/**
 * This file is a wrapper of msgpack.js.
 * The wrapper was written in order to ensure correct encoding of Algorand Transaction and other formats.
 * In particular, it matches go-algorand blockchain client, written in go (https://www.github.com/algorand/go-algorand.
 * Algorand's msgpack encoding follows to following rules -
 *  1. Every integer must be encoded to the smallest type possible (0-255-\>8bit, 256-65535-\>16bit, etx)
 *  2. All fields names must be sorted
 *  3. All empty and 0 fields should be omitted
 *  4. Every positive number must be encoded as uint
 *  5. Binary blob should be used for binary data and string for strings
 *  */
import { encode as msgpackEncode, decode as msgpackDecode, IntMode, RawBinaryString, } from 'algorand-msgpack';
import { bytesToBase64, coerceToBytes } from './binarydata.js';
import IntDecoding from '../types/intDecoding.js';
import { stringifyJSON, parseJSON, arrayEqual } from '../utils/utils.js';
// Errors
export const ERROR_CONTAINS_EMPTY_STRING = 'The object contains empty or 0 values. First empty or 0 value encountered during encoding: ';
/**
 * containsEmpty returns true if any of the object's values are empty, false otherwise.
 * Empty arrays considered empty
 * @param obj - The object to check
 * @returns \{true, empty key\} if contains empty, \{false, undefined\} otherwise
 */
function containsEmpty(obj) {
    for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            if (!obj[key] || obj[key].length === 0) {
                return { containsEmpty: true, firstEmptyKey: key };
            }
        }
    }
    return { containsEmpty: false, firstEmptyKey: undefined };
}
/**
 * msgpackRawEncode encodes objects using msgpack, regardless of whether there are
 * empty or 0 value fields.
 * @param obj - a dictionary to be encoded. May or may not contain empty or 0 values.
 * @returns msgpack representation of the object
 */
export function msgpackRawEncode(obj) {
    // enable the canonical option
    const options = { sortKeys: true };
    return msgpackEncode(obj, options);
}
/**
 * encodeObj takes a javascript object and returns its msgpack encoding
 * Note that the encoding sorts the fields alphabetically
 * @param o - js object to be encoded. Must not contain empty or 0 values.
 * @returns Uint8Array binary representation
 * @throws Error containing ERROR_CONTAINS_EMPTY_STRING if the object contains empty or zero values
 *
 * @deprecated Use {@link msgpackRawEncode} instead. Note that function does not
 *   check for empty values like this one does.
 */
export function encodeObj(obj) {
    // Check for empty values
    const emptyCheck = containsEmpty(obj);
    if (emptyCheck.containsEmpty) {
        throw new Error(ERROR_CONTAINS_EMPTY_STRING + emptyCheck.firstEmptyKey);
    }
    return msgpackRawEncode(obj);
}
function intDecodingToIntMode(intDecoding) {
    switch (intDecoding) {
        case IntDecoding.UNSAFE:
            return IntMode.UNSAFE_NUMBER;
        case IntDecoding.SAFE:
            return IntMode.SAFE_NUMBER;
        case IntDecoding.MIXED:
            return IntMode.MIXED;
        case IntDecoding.BIGINT:
            return IntMode.BIGINT;
        default:
            throw new Error(`Invalid intDecoding: ${intDecoding}`);
    }
}
/**
 * Decodes msgpack bytes into a plain JavaScript object.
 * @param buffer - The msgpack bytes to decode
 * @param options - Options for decoding, including int decoding mode. See {@link IntDecoding} for more information.
 * @returns The decoded object
 */
export function msgpackRawDecode(buffer, options) {
    const decoderOptions = {
        intMode: options?.intDecoding
            ? intDecodingToIntMode(options?.intDecoding)
            : IntMode.BIGINT,
    };
    return msgpackDecode(buffer, decoderOptions);
}
/**
 * decodeObj takes a Uint8Array and returns its javascript obj
 * @param o - Uint8Array to decode
 * @returns object
 *
 * @deprecated Use {@link msgpackRawDecode} instead. Note that this function uses `IntDecoding.MIXED`
 *   while `msgpackRawDecode` defaults to `IntDecoding.BIGINT` for int decoding, though it is
 *   configurable.
 */
export function decodeObj(o) {
    return msgpackRawDecode(o, { intDecoding: IntDecoding.MIXED });
}
/**
 * Decodes msgpack bytes into a Map object. This supports decoding non-string map keys.
 * @param encoded - The msgpack bytes to decode
 * @param options - Options for decoding, including int decoding mode. See {@link IntDecoding} for more information.
 * @returns The decoded Map object
 */
export function msgpackRawDecodeAsMap(encoded, options) {
    const decoderOptions = {
        intMode: options?.intDecoding
            ? intDecodingToIntMode(options?.intDecoding)
            : IntMode.BIGINT,
        useMap: true,
    };
    return msgpackDecode(encoded, decoderOptions);
}
function msgpackRawDecodeAsMapWithRawStrings(encoded, options) {
    const decoderOptions = {
        intMode: options?.intDecoding
            ? intDecodingToIntMode(options?.intDecoding)
            : IntMode.BIGINT,
        useMap: true,
        rawBinaryStringKeys: true,
        rawBinaryStringValues: true,
        useRawBinaryStringClass: true,
    };
    return msgpackDecode(encoded, decoderOptions);
}
export function msgpackEncodingDataToJSONEncodingData(e) {
    if (e === null || e === undefined) {
        return e;
    }
    if (e instanceof Uint8Array) {
        return bytesToBase64(e);
    }
    if (Array.isArray(e)) {
        return e.map(msgpackEncodingDataToJSONEncodingData);
    }
    if (e instanceof Map) {
        const obj = {};
        for (const [k, v] of e) {
            if (typeof k !== 'string') {
                throw new Error(`JSON map key must be a string: ${k}`);
            }
            obj[k] = msgpackEncodingDataToJSONEncodingData(v);
        }
        return obj;
    }
    return e;
}
export function jsonEncodingDataToMsgpackEncodingData(e) {
    if (e === null || e === undefined) {
        return e;
    }
    if (typeof e === 'string' || // Note, this will not convert base64 to Uint8Array
        typeof e === 'number' ||
        typeof e === 'bigint' ||
        typeof e === 'boolean') {
        return e;
    }
    if (Array.isArray(e)) {
        return e.map(jsonEncodingDataToMsgpackEncodingData);
    }
    if (typeof e === 'object') {
        const obj = new Map();
        for (const [key, value] of Object.entries(e)) {
            obj.set(key, jsonEncodingDataToMsgpackEncodingData(value));
        }
        return obj;
    }
    throw new Error(`Invalid JSON encoding data: ${e}`);
}
/* eslint-disable class-methods-use-this */
/* eslint-disable no-useless-constructor,no-empty-function */
var MsgpackObjectPathSegmentKind;
(function (MsgpackObjectPathSegmentKind) {
    MsgpackObjectPathSegmentKind[MsgpackObjectPathSegmentKind["MAP_VALUE"] = 0] = "MAP_VALUE";
    MsgpackObjectPathSegmentKind[MsgpackObjectPathSegmentKind["ARRAY_ELEMENT"] = 1] = "ARRAY_ELEMENT";
})(MsgpackObjectPathSegmentKind || (MsgpackObjectPathSegmentKind = {}));
/**
 * This class is used to index into an encoded msgpack object and extract raw strings.
 */
export class MsgpackRawStringProvider {
    constructor({ parent, segment, baseObjectBytes, }) {
        this.resolvedCache = null;
        this.resolvedCachePresent = false;
        this.parent = parent;
        this.segment = segment;
        this.baseObjectBytes = baseObjectBytes;
    }
    /**
     * Create a new provider that resolves to the current provider's map value at the given key.
     */
    withMapValue(key) {
        return new MsgpackRawStringProvider({
            parent: this,
            segment: {
                kind: MsgpackObjectPathSegmentKind.MAP_VALUE,
                key,
            },
        });
    }
    /**
     * Create a new provider that resolves to the current provider's array element at the given index.
     */
    withArrayElement(index) {
        return new MsgpackRawStringProvider({
            parent: this,
            segment: {
                kind: MsgpackObjectPathSegmentKind.ARRAY_ELEMENT,
                key: index,
            },
        });
    }
    /**
     * Get the raw string at the current location. If the current location is not a raw string, an error is thrown.
     */
    getRawStringAtCurrentLocation() {
        const resolved = this.resolve();
        if (resolved instanceof RawBinaryString) {
            // Decoded rawBinaryValue will always be a Uint8Array
            return resolved.rawBinaryValue;
        }
        throw new Error(`Invalid type. Expected RawBinaryString, got ${resolved} (${typeof resolved})`);
    }
    /**
     * Get the raw string map keys and values at the current location. If the current location is not a map, an error is thrown.
     */
    getRawStringKeysAndValuesAtCurrentLocation() {
        const resolved = this.resolve();
        if (!(resolved instanceof Map)) {
            throw new Error(`Invalid type. Expected Map, got ${resolved} (${typeof resolved})`);
        }
        const keysAndValues = new Map();
        for (const [key, value] of resolved) {
            if (key instanceof RawBinaryString) {
                // Decoded rawBinaryValue will always be a Uint8Array
                keysAndValues.set(key.rawBinaryValue, value);
            }
            else {
                throw new Error(`Invalid type for map key. Expected RawBinaryString, got ${key} (${typeof key})`);
            }
        }
        return keysAndValues;
    }
    /**
     * Resolve the provider by extracting the value it indicates from the base msgpack object.
     */
    resolve() {
        if (this.resolvedCachePresent) {
            return this.resolvedCache;
        }
        let parentResolved;
        if (this.parent) {
            parentResolved = this.parent.resolve();
        }
        else {
            // Need to parse baseObjectBytes
            parentResolved = msgpackRawDecodeAsMapWithRawStrings(this.baseObjectBytes);
        }
        if (!this.segment) {
            this.resolvedCache = parentResolved;
            this.resolvedCachePresent = true;
            return parentResolved;
        }
        if (this.segment.kind === MsgpackObjectPathSegmentKind.MAP_VALUE) {
            if (!(parentResolved instanceof Map)) {
                throw new Error(`Invalid type. Expected Map, got ${parentResolved} (${typeof parentResolved})`);
            }
            // All decoded map keys will be raw strings, and Map objects compare complex values by reference,
            // so we must check all the values for value-equality.
            if (typeof this.segment.key === 'string' ||
                this.segment.key instanceof Uint8Array ||
                this.segment.key instanceof RawBinaryString) {
                const targetBytes = this.segment.key instanceof RawBinaryString
                    ? // Decoded rawBinaryValue will always be a Uint8Array
                        this.segment.key.rawBinaryValue
                    : coerceToBytes(this.segment.key);
                const targetIsRawString = typeof this.segment.key === 'string' ||
                    this.segment.key instanceof RawBinaryString;
                for (const [key, value] of parentResolved) {
                    let potentialKeyBytes;
                    if (targetIsRawString) {
                        if (key instanceof RawBinaryString) {
                            // Decoded rawBinaryValue will always be a Uint8Array
                            potentialKeyBytes = key.rawBinaryValue;
                        }
                    }
                    else if (key instanceof Uint8Array) {
                        potentialKeyBytes = key;
                    }
                    if (potentialKeyBytes && arrayEqual(targetBytes, potentialKeyBytes)) {
                        this.resolvedCache = value;
                        break;
                    }
                }
            }
            else {
                this.resolvedCache = parentResolved.get(this.segment.key);
            }
            this.resolvedCachePresent = true;
            return this.resolvedCache;
        }
        if (this.segment.kind === MsgpackObjectPathSegmentKind.ARRAY_ELEMENT) {
            if (!Array.isArray(parentResolved)) {
                throw new Error(`Invalid type. Expected Array, got ${parentResolved} (${typeof parentResolved})`);
            }
            this.resolvedCache = parentResolved[this.segment.key];
            this.resolvedCachePresent = true;
            return this.resolvedCache;
        }
        throw new Error(`Invalid segment kind: ${this.segment.kind}`);
    }
    /**
     * Get the path string of the current location indicated by the provider. Useful for debugging.
     */
    getPathString() {
        const parentPathString = this.parent ? this.parent.getPathString() : 'root';
        if (!this.segment) {
            return parentPathString;
        }
        if (this.segment.kind === MsgpackObjectPathSegmentKind.MAP_VALUE) {
            return `${parentPathString} -> map key "${this.segment.key}" (${typeof this.segment.key})`;
        }
        if (this.segment.kind === MsgpackObjectPathSegmentKind.ARRAY_ELEMENT) {
            return `${parentPathString} -> array index ${this.segment.key} (${typeof this.segment.key})`;
        }
        return `${parentPathString} -> unknown segment kind ${this.segment.kind}`;
    }
}
/**
 * A Schema is used to prepare objects for encoding and decoding from msgpack and JSON.
 *
 * Schemas represent a specific type.
 */
export class Schema {
}
/**
 * Decode a msgpack byte array to an Encodable object.
 * @param encoded - The msgpack bytes to decode
 * @param c - The class of the object to decode. This class must match the object that was encoded.
 * @returns An instance of the class with the decoded data
 */
export function decodeMsgpack(encoded, c) {
    const decoded = msgpackRawDecodeAsMap(encoded);
    const rawStringProvider = new MsgpackRawStringProvider({
        baseObjectBytes: encoded,
    });
    return c.fromEncodingData(c.encodingSchema.fromPreparedMsgpack(decoded, rawStringProvider));
}
/**
 * Encode an Encodable object to a msgpack byte array.
 * @param e - The object to encode
 * @returns A msgpack byte array encoding of the object
 */
export function encodeMsgpack(e) {
    return msgpackRawEncode(e.getEncodingSchema().prepareMsgpack(e.toEncodingData()));
}
/**
 * Decode a JSON string to an Encodable object.
 * @param encoded - The JSON string to decode
 * @param c - The class of the object to decode. This class must match the object that was encoded.
 * @returns An instance of the class with the decoded data
 */
export function decodeJSON(encoded, c) {
    const decoded = parseJSON(encoded, {
        intDecoding: IntDecoding.BIGINT,
    });
    return c.fromEncodingData(c.encodingSchema.fromPreparedJSON(decoded));
}
/**
 * Encode an Encodable object to a JSON string.
 * @param e - The object to encode
 * @param options - Optional encoding options. See {@link EncodeJSONOptions} for more information.
 * @returns A JSON string encoding of the object
 */
export function encodeJSON(e, options) {
    const { space, ...prepareJSONOptions } = options ?? {};
    const prepared = e
        .getEncodingSchema()
        .prepareJSON(e.toEncodingData(), prepareJSONOptions);
    return stringifyJSON(prepared, undefined, space);
}
//# sourceMappingURL=encoding.js.map