"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Block = exports.SignedTxnInBlock = exports.SignedTxnWithAD = exports.ApplyData = exports.EvalDelta = exports.ValueDelta = exports.BlockHeader = exports.ParticipationUpdates = exports.UpgradeVote = exports.UpgradeState = exports.RewardState = exports.TxnCommitments = exports.StateProofTrackingData = void 0;
const index_js_1 = require("../encoding/schema/index.js");
const signedTransaction_js_1 = require("../signedTransaction.js");
/**
 * StateProofTrackingData tracks the status of state proofs.
 */
class StateProofTrackingData {
    constructor(params) {
        this.stateProofVotersCommitment = params.stateProofVotersCommitment;
        this.stateProofOnlineTotalWeight = params.stateProofOnlineTotalWeight;
        this.stateProofNextRound = params.stateProofNextRound;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return StateProofTrackingData.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['v', this.stateProofVotersCommitment],
            ['t', this.stateProofOnlineTotalWeight],
            ['n', this.stateProofNextRound],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded StateProofTrackingData: ${data}`);
        }
        return new StateProofTrackingData({
            stateProofVotersCommitment: data.get('v'),
            stateProofOnlineTotalWeight: data.get('t'),
            stateProofNextRound: data.get('n'),
        });
    }
}
exports.StateProofTrackingData = StateProofTrackingData;
StateProofTrackingData.encodingSchema = new index_js_1.NamedMapSchema((0, index_js_1.allOmitEmpty)([
    {
        key: 'v', // stateProofVotersCommitment
        valueSchema: new index_js_1.ByteArraySchema(),
    },
    {
        key: 't', // stateProofOnlineTotalWeight
        valueSchema: new index_js_1.Uint64Schema(),
    },
    {
        key: 'n', // stateProofNextRound
        valueSchema: new index_js_1.Uint64Schema(),
    },
]));
/**
 * TxnCommitments represents the commitments computed from the transactions in the block.
 * It contains multiple commitments based on different algorithms and hash functions, to support
 * different use cases.
 */
class TxnCommitments {
    constructor(params) {
        this.nativeSha512_256Commitment = params.nativeSha512_256Commitment;
        this.sha256Commitment = params.sha256Commitment;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return TxnCommitments.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['txn', this.nativeSha512_256Commitment],
            ['txn256', this.sha256Commitment],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded TxnCommitments: ${data}`);
        }
        return new TxnCommitments({
            nativeSha512_256Commitment: data.get('txn'),
            sha256Commitment: data.get('txn256'),
        });
    }
}
exports.TxnCommitments = TxnCommitments;
TxnCommitments.encodingSchema = new index_js_1.NamedMapSchema((0, index_js_1.allOmitEmpty)([
    {
        key: 'txn', // nativeSha512_256Commitment
        valueSchema: new index_js_1.FixedLengthByteArraySchema(32),
    },
    {
        key: 'txn256', // sha256Commitment
        valueSchema: new index_js_1.FixedLengthByteArraySchema(32),
    },
]));
/**
 * RewardsState represents the global parameters controlling the rate at which accounts accrue rewards.
 */
class RewardState {
    constructor(params) {
        this.feeSink = params.feeSink;
        this.rewardsPool = params.rewardsPool;
        this.rewardsLevel = params.rewardsLevel;
        this.rewardsRate = params.rewardsRate;
        this.rewardsResidue = params.rewardsResidue;
        this.rewardsRecalculationRound = params.rewardsRecalculationRound;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return RewardState.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['fees', this.feeSink],
            ['rwd', this.rewardsPool],
            ['earn', this.rewardsLevel],
            ['rate', this.rewardsRate],
            ['frac', this.rewardsResidue],
            ['rwcalr', this.rewardsRecalculationRound],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded RewardState: ${data}`);
        }
        return new RewardState({
            feeSink: data.get('fees'),
            rewardsPool: data.get('rwd'),
            rewardsLevel: data.get('earn'),
            rewardsRate: data.get('rate'),
            rewardsResidue: data.get('frac'),
            rewardsRecalculationRound: data.get('rwcalr'),
        });
    }
}
exports.RewardState = RewardState;
RewardState.encodingSchema = new index_js_1.NamedMapSchema((0, index_js_1.allOmitEmpty)([
    {
        key: 'fees', // feeSink
        valueSchema: new index_js_1.AddressSchema(),
    },
    {
        key: 'rwd', // rewardsPool
        valueSchema: new index_js_1.AddressSchema(),
    },
    {
        key: 'earn', // rewardsLevel
        valueSchema: new index_js_1.Uint64Schema(),
    },
    {
        key: 'rate', // rewardsRate
        valueSchema: new index_js_1.Uint64Schema(),
    },
    {
        key: 'frac', // rewardsResidue
        valueSchema: new index_js_1.Uint64Schema(),
    },
    {
        key: 'rwcalr', // rewardsRecalculationRound
        valueSchema: new index_js_1.Uint64Schema(),
    },
]));
/**
 * UpgradeState tracks the protocol upgrade state machine.  It is, strictly speaking, computable from
 * the history of all UpgradeVotes but we keep it in the block for explicitness and convenience
 * (instead of materializing it separately, like balances).
 */
class UpgradeState {
    constructor(params) {
        this.currentProtocol = params.currentProtocol;
        this.nextProtocol = params.nextProtocol;
        this.nextProtocolApprovals = params.nextProtocolApprovals;
        this.nextProtocolVoteBefore = params.nextProtocolVoteBefore;
        this.nextProtocolSwitchOn = params.nextProtocolSwitchOn;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return UpgradeState.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['proto', this.currentProtocol],
            ['nextproto', this.nextProtocol],
            ['nextyes', this.nextProtocolApprovals],
            ['nextbefore', this.nextProtocolVoteBefore],
            ['nextswitch', this.nextProtocolSwitchOn],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded UpgradeState: ${data}`);
        }
        return new UpgradeState({
            currentProtocol: data.get('proto'),
            nextProtocol: data.get('nextproto'),
            nextProtocolApprovals: data.get('nextyes'),
            nextProtocolVoteBefore: data.get('nextbefore'),
            nextProtocolSwitchOn: data.get('nextswitch'),
        });
    }
}
exports.UpgradeState = UpgradeState;
UpgradeState.encodingSchema = new index_js_1.NamedMapSchema((0, index_js_1.allOmitEmpty)([
    {
        key: 'proto', // currentProtocol
        valueSchema: new index_js_1.StringSchema(),
    },
    {
        key: 'nextproto', // nextProtocol
        valueSchema: new index_js_1.StringSchema(),
    },
    {
        key: 'nextyes', // nextProtocolApprovals
        valueSchema: new index_js_1.Uint64Schema(),
    },
    {
        key: 'nextbefore', // nextProtocolVoteBefore
        valueSchema: new index_js_1.Uint64Schema(),
    },
    {
        key: 'nextswitch', // nextProtocolSwitchOn
        valueSchema: new index_js_1.Uint64Schema(),
    },
]));
/**
 * UpgradeVote represents the vote of the block proposer with respect to protocol upgrades.
 */
class UpgradeVote {
    constructor(params) {
        this.upgradePropose = params.upgradePropose;
        this.upgradeDelay = params.upgradeDelay;
        this.upgradeApprove = params.upgradeApprove;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return UpgradeVote.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['upgradeprop', this.upgradePropose],
            ['upgradedelay', this.upgradeDelay],
            ['upgradeyes', this.upgradeApprove],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded UpgradeVote: ${data}`);
        }
        return new UpgradeVote({
            upgradePropose: data.get('upgradeprop'),
            upgradeDelay: data.get('upgradedelay'),
            upgradeApprove: data.get('upgradeyes'),
        });
    }
}
exports.UpgradeVote = UpgradeVote;
UpgradeVote.encodingSchema = new index_js_1.NamedMapSchema((0, index_js_1.allOmitEmpty)([
    {
        key: 'upgradeprop', // upgradePropose
        valueSchema: new index_js_1.StringSchema(),
    },
    {
        key: 'upgradedelay', // upgradeDelay
        valueSchema: new index_js_1.Uint64Schema(),
    },
    {
        key: 'upgradeyes', // upgradeApprove
        valueSchema: new index_js_1.BooleanSchema(),
    },
]));
/**
 * ParticipationUpdates represents participation account data that needs to be checked/acted on by
 * the network
 */
class ParticipationUpdates {
    constructor(params) {
        this.expiredParticipationAccounts = params.expiredParticipationAccounts;
        this.absentParticipationAccounts = params.absentParticipationAccounts;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return ParticipationUpdates.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['partupdrmv', this.expiredParticipationAccounts],
            ['partupdabs', this.absentParticipationAccounts],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded ParticipationUpdates: ${data}`);
        }
        return new ParticipationUpdates({
            expiredParticipationAccounts: data.get('partupdrmv'),
            absentParticipationAccounts: data.get('partupdabs'),
        });
    }
}
exports.ParticipationUpdates = ParticipationUpdates;
ParticipationUpdates.encodingSchema = new index_js_1.NamedMapSchema((0, index_js_1.allOmitEmpty)([
    {
        key: 'partupdrmv', // expiredParticipationAccounts
        valueSchema: new index_js_1.ArraySchema(new index_js_1.AddressSchema()),
    },
    {
        key: 'partupdabs', // absentParticipationAccounts
        valueSchema: new index_js_1.ArraySchema(new index_js_1.AddressSchema()),
    },
]));
/**
 * Represents the metadata and state of a block.
 *
 * For more information, refer to: https://github.com/algorand/go-algorand/blob/master/data/bookkeeping/block.go
 */
class BlockHeader {
    constructor(params) {
        this.round = params.round;
        this.branch = params.branch;
        this.seed = params.seed;
        this.txnCommitments = params.txnCommitments;
        this.timestamp = params.timestamp;
        this.genesisID = params.genesisID;
        this.genesisHash = params.genesisHash;
        this.proposer = params.proposer;
        this.feesCollected = params.feesCollected;
        this.bonus = params.bonus;
        this.proposerPayout = params.proposerPayout;
        this.rewardState = params.rewardState;
        this.upgradeState = params.upgradeState;
        this.upgradeVote = params.upgradeVote;
        this.txnCounter = params.txnCounter;
        this.stateproofTracking = params.stateproofTracking;
        this.participationUpdates = params.participationUpdates;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return BlockHeader.encodingSchema;
    }
    toEncodingData() {
        const data = new Map([
            ['rnd', this.round],
            ['prev', this.branch],
            ['seed', this.seed],
            ['ts', this.timestamp],
            ['gen', this.genesisID],
            ['gh', this.genesisHash],
            ['prp', this.proposer],
            ['fc', this.feesCollected],
            ['bi', this.bonus],
            ['pp', this.proposerPayout],
            ['tc', this.txnCounter],
            [
                'spt',
                (0, index_js_1.convertMap)(this.stateproofTracking, (key, value) => [
                    key,
                    value.toEncodingData(),
                ]),
            ],
        ]);
        return (0, index_js_1.combineMaps)(data, this.txnCommitments.toEncodingData(), this.rewardState.toEncodingData(), this.upgradeState.toEncodingData(), this.upgradeVote.toEncodingData(), this.participationUpdates.toEncodingData());
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded BlockHeader: ${data}`);
        }
        return new BlockHeader({
            round: data.get('rnd'),
            branch: data.get('prev'),
            seed: data.get('seed'),
            txnCommitments: TxnCommitments.fromEncodingData(data),
            timestamp: data.get('ts'),
            genesisID: data.get('gen'),
            genesisHash: data.get('gh'),
            proposer: data.get('prp'),
            feesCollected: data.get('fc'),
            bonus: data.get('bi'),
            proposerPayout: data.get('pp'),
            rewardState: RewardState.fromEncodingData(data),
            upgradeState: UpgradeState.fromEncodingData(data),
            upgradeVote: UpgradeVote.fromEncodingData(data),
            txnCounter: data.get('tc'),
            stateproofTracking: (0, index_js_1.convertMap)(data.get('spt'), (key, value) => [
                Number(key),
                StateProofTrackingData.fromEncodingData(value),
            ]),
            participationUpdates: ParticipationUpdates.fromEncodingData(data),
        });
    }
}
exports.BlockHeader = BlockHeader;
BlockHeader.encodingSchema = new index_js_1.NamedMapSchema((0, index_js_1.allOmitEmpty)([
    {
        key: 'rnd', // round
        valueSchema: new index_js_1.Uint64Schema(),
    },
    {
        key: 'prev', // branch
        valueSchema: new index_js_1.BlockHashSchema(),
    },
    {
        key: 'seed', // seed
        valueSchema: new index_js_1.ByteArraySchema(),
    },
    {
        key: '',
        valueSchema: TxnCommitments.encodingSchema,
        embedded: true,
    },
    {
        key: 'ts', // timestamp
        valueSchema: new index_js_1.Uint64Schema(),
    },
    {
        key: 'gen', // genesisID
        valueSchema: new index_js_1.StringSchema(),
    },
    {
        key: 'gh', // genesisHash
        valueSchema: new index_js_1.FixedLengthByteArraySchema(32),
    },
    {
        key: 'prp', // proposer
        valueSchema: new index_js_1.AddressSchema(),
    },
    {
        key: 'fc', // feesCollected
        valueSchema: new index_js_1.Uint64Schema(),
    },
    {
        key: 'bi', // bonus
        valueSchema: new index_js_1.Uint64Schema(),
    },
    {
        key: 'pp', // proposerPayout
        valueSchema: new index_js_1.Uint64Schema(),
    },
    {
        key: '',
        valueSchema: RewardState.encodingSchema,
        embedded: true,
    },
    {
        key: '',
        valueSchema: UpgradeState.encodingSchema,
        embedded: true,
    },
    {
        key: '',
        valueSchema: UpgradeVote.encodingSchema,
        embedded: true,
    },
    {
        key: 'tc', // txnCounter
        valueSchema: new index_js_1.Uint64Schema(),
    },
    {
        key: 'spt', // stateproofTracking
        valueSchema: new index_js_1.Uint64MapSchema(StateProofTrackingData.encodingSchema),
    },
    {
        key: '',
        valueSchema: ParticipationUpdates.encodingSchema,
        embedded: true,
    },
]));
class ValueDelta {
    constructor(params) {
        this.action = params.action;
        this.bytes = params.bytes;
        this.uint = params.uint;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return ValueDelta.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['at', this.action],
            ['bs', this.bytes],
            ['ui', this.uint],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded ValueDelta: ${data}`);
        }
        return new ValueDelta({
            action: Number(data.get('at')),
            bytes: data.get('bs'),
            uint: data.get('ui'),
        });
    }
}
exports.ValueDelta = ValueDelta;
ValueDelta.encodingSchema = new index_js_1.NamedMapSchema((0, index_js_1.allOmitEmpty)([
    {
        key: 'at', // action
        valueSchema: new index_js_1.Uint64Schema(),
    },
    {
        key: 'bs', // bytes
        valueSchema: new index_js_1.SpecialCaseBinaryStringSchema(),
    },
    {
        key: 'ui', // uint
        valueSchema: new index_js_1.Uint64Schema(),
    },
]));
class EvalDelta {
    static get encodingSchema() {
        // This is declared like this in order to break the circular dependency of
        // SignedTxnWithAD -> ApplyData -> EvalDelta -> SignedTxnWithAD
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries(...(0, index_js_1.allOmitEmpty)([
                {
                    key: 'gd', // globalDelta
                    valueSchema: new index_js_1.OptionalSchema(new index_js_1.SpecialCaseBinaryStringMapSchema(ValueDelta.encodingSchema)),
                },
                {
                    key: 'ld', // localDeltas
                    valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64MapSchema(new index_js_1.SpecialCaseBinaryStringMapSchema(ValueDelta.encodingSchema))),
                },
                {
                    key: 'sa', // sharedAccts
                    valueSchema: new index_js_1.OptionalSchema(new index_js_1.ArraySchema(new index_js_1.AddressSchema())),
                },
                {
                    key: 'lg', // logs
                    valueSchema: new index_js_1.OptionalSchema(new index_js_1.ArraySchema(new index_js_1.SpecialCaseBinaryStringSchema())),
                },
                {
                    key: 'itx', // innerTxns
                    valueSchema: new index_js_1.OptionalSchema(
                    // eslint-disable-next-line no-use-before-define
                    new index_js_1.ArraySchema(SignedTxnWithAD.encodingSchema)),
                },
            ]));
        }
        return this.encodingSchemaValue;
    }
    constructor(params) {
        this.globalDelta = params.globalDelta ?? new Map();
        this.localDeltas =
            params.localDeltas ?? new Map();
        this.sharedAccts = params.sharedAccts ?? [];
        this.logs = params.logs ?? [];
        this.innerTxns = params.innerTxns ?? [];
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return EvalDelta.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            [
                'gd',
                (0, index_js_1.convertMap)(this.globalDelta, (key, value) => [
                    key,
                    value.toEncodingData(),
                ]),
            ],
            [
                'ld',
                (0, index_js_1.convertMap)(this.localDeltas, (key, value) => [
                    key,
                    (0, index_js_1.convertMap)(value, (k, v) => [k, v.toEncodingData()]),
                ]),
            ],
            ['sa', this.sharedAccts],
            ['lg', this.logs],
            ['itx', this.innerTxns.map((t) => t.toEncodingData())],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded EvalDelta: ${data}`);
        }
        return new EvalDelta({
            globalDelta: data.get('gd')
                ? (0, index_js_1.convertMap)(data.get('gd'), (key, value) => [key, ValueDelta.fromEncodingData(value)])
                : undefined,
            localDeltas: data.get('ld')
                ? (0, index_js_1.convertMap)(data.get('ld'), (key, value) => [
                    Number(key),
                    (0, index_js_1.convertMap)(value, (k, v) => [k, ValueDelta.fromEncodingData(v)]),
                ])
                : undefined,
            sharedAccts: data.get('sa'),
            logs: data.get('lg'),
            // eslint-disable-next-line no-use-before-define
            innerTxns: (data.get('itx') ?? []).map(SignedTxnWithAD.fromEncodingData),
        });
    }
}
exports.EvalDelta = EvalDelta;
class ApplyData {
    static get encodingSchema() {
        // This is declared like this in order to break the circular dependency of
        // SignedTxnWithAD -> ApplyData -> EvalDelta -> SignedTxnWithAD
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries(...(0, index_js_1.allOmitEmpty)([
                {
                    key: 'ca', // closingAmount
                    valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()),
                },
                {
                    key: 'aca', // assetClosingAmount
                    valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()),
                },
                {
                    key: 'rs', // senderRewards
                    valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()),
                },
                {
                    key: 'rr', // receiverRewards
                    valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()),
                },
                {
                    key: 'rc', // closeRewards
                    valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()),
                },
                {
                    key: 'dt', // evalDelta
                    valueSchema: new index_js_1.OptionalSchema(EvalDelta.encodingSchema),
                },
                {
                    key: 'caid', // configAsset
                    valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()),
                },
                {
                    key: 'apid', // applicationID
                    valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()),
                },
            ]));
        }
        return this.encodingSchemaValue;
    }
    constructor(params) {
        this.closingAmount = params.closingAmount;
        this.assetClosingAmount = params.assetClosingAmount;
        this.senderRewards = params.senderRewards;
        this.receiverRewards = params.receiverRewards;
        this.closeRewards = params.closeRewards;
        this.evalDelta = params.evalDelta;
        this.configAsset = params.configAsset;
        this.applicationID = params.applicationID;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return ApplyData.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['ca', this.closingAmount],
            ['aca', this.assetClosingAmount],
            ['rs', this.senderRewards],
            ['rr', this.receiverRewards],
            ['rc', this.closeRewards],
            ['dt', this.evalDelta ? this.evalDelta.toEncodingData() : undefined],
            ['caid', this.configAsset],
            ['apid', this.applicationID],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded ApplyData: ${data}`);
        }
        return new ApplyData({
            closingAmount: data.get('ca'),
            assetClosingAmount: data.get('aca'),
            senderRewards: data.get('rs'),
            receiverRewards: data.get('rr'),
            closeRewards: data.get('rc'),
            evalDelta: data.get('dt')
                ? EvalDelta.fromEncodingData(data.get('dt'))
                : undefined,
            configAsset: data.get('caid'),
            applicationID: data.get('apid'),
        });
    }
}
exports.ApplyData = ApplyData;
class SignedTxnWithAD {
    static get encodingSchema() {
        // This is declared like this in order to break the circular dependency of
        // SignedTxnWithAD -> ApplyData -> EvalDelta -> SignedTxnWithAD
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries(...(0, index_js_1.allOmitEmpty)([
                {
                    key: '',
                    valueSchema: signedTransaction_js_1.SignedTransaction.encodingSchema,
                    embedded: true,
                },
                {
                    key: '',
                    valueSchema: ApplyData.encodingSchema,
                    embedded: true,
                },
            ]));
        }
        return this.encodingSchemaValue;
    }
    constructor(params) {
        this.signedTxn = params.signedTxn;
        this.applyData = params.applyData;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return SignedTxnWithAD.encodingSchema;
    }
    toEncodingData() {
        return (0, index_js_1.combineMaps)(this.signedTxn.toEncodingData(), this.applyData.toEncodingData());
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded SignedTxnWithAD: ${data}`);
        }
        return new SignedTxnWithAD({
            signedTxn: signedTransaction_js_1.SignedTransaction.fromEncodingData(data),
            applyData: ApplyData.fromEncodingData(data),
        });
    }
}
exports.SignedTxnWithAD = SignedTxnWithAD;
/**
 * SignedTxnInBlock is how a signed transaction is encoded in a block.
 */
class SignedTxnInBlock {
    constructor(params) {
        this.signedTxn = params.signedTxn;
        this.hasGenesisID = params.hasGenesisID;
        this.hasGenesisHash = params.hasGenesisHash;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return SignedTxnInBlock.encodingSchema;
    }
    toEncodingData() {
        const data = new Map([
            ['hgi', this.hasGenesisID],
            ['hgh', this.hasGenesisHash],
        ]);
        return (0, index_js_1.combineMaps)(data, this.signedTxn.toEncodingData());
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded SignedTxnInBlock: ${data}`);
        }
        return new SignedTxnInBlock({
            signedTxn: SignedTxnWithAD.fromEncodingData(data),
            hasGenesisID: data.get('hgi'),
            hasGenesisHash: data.get('hgh'),
        });
    }
}
exports.SignedTxnInBlock = SignedTxnInBlock;
SignedTxnInBlock.encodingSchema = new index_js_1.NamedMapSchema((0, index_js_1.allOmitEmpty)([
    {
        key: '',
        valueSchema: SignedTxnWithAD.encodingSchema,
        embedded: true,
    },
    {
        key: 'hgi', // hasGenesisID
        valueSchema: new index_js_1.BooleanSchema(),
    },
    {
        key: 'hgh', // hasGenesisHash
        valueSchema: new index_js_1.BooleanSchema(),
    },
]));
/**
 * A Block contains the Payset and metadata corresponding to a given Round.
 */
class Block {
    constructor(params) {
        this.header = params.header;
        this.payset = params.payset;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return Block.encodingSchema;
    }
    toEncodingData() {
        const data = new Map([
            ['txns', this.payset.map((p) => p.toEncodingData())],
        ]);
        return (0, index_js_1.combineMaps)(data, this.header.toEncodingData());
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded BlockHeader: ${data}`);
        }
        return new Block({
            header: BlockHeader.fromEncodingData(data),
            payset: data.get('txns').map(SignedTxnInBlock.fromEncodingData),
        });
    }
}
exports.Block = Block;
Block.encodingSchema = new index_js_1.NamedMapSchema((0, index_js_1.allOmitEmpty)([
    {
        key: '',
        valueSchema: BlockHeader.encodingSchema,
        embedded: true,
    },
    {
        key: 'txns', // payset
        valueSchema: new index_js_1.ArraySchema(SignedTxnInBlock.encodingSchema),
    },
]));
//# sourceMappingURL=block.js.map