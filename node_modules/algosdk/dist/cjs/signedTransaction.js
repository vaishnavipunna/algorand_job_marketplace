"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodeUnsignedSimulateTransaction = exports.decodeSignedTransaction = exports.SignedTransaction = void 0;
const encoding_js_1 = require("./encoding/encoding.js");
const transaction_js_1 = require("./transaction.js");
const logicsig_js_1 = require("./logicsig.js");
const index_js_1 = require("./types/transactions/index.js");
const index_js_2 = require("./encoding/schema/index.js");
class SignedTransaction {
    constructor({ txn, sig, msig, lsig, sgnr, }) {
        this.txn = txn;
        this.sig = sig;
        this.msig = msig;
        this.lsig = lsig;
        this.sgnr = sgnr;
        let numberOfSigs = 0;
        if (sig)
            numberOfSigs += 1;
        if (msig)
            numberOfSigs += 1;
        if (lsig)
            numberOfSigs += 1;
        if (numberOfSigs > 1) {
            throw new Error(`SignedTransaction must not have more than 1 signature. Got ${numberOfSigs}`);
        }
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return SignedTransaction.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['txn', this.txn.toEncodingData()],
            ['sig', this.sig],
            [
                'msig',
                this.msig ? (0, index_js_1.encodedMultiSigToEncodingData)(this.msig) : undefined,
            ],
            ['lsig', this.lsig ? this.lsig.toEncodingData() : undefined],
            ['sgnr', this.sgnr],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded SignedTransaction: ${data}`);
        }
        return new SignedTransaction({
            txn: transaction_js_1.Transaction.fromEncodingData(data.get('txn')),
            sig: data.get('sig'),
            msig: data.get('msig')
                ? (0, index_js_1.encodedMultiSigFromEncodingData)(data.get('msig'))
                : undefined,
            lsig: data.get('lsig')
                ? logicsig_js_1.LogicSig.fromEncodingData(data.get('lsig'))
                : undefined,
            sgnr: data.get('sgnr'),
        });
    }
}
exports.SignedTransaction = SignedTransaction;
SignedTransaction.encodingSchema = new index_js_2.NamedMapSchema((0, index_js_2.allOmitEmpty)([
    {
        key: 'txn',
        valueSchema: transaction_js_1.Transaction.encodingSchema,
    },
    {
        key: 'sig',
        valueSchema: new index_js_2.OptionalSchema(new index_js_2.FixedLengthByteArraySchema(64)),
    },
    {
        key: 'msig',
        valueSchema: new index_js_2.OptionalSchema(index_js_1.ENCODED_MULTISIG_SCHEMA),
    },
    {
        key: 'lsig',
        valueSchema: new index_js_2.OptionalSchema(logicsig_js_1.LogicSig.encodingSchema),
    },
    {
        key: 'sgnr',
        valueSchema: new index_js_2.OptionalSchema(new index_js_2.AddressSchema()),
    },
]));
/**
 * decodeSignedTransaction takes a Uint8Array (from transaction.signTxn) and converts it to an object
 * containing the Transaction (txn), the signature (sig), and the auth-addr field if applicable (sgnr)
 * @param transactionBuffer - the Uint8Array containing a transaction
 * @returns containing a Transaction, the signature, and possibly an auth-addr field
 */
function decodeSignedTransaction(transactionBuffer) {
    return (0, encoding_js_1.decodeMsgpack)(transactionBuffer, SignedTransaction);
}
exports.decodeSignedTransaction = decodeSignedTransaction;
/**
 * encodeUnsignedSimulateTransaction takes a txnBuilder.Transaction object,
 * converts it into a SignedTransaction-like object, and converts it to a Buffer.
 *
 * Note: this function should only be used to simulate unsigned transactions.
 *
 * @param txn - Transaction object to simulate.
 */
function encodeUnsignedSimulateTransaction(txn) {
    const stxn = new SignedTransaction({ txn });
    return (0, encoding_js_1.encodeMsgpack)(stxn);
}
exports.encodeUnsignedSimulateTransaction = encodeUnsignedSimulateTransaction;
//# sourceMappingURL=signedTransaction.js.map