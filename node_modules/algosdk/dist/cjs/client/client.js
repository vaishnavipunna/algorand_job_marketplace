"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HTTPClient = exports.HTTPClientResponse = void 0;
const utils = __importStar(require("../utils/utils.js"));
const urlTokenBaseHTTPClient_js_1 = require("./urlTokenBaseHTTPClient.js");
class HTTPClientResponse {
    constructor(options) {
        this.body = options.body;
        this.text = options.text;
        this.format = options.format;
        this.headers = options.headers;
        this.status = options.status;
        this.ok = options.ok;
    }
    /**
     * Returns the response body as a string, ready to be parsed as JSON.
     */
    getJSONText() {
        if (this.text === undefined) {
            throw new Error(`Response body does not contain JSON data. Format is ${this.format}`);
        }
        return this.text;
    }
    /**
     * Parses the response body as JSON with the given options.
     */
    parseBodyAsJSON(jsonOptions) {
        if (this.text === undefined) {
            throw new Error(`Response body does not contain JSON data. Format is ${this.format}`);
        }
        // eslint-disable-next-line no-use-before-define
        return HTTPClient.parseJSON(this.text, this.status, jsonOptions);
    }
}
exports.HTTPClientResponse = HTTPClientResponse;
/**
 * Remove falsy values or values with a length of 0 from an object.
 */
function removeFalsyOrEmpty(obj) {
    for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            // eslint-disable-next-line no-param-reassign
            if (!obj[key] || obj[key].length === 0)
                delete obj[key];
        }
    }
    return obj;
}
/**
 * Create a new object with lower-case keys
 * See https://codereview.stackexchange.com/a/162418
 * Used to ensure all headers are lower-case and to work more easily with them
 */
function tolowerCaseKeys(o) {
    /* eslint-disable no-param-reassign,no-return-assign,no-sequences */
    return Object.keys(o).reduce((c, k) => ((c[k.toLowerCase()] = o[k]), c), {});
    /* eslint-enable no-param-reassign,no-return-assign,no-sequences */
}
/**
 * getAcceptFormat returns the correct Accept header depending on the
 * requested format.
 */
function getAcceptFormat(query) {
    if (query !== undefined &&
        Object.prototype.hasOwnProperty.call(query, 'format')) {
        switch (query.format) {
            case 'msgpack':
                return 'application/msgpack';
            case 'json':
            default:
                return 'application/json';
        }
    }
    else
        return 'application/json';
}
/**
 * HTTPClient is a wrapper around a BaseHTTPClient
 * It takes care of setting the proper "Accept" header and of
 * decoding the JSON outputs.
 */
class HTTPClient {
    constructor(bcOrTokenHeader, baseServer, port, defaultHeaders = {}) {
        if (baseServer !== undefined) {
            this.bc = new urlTokenBaseHTTPClient_js_1.URLTokenBaseHTTPClient(bcOrTokenHeader, baseServer, port, defaultHeaders);
        }
        else {
            this.bc = bcOrTokenHeader;
        }
    }
    /**
     * Parse JSON using utils.parseJSON
     *
     * @param text - JSON data
     * @param status - Status of the response (used in case parseJSON fails)
     * @param jsonOptions - Options object to use to decode JSON responses. See
     *   utils.parseJSON for the options available.
     */
    static parseJSON(text, status, jsonOptions) {
        try {
            if (!text) {
                return null;
            }
            return utils.parseJSON(text, jsonOptions);
        }
        catch (err_) {
            const err = err_;
            // return the raw response if the response parsing fails
            err.rawResponse = text || null;
            // return the http status code if the response parsing fails
            err.statusCode = status;
            throw err;
        }
    }
    /**
     * Serialize the data according to the requestHeaders
     * Assumes that requestHeaders contain a key "content-type"
     * If the content-type is "application/json", data is JSON serialized
     * Otherwise, data needs to be either an UTF-8 string that is converted to an Uint8Array
     * or an Uint8Array
     * @private
     */
    static serializeData(data, requestHeaders) {
        if (!data) {
            return new Uint8Array(0); // empty Uint8Array
        }
        if (requestHeaders['content-type'] === 'application/json') {
            return new TextEncoder().encode(utils.stringifyJSON(data));
        }
        if (typeof data === 'string') {
            return new TextEncoder().encode(data);
        }
        if (data instanceof Uint8Array) {
            return data;
        }
        throw new Error('provided data is neither a string nor a Uint8Array and content-type is not application/json');
    }
    /**
     * Convert a BaseHTTPClientResponse into a full HTTPClientResponse
     * Parse the body in
     * Modifies in place res and return the result
     */
    static prepareResponse(res, format) {
        const { body } = res;
        let text;
        if (format !== 'application/msgpack') {
            text = (body && new TextDecoder().decode(body)) || '';
        }
        return new HTTPClientResponse({
            ...res,
            format,
            text,
            ok: Math.trunc(res.status / 100) === 2,
        });
    }
    /**
     * Prepare an error with a response
     * (the type of errors BaseHTTPClient are supposed to throw)
     * by adding the status and preparing the internal response
     * @private
     */
    static prepareResponseError(err) {
        if (err.response) {
            // eslint-disable-next-line no-param-reassign
            err.response = HTTPClient.prepareResponse(err.response, 'application/json');
            // eslint-disable-next-line no-param-reassign
            err.status = err.response.status;
        }
        return err;
    }
    /**
     * Send a GET request.
     *
     * @param options - The options to use for the request.
     * @param options.relativePath - The path of the request.
     * @param options.query - An object containing the query parameters of the request.
     * @param options.requestHeaders - An object containing additional request headers to use.
     *   or not.
     * @param options.customOptions - An object containing additional options to pass to the
     *   underlying BaseHTTPClient instance.
     * @returns Response object.
     */
    async get({ relativePath, query, requestHeaders, customOptions, }) {
        const format = getAcceptFormat(query);
        const fullHeaders = { ...(requestHeaders ?? {}), accept: format };
        try {
            const res = await this.bc.get(relativePath, query ? removeFalsyOrEmpty(query) : undefined, fullHeaders, customOptions);
            return HTTPClient.prepareResponse(res, format);
        }
        catch (err) {
            throw HTTPClient.prepareResponseError(err);
        }
    }
    /**
     * Send a POST request.
     * If no content-type present, adds the header "content-type: application/json"
     * and data is serialized in JSON (if not empty)
     * @param options - The options to use for the request.
     */
    async post({ relativePath, data, query, requestHeaders, customOptions, }) {
        const fullHeaders = {
            'content-type': 'application/json',
            ...tolowerCaseKeys(requestHeaders ?? {}),
        };
        try {
            const res = await this.bc.post(relativePath, HTTPClient.serializeData(data, fullHeaders), query, fullHeaders, customOptions);
            return HTTPClient.prepareResponse(res, 'application/json');
        }
        catch (err) {
            throw HTTPClient.prepareResponseError(err);
        }
    }
    /**
     * Send a DELETE request.
     * If no content-type present, adds the header "content-type: application/json"
     * and data is serialized in JSON (if not empty)
     * @param options - The options to use for the request.
     */
    async delete({ relativePath, data, requestHeaders, customOptions, }) {
        const fullHeaders = {
            'content-type': 'application/json',
            ...tolowerCaseKeys(requestHeaders ?? {}),
        };
        try {
            const res = await this.bc.delete(relativePath, typeof data !== 'undefined'
                ? HTTPClient.serializeData(data, fullHeaders)
                : undefined, undefined, fullHeaders, customOptions);
            return HTTPClient.prepareResponse(res, 'application/json');
        }
        catch (err) {
            throw HTTPClient.prepareResponseError(err);
        }
    }
}
exports.HTTPClient = HTTPClient;
//# sourceMappingURL=client.js.map