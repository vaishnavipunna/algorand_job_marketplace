"use strict";
/**
 * NOTICE: This file was generated. Editing this file manually is not recommended.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PendingTransactionsResponse = exports.PendingTransactionResponse = exports.NodeStatusResponse = exports.LightBlockHeaderProof = exports.LedgerStateDeltaForTransactionGroup = exports.GetSyncRoundResponse = exports.GetBlockTimeStampOffsetResponse = exports.GenesisAllocation = exports.Genesis = exports.EvalDeltaKeyValue = exports.EvalDelta = exports.ErrorResponse = exports.DryrunTxnResult = exports.DryrunState = exports.DryrunSource = exports.DryrunResponse = exports.DryrunRequest = exports.DisassembleResponse = exports.CompileResponse = exports.BuildVersion = exports.BoxesResponse = exports.BoxReference = exports.BoxDescriptor = exports.Box = exports.BlockTxidsResponse = exports.BlockResponse = exports.BlockLogsResponse = exports.BlockHashResponse = exports.AvmValue = exports.AvmKeyValue = exports.AssetParams = exports.AssetHoldingReference = exports.AssetHolding = exports.Asset = exports.ApplicationStateSchema = exports.ApplicationStateOperation = exports.ApplicationParams = exports.ApplicationLocalState = exports.ApplicationLocalReference = exports.ApplicationKVStorage = exports.ApplicationInitialStates = exports.Application = exports.AppCallLogs = exports.AccountStateDelta = exports.AccountParticipation = exports.AccountAssetsInformationResponse = exports.AccountAssetResponse = exports.AccountAssetHolding = exports.AccountApplicationResponse = exports.Account = void 0;
exports.Version = exports.TransactionProof = exports.TransactionParametersResponse = exports.TransactionGroupLedgerStateDeltasForRoundResponse = exports.TealValue = exports.TealKeyValue = exports.SupplyResponse = exports.StateProofMessage = exports.StateProof = exports.SimulationTransactionExecTrace = exports.SimulationOpcodeTraceUnit = exports.SimulationEvalOverrides = exports.SimulateUnnamedResourcesAccessed = exports.SimulateTransactionResult = exports.SimulateTransactionGroupResult = exports.SimulateTraceConfig = exports.SimulateResponse = exports.SimulateRequestTransactionGroup = exports.SimulateRequest = exports.SimulateInitialStates = exports.ScratchChange = exports.PostTransactionsResponse = void 0;
/* eslint-disable no-use-before-define */
const utils_js_1 = require("../../../../utils/utils.js");
const index_js_1 = require("../../../../encoding/schema/index.js");
const binarydata_js_1 = require("../../../../encoding/binarydata.js");
const block_js_1 = require("../../../../types/block.js");
const statedelta_js_1 = require("../../../../types/statedelta.js");
const signedTransaction_js_1 = require("../../../../signedTransaction.js");
const address_js_1 = require("../../../../encoding/address.js");
const untypedmodel_js_1 = require("../../untypedmodel.js");
/**
 * Account information at a given round.
 * Definition:
 * data/basics/userBalance.go : AccountData
 */
class Account {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: 'address', valueSchema: new index_js_1.StringSchema(), omitEmpty: true }, { key: 'amount', valueSchema: new index_js_1.Uint64Schema(), omitEmpty: true }, {
                key: 'amount-without-pending-rewards',
                valueSchema: new index_js_1.Uint64Schema(),
                omitEmpty: true,
            }, {
                key: 'min-balance',
                valueSchema: new index_js_1.Uint64Schema(),
                omitEmpty: true,
            }, {
                key: 'pending-rewards',
                valueSchema: new index_js_1.Uint64Schema(),
                omitEmpty: true,
            }, { key: 'rewards', valueSchema: new index_js_1.Uint64Schema(), omitEmpty: true }, { key: 'round', valueSchema: new index_js_1.Uint64Schema(), omitEmpty: true }, { key: 'status', valueSchema: new index_js_1.StringSchema(), omitEmpty: true }, {
                key: 'total-apps-opted-in',
                valueSchema: new index_js_1.Uint64Schema(),
                omitEmpty: true,
            }, {
                key: 'total-assets-opted-in',
                valueSchema: new index_js_1.Uint64Schema(),
                omitEmpty: true,
            }, {
                key: 'total-created-apps',
                valueSchema: new index_js_1.Uint64Schema(),
                omitEmpty: true,
            }, {
                key: 'total-created-assets',
                valueSchema: new index_js_1.Uint64Schema(),
                omitEmpty: true,
            }, {
                key: 'apps-local-state',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.ArraySchema(ApplicationLocalState.encodingSchema)),
                omitEmpty: true,
            }, {
                key: 'apps-total-extra-pages',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()),
                omitEmpty: true,
            }, {
                key: 'apps-total-schema',
                valueSchema: new index_js_1.OptionalSchema(ApplicationStateSchema.encodingSchema),
                omitEmpty: true,
            }, {
                key: 'assets',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.ArraySchema(AssetHolding.encodingSchema)),
                omitEmpty: true,
            }, {
                key: 'auth-addr',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.StringSchema()),
                omitEmpty: true,
            }, {
                key: 'created-apps',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.ArraySchema(Application.encodingSchema)),
                omitEmpty: true,
            }, {
                key: 'created-assets',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.ArraySchema(Asset.encodingSchema)),
                omitEmpty: true,
            }, {
                key: 'incentive-eligible',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.BooleanSchema()),
                omitEmpty: true,
            }, {
                key: 'last-heartbeat',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()),
                omitEmpty: true,
            }, {
                key: 'last-proposed',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()),
                omitEmpty: true,
            }, {
                key: 'participation',
                valueSchema: new index_js_1.OptionalSchema(AccountParticipation.encodingSchema),
                omitEmpty: true,
            }, {
                key: 'reward-base',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()),
                omitEmpty: true,
            }, {
                key: 'sig-type',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.StringSchema()),
                omitEmpty: true,
            }, {
                key: 'total-box-bytes',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()),
                omitEmpty: true,
            }, {
                key: 'total-boxes',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()),
                omitEmpty: true,
            });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `Account` object.
     * @param address - the account public key
     * @param amount - (algo) total number of MicroAlgos in the account
     * @param amountWithoutPendingRewards - specifies the amount of MicroAlgos in the account, without the pending rewards.
     * @param minBalance - MicroAlgo balance required by the account.
     * The requirement grows based on asset and application usage.
     * @param pendingRewards - amount of MicroAlgos of pending rewards in this account.
     * @param rewards - (ern) total rewards of MicroAlgos the account has received, including pending
     * rewards.
     * @param round - The round for which this information is relevant.
     * @param status - (onl) delegation status of the account's MicroAlgos
     * * Offline - indicates that the associated account is delegated.
     * * Online - indicates that the associated account used as part of the delegation
     * pool.
     * * NotParticipating - indicates that the associated account is neither a
     * delegator nor a delegate.
     * @param totalAppsOptedIn - The count of all applications that have been opted in, equivalent to the count
     * of application local data (AppLocalState objects) stored in this account.
     * @param totalAssetsOptedIn - The count of all assets that have been opted in, equivalent to the count of
     * AssetHolding objects held by this account.
     * @param totalCreatedApps - The count of all apps (AppParams objects) created by this account.
     * @param totalCreatedAssets - The count of all assets (AssetParams objects) created by this account.
     * @param appsLocalState - (appl) applications local data stored in this account.
     * Note the raw object uses `map[int] -> AppLocalState` for this type.
     * @param appsTotalExtraPages - (teap) the sum of all extra application program pages for this account.
     * @param appsTotalSchema - (tsch) stores the sum of all of the local schemas and global schemas in this
     * account.
     * Note: the raw account uses `StateSchema` for this type.
     * @param assets - (asset) assets held by this account.
     * Note the raw object uses `map[int] -> AssetHolding` for this type.
     * @param authAddr - (spend) the address against which signing should be checked. If empty, the
     * address of the current account is used. This field can be updated in any
     * transaction by setting the RekeyTo field.
     * @param createdApps - (appp) parameters of applications created by this account including app global
     * data.
     * Note: the raw account uses `map[int] -> AppParams` for this type.
     * @param createdAssets - (apar) parameters of assets created by this account.
     * Note: the raw account uses `map[int] -> Asset` for this type.
     * @param incentiveEligible - Whether or not the account can receive block incentives if its balance is in
     * range at proposal time.
     * @param lastHeartbeat - The round in which this account last went online, or explicitly renewed their
     * online status.
     * @param lastProposed - The round in which this account last proposed the block.
     * @param participation - AccountParticipation describes the parameters used by this account in consensus
     * protocol.
     * @param rewardBase - (ebase) used as part of the rewards computation. Only applicable to accounts
     * which are participating.
     * @param sigType - Indicates what type of signature is used by this account, must be one of:
     * * sig
     * * msig
     * * lsig
     * @param totalBoxBytes - (tbxb) The total number of bytes used by this account's app's box keys and
     * values.
     * @param totalBoxes - (tbx) The number of existing boxes created by this account's app.
     */
    constructor({ address, amount, amountWithoutPendingRewards, minBalance, pendingRewards, rewards, round, status, totalAppsOptedIn, totalAssetsOptedIn, totalCreatedApps, totalCreatedAssets, appsLocalState, appsTotalExtraPages, appsTotalSchema, assets, authAddr, createdApps, createdAssets, incentiveEligible, lastHeartbeat, lastProposed, participation, rewardBase, sigType, totalBoxBytes, totalBoxes, }) {
        this.address = address;
        this.amount = (0, utils_js_1.ensureBigInt)(amount);
        this.amountWithoutPendingRewards = (0, utils_js_1.ensureBigInt)(amountWithoutPendingRewards);
        this.minBalance = (0, utils_js_1.ensureBigInt)(minBalance);
        this.pendingRewards = (0, utils_js_1.ensureBigInt)(pendingRewards);
        this.rewards = (0, utils_js_1.ensureBigInt)(rewards);
        this.round = (0, utils_js_1.ensureBigInt)(round);
        this.status = status;
        this.totalAppsOptedIn = (0, utils_js_1.ensureSafeInteger)(totalAppsOptedIn);
        this.totalAssetsOptedIn = (0, utils_js_1.ensureSafeInteger)(totalAssetsOptedIn);
        this.totalCreatedApps = (0, utils_js_1.ensureSafeInteger)(totalCreatedApps);
        this.totalCreatedAssets = (0, utils_js_1.ensureSafeInteger)(totalCreatedAssets);
        this.appsLocalState = appsLocalState;
        this.appsTotalExtraPages =
            typeof appsTotalExtraPages === 'undefined'
                ? undefined
                : (0, utils_js_1.ensureSafeInteger)(appsTotalExtraPages);
        this.appsTotalSchema = appsTotalSchema;
        this.assets = assets;
        this.authAddr =
            typeof authAddr === 'string' ? address_js_1.Address.fromString(authAddr) : authAddr;
        this.createdApps = createdApps;
        this.createdAssets = createdAssets;
        this.incentiveEligible = incentiveEligible;
        this.lastHeartbeat =
            typeof lastHeartbeat === 'undefined'
                ? undefined
                : (0, utils_js_1.ensureSafeInteger)(lastHeartbeat);
        this.lastProposed =
            typeof lastProposed === 'undefined'
                ? undefined
                : (0, utils_js_1.ensureSafeInteger)(lastProposed);
        this.participation = participation;
        this.rewardBase =
            typeof rewardBase === 'undefined' ? undefined : (0, utils_js_1.ensureBigInt)(rewardBase);
        this.sigType = sigType;
        this.totalBoxBytes =
            typeof totalBoxBytes === 'undefined'
                ? undefined
                : (0, utils_js_1.ensureSafeInteger)(totalBoxBytes);
        this.totalBoxes =
            typeof totalBoxes === 'undefined'
                ? undefined
                : (0, utils_js_1.ensureSafeInteger)(totalBoxes);
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return Account.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['address', this.address],
            ['amount', this.amount],
            ['amount-without-pending-rewards', this.amountWithoutPendingRewards],
            ['min-balance', this.minBalance],
            ['pending-rewards', this.pendingRewards],
            ['rewards', this.rewards],
            ['round', this.round],
            ['status', this.status],
            ['total-apps-opted-in', this.totalAppsOptedIn],
            ['total-assets-opted-in', this.totalAssetsOptedIn],
            ['total-created-apps', this.totalCreatedApps],
            ['total-created-assets', this.totalCreatedAssets],
            [
                'apps-local-state',
                typeof this.appsLocalState !== 'undefined'
                    ? this.appsLocalState.map((v) => v.toEncodingData())
                    : undefined,
            ],
            ['apps-total-extra-pages', this.appsTotalExtraPages],
            [
                'apps-total-schema',
                typeof this.appsTotalSchema !== 'undefined'
                    ? this.appsTotalSchema.toEncodingData()
                    : undefined,
            ],
            [
                'assets',
                typeof this.assets !== 'undefined'
                    ? this.assets.map((v) => v.toEncodingData())
                    : undefined,
            ],
            [
                'auth-addr',
                typeof this.authAddr !== 'undefined'
                    ? this.authAddr.toString()
                    : undefined,
            ],
            [
                'created-apps',
                typeof this.createdApps !== 'undefined'
                    ? this.createdApps.map((v) => v.toEncodingData())
                    : undefined,
            ],
            [
                'created-assets',
                typeof this.createdAssets !== 'undefined'
                    ? this.createdAssets.map((v) => v.toEncodingData())
                    : undefined,
            ],
            ['incentive-eligible', this.incentiveEligible],
            ['last-heartbeat', this.lastHeartbeat],
            ['last-proposed', this.lastProposed],
            [
                'participation',
                typeof this.participation !== 'undefined'
                    ? this.participation.toEncodingData()
                    : undefined,
            ],
            ['reward-base', this.rewardBase],
            ['sig-type', this.sigType],
            ['total-box-bytes', this.totalBoxBytes],
            ['total-boxes', this.totalBoxes],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded Account: ${data}`);
        }
        return new Account({
            address: data.get('address'),
            amount: data.get('amount'),
            amountWithoutPendingRewards: data.get('amount-without-pending-rewards'),
            minBalance: data.get('min-balance'),
            pendingRewards: data.get('pending-rewards'),
            rewards: data.get('rewards'),
            round: data.get('round'),
            status: data.get('status'),
            totalAppsOptedIn: data.get('total-apps-opted-in'),
            totalAssetsOptedIn: data.get('total-assets-opted-in'),
            totalCreatedApps: data.get('total-created-apps'),
            totalCreatedAssets: data.get('total-created-assets'),
            appsLocalState: typeof data.get('apps-local-state') !== 'undefined'
                ? data
                    .get('apps-local-state')
                    .map((v) => ApplicationLocalState.fromEncodingData(v))
                : undefined,
            appsTotalExtraPages: data.get('apps-total-extra-pages'),
            appsTotalSchema: typeof data.get('apps-total-schema') !== 'undefined'
                ? ApplicationStateSchema.fromEncodingData(data.get('apps-total-schema'))
                : undefined,
            assets: typeof data.get('assets') !== 'undefined'
                ? data
                    .get('assets')
                    .map((v) => AssetHolding.fromEncodingData(v))
                : undefined,
            authAddr: data.get('auth-addr'),
            createdApps: typeof data.get('created-apps') !== 'undefined'
                ? data
                    .get('created-apps')
                    .map((v) => Application.fromEncodingData(v))
                : undefined,
            createdAssets: typeof data.get('created-assets') !== 'undefined'
                ? data
                    .get('created-assets')
                    .map((v) => Asset.fromEncodingData(v))
                : undefined,
            incentiveEligible: data.get('incentive-eligible'),
            lastHeartbeat: data.get('last-heartbeat'),
            lastProposed: data.get('last-proposed'),
            participation: typeof data.get('participation') !== 'undefined'
                ? AccountParticipation.fromEncodingData(data.get('participation'))
                : undefined,
            rewardBase: data.get('reward-base'),
            sigType: data.get('sig-type'),
            totalBoxBytes: data.get('total-box-bytes'),
            totalBoxes: data.get('total-boxes'),
        });
    }
}
exports.Account = Account;
/**
 * AccountApplicationResponse describes the account's application local state and
 * global state (AppLocalState and AppParams, if either exists) for a specific
 * application ID. Global state will only be returned if the provided address is
 * the application's creator.
 */
class AccountApplicationResponse {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: 'round', valueSchema: new index_js_1.Uint64Schema(), omitEmpty: true }, {
                key: 'app-local-state',
                valueSchema: new index_js_1.OptionalSchema(ApplicationLocalState.encodingSchema),
                omitEmpty: true,
            }, {
                key: 'created-app',
                valueSchema: new index_js_1.OptionalSchema(ApplicationParams.encodingSchema),
                omitEmpty: true,
            });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `AccountApplicationResponse` object.
     * @param round - The round for which this information is relevant.
     * @param appLocalState - (appl) the application local data stored in this account.
     * The raw account uses `AppLocalState` for this type.
     * @param createdApp - (appp) parameters of the application created by this account including app
     * global data.
     * The raw account uses `AppParams` for this type.
     */
    constructor({ round, appLocalState, createdApp, }) {
        this.round = (0, utils_js_1.ensureBigInt)(round);
        this.appLocalState = appLocalState;
        this.createdApp = createdApp;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return AccountApplicationResponse.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['round', this.round],
            [
                'app-local-state',
                typeof this.appLocalState !== 'undefined'
                    ? this.appLocalState.toEncodingData()
                    : undefined,
            ],
            [
                'created-app',
                typeof this.createdApp !== 'undefined'
                    ? this.createdApp.toEncodingData()
                    : undefined,
            ],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded AccountApplicationResponse: ${data}`);
        }
        return new AccountApplicationResponse({
            round: data.get('round'),
            appLocalState: typeof data.get('app-local-state') !== 'undefined'
                ? ApplicationLocalState.fromEncodingData(data.get('app-local-state'))
                : undefined,
            createdApp: typeof data.get('created-app') !== 'undefined'
                ? ApplicationParams.fromEncodingData(data.get('created-app'))
                : undefined,
        });
    }
}
exports.AccountApplicationResponse = AccountApplicationResponse;
/**
 * AccountAssetHolding describes the account's asset holding and asset parameters
 * (if either exist) for a specific asset ID.
 */
class AccountAssetHolding {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
                key: 'asset-holding',
                valueSchema: AssetHolding.encodingSchema,
                omitEmpty: true,
            }, {
                key: 'asset-params',
                valueSchema: new index_js_1.OptionalSchema(AssetParams.encodingSchema),
                omitEmpty: true,
            });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `AccountAssetHolding` object.
     * @param assetHolding - (asset) Details about the asset held by this account.
     * The raw account uses `AssetHolding` for this type.
     * @param assetParams - (apar) parameters of the asset held by this account.
     * The raw account uses `AssetParams` for this type.
     */
    constructor({ assetHolding, assetParams, }) {
        this.assetHolding = assetHolding;
        this.assetParams = assetParams;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return AccountAssetHolding.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['asset-holding', this.assetHolding.toEncodingData()],
            [
                'asset-params',
                typeof this.assetParams !== 'undefined'
                    ? this.assetParams.toEncodingData()
                    : undefined,
            ],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded AccountAssetHolding: ${data}`);
        }
        return new AccountAssetHolding({
            assetHolding: AssetHolding.fromEncodingData(data.get('asset-holding') ?? new Map()),
            assetParams: typeof data.get('asset-params') !== 'undefined'
                ? AssetParams.fromEncodingData(data.get('asset-params'))
                : undefined,
        });
    }
}
exports.AccountAssetHolding = AccountAssetHolding;
/**
 * AccountAssetResponse describes the account's asset holding and asset parameters
 * (if either exist) for a specific asset ID. Asset parameters will only be
 * returned if the provided address is the asset's creator.
 */
class AccountAssetResponse {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: 'round', valueSchema: new index_js_1.Uint64Schema(), omitEmpty: true }, {
                key: 'asset-holding',
                valueSchema: new index_js_1.OptionalSchema(AssetHolding.encodingSchema),
                omitEmpty: true,
            }, {
                key: 'created-asset',
                valueSchema: new index_js_1.OptionalSchema(AssetParams.encodingSchema),
                omitEmpty: true,
            });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `AccountAssetResponse` object.
     * @param round - The round for which this information is relevant.
     * @param assetHolding - (asset) Details about the asset held by this account.
     * The raw account uses `AssetHolding` for this type.
     * @param createdAsset - (apar) parameters of the asset created by this account.
     * The raw account uses `AssetParams` for this type.
     */
    constructor({ round, assetHolding, createdAsset, }) {
        this.round = (0, utils_js_1.ensureBigInt)(round);
        this.assetHolding = assetHolding;
        this.createdAsset = createdAsset;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return AccountAssetResponse.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['round', this.round],
            [
                'asset-holding',
                typeof this.assetHolding !== 'undefined'
                    ? this.assetHolding.toEncodingData()
                    : undefined,
            ],
            [
                'created-asset',
                typeof this.createdAsset !== 'undefined'
                    ? this.createdAsset.toEncodingData()
                    : undefined,
            ],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded AccountAssetResponse: ${data}`);
        }
        return new AccountAssetResponse({
            round: data.get('round'),
            assetHolding: typeof data.get('asset-holding') !== 'undefined'
                ? AssetHolding.fromEncodingData(data.get('asset-holding'))
                : undefined,
            createdAsset: typeof data.get('created-asset') !== 'undefined'
                ? AssetParams.fromEncodingData(data.get('created-asset'))
                : undefined,
        });
    }
}
exports.AccountAssetResponse = AccountAssetResponse;
/**
 * AccountAssetsInformationResponse contains a list of assets held by an account.
 */
class AccountAssetsInformationResponse {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: 'round', valueSchema: new index_js_1.Uint64Schema(), omitEmpty: true }, {
                key: 'asset-holdings',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.ArraySchema(AccountAssetHolding.encodingSchema)),
                omitEmpty: true,
            }, {
                key: 'next-token',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.StringSchema()),
                omitEmpty: true,
            });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `AccountAssetsInformationResponse` object.
     * @param round - The round for which this information is relevant.
     * @param assetHoldings -
     * @param nextToken - Used for pagination, when making another request provide this token with the
     * next parameter.
     */
    constructor({ round, assetHoldings, nextToken, }) {
        this.round = (0, utils_js_1.ensureSafeInteger)(round);
        this.assetHoldings = assetHoldings;
        this.nextToken = nextToken;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return AccountAssetsInformationResponse.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['round', this.round],
            [
                'asset-holdings',
                typeof this.assetHoldings !== 'undefined'
                    ? this.assetHoldings.map((v) => v.toEncodingData())
                    : undefined,
            ],
            ['next-token', this.nextToken],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded AccountAssetsInformationResponse: ${data}`);
        }
        return new AccountAssetsInformationResponse({
            round: data.get('round'),
            assetHoldings: typeof data.get('asset-holdings') !== 'undefined'
                ? data
                    .get('asset-holdings')
                    .map((v) => AccountAssetHolding.fromEncodingData(v))
                : undefined,
            nextToken: data.get('next-token'),
        });
    }
}
exports.AccountAssetsInformationResponse = AccountAssetsInformationResponse;
/**
 * AccountParticipation describes the parameters used by this account in consensus
 * protocol.
 */
class AccountParticipation {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
                key: 'selection-participation-key',
                valueSchema: new index_js_1.ByteArraySchema(),
                omitEmpty: true,
            }, {
                key: 'vote-first-valid',
                valueSchema: new index_js_1.Uint64Schema(),
                omitEmpty: true,
            }, {
                key: 'vote-key-dilution',
                valueSchema: new index_js_1.Uint64Schema(),
                omitEmpty: true,
            }, {
                key: 'vote-last-valid',
                valueSchema: new index_js_1.Uint64Schema(),
                omitEmpty: true,
            }, {
                key: 'vote-participation-key',
                valueSchema: new index_js_1.ByteArraySchema(),
                omitEmpty: true,
            }, {
                key: 'state-proof-key',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.ByteArraySchema()),
                omitEmpty: true,
            });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `AccountParticipation` object.
     * @param selectionParticipationKey - (sel) Selection public key (if any) currently registered for this round.
     * @param voteFirstValid - (voteFst) First round for which this participation is valid.
     * @param voteKeyDilution - (voteKD) Number of subkeys in each batch of participation keys.
     * @param voteLastValid - (voteLst) Last round for which this participation is valid.
     * @param voteParticipationKey - (vote) root participation public key (if any) currently registered for this
     * round.
     * @param stateProofKey - (stprf) Root of the state proof key (if any)
     */
    constructor({ selectionParticipationKey, voteFirstValid, voteKeyDilution, voteLastValid, voteParticipationKey, stateProofKey, }) {
        this.selectionParticipationKey =
            typeof selectionParticipationKey === 'string'
                ? (0, binarydata_js_1.base64ToBytes)(selectionParticipationKey)
                : selectionParticipationKey;
        this.voteFirstValid = (0, utils_js_1.ensureBigInt)(voteFirstValid);
        this.voteKeyDilution = (0, utils_js_1.ensureBigInt)(voteKeyDilution);
        this.voteLastValid = (0, utils_js_1.ensureBigInt)(voteLastValid);
        this.voteParticipationKey =
            typeof voteParticipationKey === 'string'
                ? (0, binarydata_js_1.base64ToBytes)(voteParticipationKey)
                : voteParticipationKey;
        this.stateProofKey =
            typeof stateProofKey === 'string'
                ? (0, binarydata_js_1.base64ToBytes)(stateProofKey)
                : stateProofKey;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return AccountParticipation.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['selection-participation-key', this.selectionParticipationKey],
            ['vote-first-valid', this.voteFirstValid],
            ['vote-key-dilution', this.voteKeyDilution],
            ['vote-last-valid', this.voteLastValid],
            ['vote-participation-key', this.voteParticipationKey],
            ['state-proof-key', this.stateProofKey],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded AccountParticipation: ${data}`);
        }
        return new AccountParticipation({
            selectionParticipationKey: data.get('selection-participation-key'),
            voteFirstValid: data.get('vote-first-valid'),
            voteKeyDilution: data.get('vote-key-dilution'),
            voteLastValid: data.get('vote-last-valid'),
            voteParticipationKey: data.get('vote-participation-key'),
            stateProofKey: data.get('state-proof-key'),
        });
    }
}
exports.AccountParticipation = AccountParticipation;
/**
 * Application state delta.
 */
class AccountStateDelta {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: 'address', valueSchema: new index_js_1.StringSchema(), omitEmpty: true }, {
                key: 'delta',
                valueSchema: new index_js_1.ArraySchema(EvalDeltaKeyValue.encodingSchema),
                omitEmpty: true,
            });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `AccountStateDelta` object.
     * @param address -
     * @param delta - Application state delta.
     */
    constructor({ address, delta, }) {
        this.address = address;
        this.delta = delta;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return AccountStateDelta.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['address', this.address],
            ['delta', this.delta.map((v) => v.toEncodingData())],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded AccountStateDelta: ${data}`);
        }
        return new AccountStateDelta({
            address: data.get('address'),
            delta: (data.get('delta') ?? []).map((v) => EvalDeltaKeyValue.fromEncodingData(v)),
        });
    }
}
exports.AccountStateDelta = AccountStateDelta;
/**
 * The logged messages from an app call along with the app ID and outer transaction
 * ID. Logs appear in the same order that they were emitted.
 */
class AppCallLogs {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
                key: 'application-index',
                valueSchema: new index_js_1.Uint64Schema(),
                omitEmpty: true,
            }, {
                key: 'logs',
                valueSchema: new index_js_1.ArraySchema(new index_js_1.ByteArraySchema()),
                omitEmpty: true,
            }, { key: 'txId', valueSchema: new index_js_1.StringSchema(), omitEmpty: true });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `AppCallLogs` object.
     * @param applicationIndex - The application from which the logs were generated
     * @param logs - An array of logs
     * @param txid - The transaction ID of the outer app call that lead to these logs
     */
    constructor({ applicationIndex, logs, txid, }) {
        this.applicationIndex = (0, utils_js_1.ensureSafeInteger)(applicationIndex);
        this.logs = logs;
        this.txid = txid;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return AppCallLogs.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['application-index', this.applicationIndex],
            ['logs', this.logs],
            ['txId', this.txid],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded AppCallLogs: ${data}`);
        }
        return new AppCallLogs({
            applicationIndex: data.get('application-index'),
            logs: data.get('logs'),
            txid: data.get('txId'),
        });
    }
}
exports.AppCallLogs = AppCallLogs;
/**
 * Application index and its parameters
 */
class Application {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: 'id', valueSchema: new index_js_1.Uint64Schema(), omitEmpty: true }, {
                key: 'params',
                valueSchema: ApplicationParams.encodingSchema,
                omitEmpty: true,
            });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `Application` object.
     * @param id - (appidx) application index.
     * @param params - (appparams) application parameters.
     */
    constructor({ id, params, }) {
        this.id = (0, utils_js_1.ensureBigInt)(id);
        this.params = params;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return Application.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['id', this.id],
            ['params', this.params.toEncodingData()],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded Application: ${data}`);
        }
        return new Application({
            id: data.get('id'),
            params: ApplicationParams.fromEncodingData(data.get('params') ?? new Map()),
        });
    }
}
exports.Application = Application;
/**
 * An application's initial global/local/box states that were accessed during
 * simulation.
 */
class ApplicationInitialStates {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: 'id', valueSchema: new index_js_1.Uint64Schema(), omitEmpty: true }, {
                key: 'app-boxes',
                valueSchema: new index_js_1.OptionalSchema(ApplicationKVStorage.encodingSchema),
                omitEmpty: true,
            }, {
                key: 'app-globals',
                valueSchema: new index_js_1.OptionalSchema(ApplicationKVStorage.encodingSchema),
                omitEmpty: true,
            }, {
                key: 'app-locals',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.ArraySchema(ApplicationKVStorage.encodingSchema)),
                omitEmpty: true,
            });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `ApplicationInitialStates` object.
     * @param id - Application index.
     * @param appBoxes - An application's global/local/box state.
     * @param appGlobals - An application's global/local/box state.
     * @param appLocals - An application's initial local states tied to different accounts.
     */
    constructor({ id, appBoxes, appGlobals, appLocals, }) {
        this.id = (0, utils_js_1.ensureBigInt)(id);
        this.appBoxes = appBoxes;
        this.appGlobals = appGlobals;
        this.appLocals = appLocals;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return ApplicationInitialStates.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['id', this.id],
            [
                'app-boxes',
                typeof this.appBoxes !== 'undefined'
                    ? this.appBoxes.toEncodingData()
                    : undefined,
            ],
            [
                'app-globals',
                typeof this.appGlobals !== 'undefined'
                    ? this.appGlobals.toEncodingData()
                    : undefined,
            ],
            [
                'app-locals',
                typeof this.appLocals !== 'undefined'
                    ? this.appLocals.map((v) => v.toEncodingData())
                    : undefined,
            ],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded ApplicationInitialStates: ${data}`);
        }
        return new ApplicationInitialStates({
            id: data.get('id'),
            appBoxes: typeof data.get('app-boxes') !== 'undefined'
                ? ApplicationKVStorage.fromEncodingData(data.get('app-boxes'))
                : undefined,
            appGlobals: typeof data.get('app-globals') !== 'undefined'
                ? ApplicationKVStorage.fromEncodingData(data.get('app-globals'))
                : undefined,
            appLocals: typeof data.get('app-locals') !== 'undefined'
                ? data
                    .get('app-locals')
                    .map((v) => ApplicationKVStorage.fromEncodingData(v))
                : undefined,
        });
    }
}
exports.ApplicationInitialStates = ApplicationInitialStates;
/**
 * An application's global/local/box state.
 */
class ApplicationKVStorage {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
                key: 'kvs',
                valueSchema: new index_js_1.ArraySchema(AvmKeyValue.encodingSchema),
                omitEmpty: true,
            }, {
                key: 'account',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.StringSchema()),
                omitEmpty: true,
            });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `ApplicationKVStorage` object.
     * @param kvs - Key-Value pairs representing application states.
     * @param account - The address of the account associated with the local state.
     */
    constructor({ kvs, account, }) {
        this.kvs = kvs;
        this.account =
            typeof account === 'string' ? address_js_1.Address.fromString(account) : account;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return ApplicationKVStorage.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['kvs', this.kvs.map((v) => v.toEncodingData())],
            [
                'account',
                typeof this.account !== 'undefined'
                    ? this.account.toString()
                    : undefined,
            ],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded ApplicationKVStorage: ${data}`);
        }
        return new ApplicationKVStorage({
            kvs: (data.get('kvs') ?? []).map((v) => AvmKeyValue.fromEncodingData(v)),
            account: data.get('account'),
        });
    }
}
exports.ApplicationKVStorage = ApplicationKVStorage;
/**
 * References an account's local state for an application.
 */
class ApplicationLocalReference {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: 'account', valueSchema: new index_js_1.StringSchema(), omitEmpty: true }, { key: 'app', valueSchema: new index_js_1.Uint64Schema(), omitEmpty: true });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `ApplicationLocalReference` object.
     * @param account - Address of the account with the local state.
     * @param app - Application ID of the local state application.
     */
    constructor({ account, app, }) {
        this.account =
            typeof account === 'string' ? address_js_1.Address.fromString(account) : account;
        this.app = (0, utils_js_1.ensureBigInt)(app);
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return ApplicationLocalReference.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['account', this.account.toString()],
            ['app', this.app],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded ApplicationLocalReference: ${data}`);
        }
        return new ApplicationLocalReference({
            account: data.get('account'),
            app: data.get('app'),
        });
    }
}
exports.ApplicationLocalReference = ApplicationLocalReference;
/**
 * Stores local state associated with an application.
 */
class ApplicationLocalState {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: 'id', valueSchema: new index_js_1.Uint64Schema(), omitEmpty: true }, {
                key: 'schema',
                valueSchema: ApplicationStateSchema.encodingSchema,
                omitEmpty: true,
            }, {
                key: 'key-value',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.ArraySchema(TealKeyValue.encodingSchema)),
                omitEmpty: true,
            });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `ApplicationLocalState` object.
     * @param id - The application which this local state is for.
     * @param schema - (hsch) schema.
     * @param keyValue - (tkv) storage.
     */
    constructor({ id, schema, keyValue, }) {
        this.id = (0, utils_js_1.ensureBigInt)(id);
        this.schema = schema;
        this.keyValue = keyValue;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return ApplicationLocalState.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['id', this.id],
            ['schema', this.schema.toEncodingData()],
            [
                'key-value',
                typeof this.keyValue !== 'undefined'
                    ? this.keyValue.map((v) => v.toEncodingData())
                    : undefined,
            ],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded ApplicationLocalState: ${data}`);
        }
        return new ApplicationLocalState({
            id: data.get('id'),
            schema: ApplicationStateSchema.fromEncodingData(data.get('schema') ?? new Map()),
            keyValue: typeof data.get('key-value') !== 'undefined'
                ? data
                    .get('key-value')
                    .map((v) => TealKeyValue.fromEncodingData(v))
                : undefined,
        });
    }
}
exports.ApplicationLocalState = ApplicationLocalState;
/**
 * Stores the global information associated with an application.
 */
class ApplicationParams {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
                key: 'approval-program',
                valueSchema: new index_js_1.ByteArraySchema(),
                omitEmpty: true,
            }, {
                key: 'clear-state-program',
                valueSchema: new index_js_1.ByteArraySchema(),
                omitEmpty: true,
            }, { key: 'creator', valueSchema: new index_js_1.StringSchema(), omitEmpty: true }, {
                key: 'extra-program-pages',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()),
                omitEmpty: true,
            }, {
                key: 'global-state',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.ArraySchema(TealKeyValue.encodingSchema)),
                omitEmpty: true,
            }, {
                key: 'global-state-schema',
                valueSchema: new index_js_1.OptionalSchema(ApplicationStateSchema.encodingSchema),
                omitEmpty: true,
            }, {
                key: 'local-state-schema',
                valueSchema: new index_js_1.OptionalSchema(ApplicationStateSchema.encodingSchema),
                omitEmpty: true,
            }, {
                key: 'version',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()),
                omitEmpty: true,
            });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `ApplicationParams` object.
     * @param approvalProgram - (approv) approval program.
     * @param clearStateProgram - (clearp) approval program.
     * @param creator - The address that created this application. This is the address where the
     * parameters and global state for this application can be found.
     * @param extraProgramPages - (epp) the amount of extra program pages available to this app.
     * @param globalState - (gs) global state
     * @param globalStateSchema - (gsch) global schema
     * @param localStateSchema - (lsch) local schema
     * @param version - (v) the number of updates to the application programs
     */
    constructor({ approvalProgram, clearStateProgram, creator, extraProgramPages, globalState, globalStateSchema, localStateSchema, version, }) {
        this.approvalProgram =
            typeof approvalProgram === 'string'
                ? (0, binarydata_js_1.base64ToBytes)(approvalProgram)
                : approvalProgram;
        this.clearStateProgram =
            typeof clearStateProgram === 'string'
                ? (0, binarydata_js_1.base64ToBytes)(clearStateProgram)
                : clearStateProgram;
        this.creator =
            typeof creator === 'string' ? address_js_1.Address.fromString(creator) : creator;
        this.extraProgramPages =
            typeof extraProgramPages === 'undefined'
                ? undefined
                : (0, utils_js_1.ensureSafeInteger)(extraProgramPages);
        this.globalState = globalState;
        this.globalStateSchema = globalStateSchema;
        this.localStateSchema = localStateSchema;
        this.version =
            typeof version === 'undefined' ? undefined : (0, utils_js_1.ensureSafeInteger)(version);
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return ApplicationParams.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['approval-program', this.approvalProgram],
            ['clear-state-program', this.clearStateProgram],
            ['creator', this.creator.toString()],
            ['extra-program-pages', this.extraProgramPages],
            [
                'global-state',
                typeof this.globalState !== 'undefined'
                    ? this.globalState.map((v) => v.toEncodingData())
                    : undefined,
            ],
            [
                'global-state-schema',
                typeof this.globalStateSchema !== 'undefined'
                    ? this.globalStateSchema.toEncodingData()
                    : undefined,
            ],
            [
                'local-state-schema',
                typeof this.localStateSchema !== 'undefined'
                    ? this.localStateSchema.toEncodingData()
                    : undefined,
            ],
            ['version', this.version],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded ApplicationParams: ${data}`);
        }
        return new ApplicationParams({
            approvalProgram: data.get('approval-program'),
            clearStateProgram: data.get('clear-state-program'),
            creator: data.get('creator'),
            extraProgramPages: data.get('extra-program-pages'),
            globalState: typeof data.get('global-state') !== 'undefined'
                ? data
                    .get('global-state')
                    .map((v) => TealKeyValue.fromEncodingData(v))
                : undefined,
            globalStateSchema: typeof data.get('global-state-schema') !== 'undefined'
                ? ApplicationStateSchema.fromEncodingData(data.get('global-state-schema'))
                : undefined,
            localStateSchema: typeof data.get('local-state-schema') !== 'undefined'
                ? ApplicationStateSchema.fromEncodingData(data.get('local-state-schema'))
                : undefined,
            version: data.get('version'),
        });
    }
}
exports.ApplicationParams = ApplicationParams;
/**
 * An operation against an application's global/local/box state.
 */
class ApplicationStateOperation {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
                key: 'app-state-type',
                valueSchema: new index_js_1.StringSchema(),
                omitEmpty: true,
            }, { key: 'key', valueSchema: new index_js_1.ByteArraySchema(), omitEmpty: true }, { key: 'operation', valueSchema: new index_js_1.StringSchema(), omitEmpty: true }, {
                key: 'account',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.StringSchema()),
                omitEmpty: true,
            }, {
                key: 'new-value',
                valueSchema: new index_js_1.OptionalSchema(AvmValue.encodingSchema),
                omitEmpty: true,
            });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `ApplicationStateOperation` object.
     * @param appStateType - Type of application state. Value `g` is **global state**, `l` is **local
     * state**, `b` is **boxes**.
     * @param key - The key (name) of the global/local/box state.
     * @param operation - Operation type. Value `w` is **write**, `d` is **delete**.
     * @param account - For local state changes, the address of the account associated with the local
     * state.
     * @param newValue - Represents an AVM value.
     */
    constructor({ appStateType, key, operation, account, newValue, }) {
        this.appStateType = appStateType;
        this.key = typeof key === 'string' ? (0, binarydata_js_1.base64ToBytes)(key) : key;
        this.operation = operation;
        this.account =
            typeof account === 'string' ? address_js_1.Address.fromString(account) : account;
        this.newValue = newValue;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return ApplicationStateOperation.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['app-state-type', this.appStateType],
            ['key', this.key],
            ['operation', this.operation],
            [
                'account',
                typeof this.account !== 'undefined'
                    ? this.account.toString()
                    : undefined,
            ],
            [
                'new-value',
                typeof this.newValue !== 'undefined'
                    ? this.newValue.toEncodingData()
                    : undefined,
            ],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded ApplicationStateOperation: ${data}`);
        }
        return new ApplicationStateOperation({
            appStateType: data.get('app-state-type'),
            key: data.get('key'),
            operation: data.get('operation'),
            account: data.get('account'),
            newValue: typeof data.get('new-value') !== 'undefined'
                ? AvmValue.fromEncodingData(data.get('new-value'))
                : undefined,
        });
    }
}
exports.ApplicationStateOperation = ApplicationStateOperation;
/**
 * Specifies maximums on the number of each type that may be stored.
 */
class ApplicationStateSchema {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
                key: 'num-byte-slice',
                valueSchema: new index_js_1.Uint64Schema(),
                omitEmpty: true,
            }, { key: 'num-uint', valueSchema: new index_js_1.Uint64Schema(), omitEmpty: true });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `ApplicationStateSchema` object.
     * @param numByteSlice - (nbs) num of byte slices.
     * @param numUint - (nui) num of uints.
     */
    constructor({ numByteSlice, numUint, }) {
        this.numByteSlice = (0, utils_js_1.ensureSafeInteger)(numByteSlice);
        this.numUint = (0, utils_js_1.ensureSafeInteger)(numUint);
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return ApplicationStateSchema.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['num-byte-slice', this.numByteSlice],
            ['num-uint', this.numUint],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded ApplicationStateSchema: ${data}`);
        }
        return new ApplicationStateSchema({
            numByteSlice: data.get('num-byte-slice'),
            numUint: data.get('num-uint'),
        });
    }
}
exports.ApplicationStateSchema = ApplicationStateSchema;
/**
 * Specifies both the unique identifier and the parameters for an asset
 */
class Asset {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: 'index', valueSchema: new index_js_1.Uint64Schema(), omitEmpty: true }, {
                key: 'params',
                valueSchema: AssetParams.encodingSchema,
                omitEmpty: true,
            });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `Asset` object.
     * @param index - unique asset identifier
     * @param params - AssetParams specifies the parameters for an asset.
     * (apar) when part of an AssetConfig transaction.
     * Definition:
     * data/transactions/asset.go : AssetParams
     */
    constructor({ index, params, }) {
        this.index = (0, utils_js_1.ensureBigInt)(index);
        this.params = params;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return Asset.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['index', this.index],
            ['params', this.params.toEncodingData()],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded Asset: ${data}`);
        }
        return new Asset({
            index: data.get('index'),
            params: AssetParams.fromEncodingData(data.get('params') ?? new Map()),
        });
    }
}
exports.Asset = Asset;
/**
 * Describes an asset held by an account.
 * Definition:
 * data/basics/userBalance.go : AssetHolding
 */
class AssetHolding {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: 'amount', valueSchema: new index_js_1.Uint64Schema(), omitEmpty: true }, { key: 'asset-id', valueSchema: new index_js_1.Uint64Schema(), omitEmpty: true }, { key: 'is-frozen', valueSchema: new index_js_1.BooleanSchema(), omitEmpty: true });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `AssetHolding` object.
     * @param amount - (a) number of units held.
     * @param assetId - Asset ID of the holding.
     * @param isFrozen - (f) whether or not the holding is frozen.
     */
    constructor({ amount, assetId, isFrozen, }) {
        this.amount = (0, utils_js_1.ensureBigInt)(amount);
        this.assetId = (0, utils_js_1.ensureBigInt)(assetId);
        this.isFrozen = isFrozen;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return AssetHolding.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['amount', this.amount],
            ['asset-id', this.assetId],
            ['is-frozen', this.isFrozen],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded AssetHolding: ${data}`);
        }
        return new AssetHolding({
            amount: data.get('amount'),
            assetId: data.get('asset-id'),
            isFrozen: data.get('is-frozen'),
        });
    }
}
exports.AssetHolding = AssetHolding;
/**
 * References an asset held by an account.
 */
class AssetHoldingReference {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: 'account', valueSchema: new index_js_1.StringSchema(), omitEmpty: true }, { key: 'asset', valueSchema: new index_js_1.Uint64Schema(), omitEmpty: true });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `AssetHoldingReference` object.
     * @param account - Address of the account holding the asset.
     * @param asset - Asset ID of the holding.
     */
    constructor({ account, asset, }) {
        this.account =
            typeof account === 'string' ? address_js_1.Address.fromString(account) : account;
        this.asset = (0, utils_js_1.ensureBigInt)(asset);
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return AssetHoldingReference.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['account', this.account.toString()],
            ['asset', this.asset],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded AssetHoldingReference: ${data}`);
        }
        return new AssetHoldingReference({
            account: data.get('account'),
            asset: data.get('asset'),
        });
    }
}
exports.AssetHoldingReference = AssetHoldingReference;
/**
 * AssetParams specifies the parameters for an asset.
 * (apar) when part of an AssetConfig transaction.
 * Definition:
 * data/transactions/asset.go : AssetParams
 */
class AssetParams {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: 'creator', valueSchema: new index_js_1.StringSchema(), omitEmpty: true }, { key: 'decimals', valueSchema: new index_js_1.Uint64Schema(), omitEmpty: true }, { key: 'total', valueSchema: new index_js_1.Uint64Schema(), omitEmpty: true }, {
                key: 'clawback',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.StringSchema()),
                omitEmpty: true,
            }, {
                key: 'default-frozen',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.BooleanSchema()),
                omitEmpty: true,
            }, {
                key: 'freeze',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.StringSchema()),
                omitEmpty: true,
            }, {
                key: 'manager',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.StringSchema()),
                omitEmpty: true,
            }, {
                key: 'metadata-hash',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.ByteArraySchema()),
                omitEmpty: true,
            }, {
                key: 'name',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.StringSchema()),
                omitEmpty: true,
            }, {
                key: 'name-b64',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.ByteArraySchema()),
                omitEmpty: true,
            }, {
                key: 'reserve',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.StringSchema()),
                omitEmpty: true,
            }, {
                key: 'unit-name',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.StringSchema()),
                omitEmpty: true,
            }, {
                key: 'unit-name-b64',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.ByteArraySchema()),
                omitEmpty: true,
            }, {
                key: 'url',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.StringSchema()),
                omitEmpty: true,
            }, {
                key: 'url-b64',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.ByteArraySchema()),
                omitEmpty: true,
            });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `AssetParams` object.
     * @param creator - The address that created this asset. This is the address where the parameters
     * for this asset can be found, and also the address where unwanted asset units can
     * be sent in the worst case.
     * @param decimals - (dc) The number of digits to use after the decimal point when displaying this
     * asset. If 0, the asset is not divisible. If 1, the base unit of the asset is in
     * tenths. If 2, the base unit of the asset is in hundredths, and so on. This value
     * must be between 0 and 19 (inclusive).
     * @param total - (t) The total number of units of this asset.
     * @param clawback - (c) Address of account used to clawback holdings of this asset. If empty,
     * clawback is not permitted.
     * @param defaultFrozen - (df) Whether holdings of this asset are frozen by default.
     * @param freeze - (f) Address of account used to freeze holdings of this asset. If empty, freezing
     * is not permitted.
     * @param manager - (m) Address of account used to manage the keys of this asset and to destroy it.
     * @param metadataHash - (am) A commitment to some unspecified asset metadata. The format of this
     * metadata is up to the application.
     * @param name - (an) Name of this asset, as supplied by the creator. Included only when the
     * asset name is composed of printable utf-8 characters.
     * @param nameB64 - Base64 encoded name of this asset, as supplied by the creator.
     * @param reserve - (r) Address of account holding reserve (non-minted) units of this asset.
     * @param unitName - (un) Name of a unit of this asset, as supplied by the creator. Included only
     * when the name of a unit of this asset is composed of printable utf-8 characters.
     * @param unitNameB64 - Base64 encoded name of a unit of this asset, as supplied by the creator.
     * @param url - (au) URL where more information about the asset can be retrieved. Included only
     * when the URL is composed of printable utf-8 characters.
     * @param urlB64 - Base64 encoded URL where more information about the asset can be retrieved.
     */
    constructor({ creator, decimals, total, clawback, defaultFrozen, freeze, manager, metadataHash, name, nameB64, reserve, unitName, unitNameB64, url, urlB64, }) {
        this.creator = creator;
        this.decimals = (0, utils_js_1.ensureSafeInteger)(decimals);
        this.total = (0, utils_js_1.ensureBigInt)(total);
        this.clawback = clawback;
        this.defaultFrozen = defaultFrozen;
        this.freeze = freeze;
        this.manager = manager;
        this.metadataHash =
            typeof metadataHash === 'string'
                ? (0, binarydata_js_1.base64ToBytes)(metadataHash)
                : metadataHash;
        this.name = name;
        this.nameB64 =
            typeof nameB64 === 'string' ? (0, binarydata_js_1.base64ToBytes)(nameB64) : nameB64;
        this.reserve = reserve;
        this.unitName = unitName;
        this.unitNameB64 =
            typeof unitNameB64 === 'string'
                ? (0, binarydata_js_1.base64ToBytes)(unitNameB64)
                : unitNameB64;
        this.url = url;
        this.urlB64 = typeof urlB64 === 'string' ? (0, binarydata_js_1.base64ToBytes)(urlB64) : urlB64;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return AssetParams.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['creator', this.creator],
            ['decimals', this.decimals],
            ['total', this.total],
            ['clawback', this.clawback],
            ['default-frozen', this.defaultFrozen],
            ['freeze', this.freeze],
            ['manager', this.manager],
            ['metadata-hash', this.metadataHash],
            ['name', this.name],
            ['name-b64', this.nameB64],
            ['reserve', this.reserve],
            ['unit-name', this.unitName],
            ['unit-name-b64', this.unitNameB64],
            ['url', this.url],
            ['url-b64', this.urlB64],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded AssetParams: ${data}`);
        }
        return new AssetParams({
            creator: data.get('creator'),
            decimals: data.get('decimals'),
            total: data.get('total'),
            clawback: data.get('clawback'),
            defaultFrozen: data.get('default-frozen'),
            freeze: data.get('freeze'),
            manager: data.get('manager'),
            metadataHash: data.get('metadata-hash'),
            name: data.get('name'),
            nameB64: data.get('name-b64'),
            reserve: data.get('reserve'),
            unitName: data.get('unit-name'),
            unitNameB64: data.get('unit-name-b64'),
            url: data.get('url'),
            urlB64: data.get('url-b64'),
        });
    }
}
exports.AssetParams = AssetParams;
/**
 * Represents an AVM key-value pair in an application store.
 */
class AvmKeyValue {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: 'key', valueSchema: new index_js_1.ByteArraySchema(), omitEmpty: true }, { key: 'value', valueSchema: AvmValue.encodingSchema, omitEmpty: true });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `AvmKeyValue` object.
     * @param key -
     * @param value - Represents an AVM value.
     */
    constructor({ key, value }) {
        this.key = typeof key === 'string' ? (0, binarydata_js_1.base64ToBytes)(key) : key;
        this.value = value;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return AvmKeyValue.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['key', this.key],
            ['value', this.value.toEncodingData()],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded AvmKeyValue: ${data}`);
        }
        return new AvmKeyValue({
            key: data.get('key'),
            value: AvmValue.fromEncodingData(data.get('value') ?? new Map()),
        });
    }
}
exports.AvmKeyValue = AvmKeyValue;
/**
 * Represents an AVM value.
 */
class AvmValue {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: 'type', valueSchema: new index_js_1.Uint64Schema(), omitEmpty: true }, {
                key: 'bytes',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.ByteArraySchema()),
                omitEmpty: true,
            }, {
                key: 'uint',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()),
                omitEmpty: true,
            });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `AvmValue` object.
     * @param type - value type. Value `1` refers to **bytes**, value `2` refers to **uint64**
     * @param bytes - bytes value.
     * @param uint - uint value.
     */
    constructor({ type, bytes, uint, }) {
        this.type = (0, utils_js_1.ensureSafeInteger)(type);
        this.bytes = typeof bytes === 'string' ? (0, binarydata_js_1.base64ToBytes)(bytes) : bytes;
        this.uint = typeof uint === 'undefined' ? undefined : (0, utils_js_1.ensureBigInt)(uint);
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return AvmValue.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['type', this.type],
            ['bytes', this.bytes],
            ['uint', this.uint],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded AvmValue: ${data}`);
        }
        return new AvmValue({
            type: data.get('type'),
            bytes: data.get('bytes'),
            uint: data.get('uint'),
        });
    }
}
exports.AvmValue = AvmValue;
/**
 * Hash of a block header.
 */
class BlockHashResponse {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
                key: 'blockHash',
                valueSchema: new index_js_1.StringSchema(),
                omitEmpty: true,
            });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `BlockHashResponse` object.
     * @param blockhash - Block header hash.
     */
    constructor({ blockhash }) {
        this.blockhash = blockhash;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return BlockHashResponse.encodingSchema;
    }
    toEncodingData() {
        return new Map([['blockHash', this.blockhash]]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded BlockHashResponse: ${data}`);
        }
        return new BlockHashResponse({
            blockhash: data.get('blockHash'),
        });
    }
}
exports.BlockHashResponse = BlockHashResponse;
/**
 * All logs emitted in the given round. Each app call, whether top-level or inner,
 * that contains logs results in a separate AppCallLogs object. Therefore there may
 * be multiple AppCallLogs with the same application ID and outer transaction ID in
 * the event of multiple inner app calls to the same app. App calls with no logs
 * are not included in the response. AppCallLogs are returned in the same order
 * that their corresponding app call appeared in the block (pre-order traversal of
 * inner app calls)
 */
class BlockLogsResponse {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
                key: 'logs',
                valueSchema: new index_js_1.ArraySchema(AppCallLogs.encodingSchema),
                omitEmpty: true,
            });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `BlockLogsResponse` object.
     * @param logs -
     */
    constructor({ logs }) {
        this.logs = logs;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return BlockLogsResponse.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['logs', this.logs.map((v) => v.toEncodingData())],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded BlockLogsResponse: ${data}`);
        }
        return new BlockLogsResponse({
            logs: (data.get('logs') ?? []).map((v) => AppCallLogs.fromEncodingData(v)),
        });
    }
}
exports.BlockLogsResponse = BlockLogsResponse;
/**
 * Encoded block object.
 */
class BlockResponse {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: 'block', valueSchema: block_js_1.Block.encodingSchema, omitEmpty: true }, {
                key: 'cert',
                valueSchema: new index_js_1.OptionalSchema(untypedmodel_js_1.UntypedValue.encodingSchema),
                omitEmpty: true,
            });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `BlockResponse` object.
     * @param block - Block header data.
     * @param cert - Optional certificate object. This is only included when the format is set to
     * message pack.
     */
    constructor({ block, cert }) {
        this.block = block;
        this.cert = cert;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return BlockResponse.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['block', this.block.toEncodingData()],
            [
                'cert',
                typeof this.cert !== 'undefined'
                    ? this.cert.toEncodingData()
                    : undefined,
            ],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded BlockResponse: ${data}`);
        }
        return new BlockResponse({
            block: block_js_1.Block.fromEncodingData(data.get('block') ?? new Map()),
            cert: typeof data.get('cert') !== 'undefined'
                ? untypedmodel_js_1.UntypedValue.fromEncodingData(data.get('cert'))
                : undefined,
        });
    }
}
exports.BlockResponse = BlockResponse;
/**
 * Top level transaction IDs in a block.
 */
class BlockTxidsResponse {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
                key: 'blockTxids',
                valueSchema: new index_js_1.ArraySchema(new index_js_1.StringSchema()),
                omitEmpty: true,
            });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `BlockTxidsResponse` object.
     * @param blocktxids - Block transaction IDs.
     */
    constructor({ blocktxids }) {
        this.blocktxids = blocktxids;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return BlockTxidsResponse.encodingSchema;
    }
    toEncodingData() {
        return new Map([['blockTxids', this.blocktxids]]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded BlockTxidsResponse: ${data}`);
        }
        return new BlockTxidsResponse({
            blocktxids: data.get('blockTxids'),
        });
    }
}
exports.BlockTxidsResponse = BlockTxidsResponse;
/**
 * Box name and its content.
 */
class Box {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: 'name', valueSchema: new index_js_1.ByteArraySchema(), omitEmpty: true }, { key: 'round', valueSchema: new index_js_1.Uint64Schema(), omitEmpty: true }, { key: 'value', valueSchema: new index_js_1.ByteArraySchema(), omitEmpty: true });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `Box` object.
     * @param name - The box name, base64 encoded
     * @param round - The round for which this information is relevant
     * @param value - The box value, base64 encoded.
     */
    constructor({ name, round, value, }) {
        this.name = typeof name === 'string' ? (0, binarydata_js_1.base64ToBytes)(name) : name;
        this.round = (0, utils_js_1.ensureBigInt)(round);
        this.value = typeof value === 'string' ? (0, binarydata_js_1.base64ToBytes)(value) : value;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return Box.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['name', this.name],
            ['round', this.round],
            ['value', this.value],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded Box: ${data}`);
        }
        return new Box({
            name: data.get('name'),
            round: data.get('round'),
            value: data.get('value'),
        });
    }
}
exports.Box = Box;
/**
 * Box descriptor describes a Box.
 */
class BoxDescriptor {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
                key: 'name',
                valueSchema: new index_js_1.ByteArraySchema(),
                omitEmpty: true,
            });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `BoxDescriptor` object.
     * @param name - Base64 encoded box name
     */
    constructor({ name }) {
        this.name = typeof name === 'string' ? (0, binarydata_js_1.base64ToBytes)(name) : name;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return BoxDescriptor.encodingSchema;
    }
    toEncodingData() {
        return new Map([['name', this.name]]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded BoxDescriptor: ${data}`);
        }
        return new BoxDescriptor({
            name: data.get('name'),
        });
    }
}
exports.BoxDescriptor = BoxDescriptor;
/**
 * References a box of an application.
 */
class BoxReference {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: 'app', valueSchema: new index_js_1.Uint64Schema(), omitEmpty: true }, { key: 'name', valueSchema: new index_js_1.ByteArraySchema(), omitEmpty: true });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `BoxReference` object.
     * @param app - Application ID which this box belongs to
     * @param name - Base64 encoded box name
     */
    constructor({ app, name, }) {
        this.app = (0, utils_js_1.ensureBigInt)(app);
        this.name = typeof name === 'string' ? (0, binarydata_js_1.base64ToBytes)(name) : name;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return BoxReference.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['app', this.app],
            ['name', this.name],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded BoxReference: ${data}`);
        }
        return new BoxReference({
            app: data.get('app'),
            name: data.get('name'),
        });
    }
}
exports.BoxReference = BoxReference;
/**
 * Box names of an application
 */
class BoxesResponse {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
                key: 'boxes',
                valueSchema: new index_js_1.ArraySchema(BoxDescriptor.encodingSchema),
                omitEmpty: true,
            });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `BoxesResponse` object.
     * @param boxes -
     */
    constructor({ boxes }) {
        this.boxes = boxes;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return BoxesResponse.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['boxes', this.boxes.map((v) => v.toEncodingData())],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded BoxesResponse: ${data}`);
        }
        return new BoxesResponse({
            boxes: (data.get('boxes') ?? []).map((v) => BoxDescriptor.fromEncodingData(v)),
        });
    }
}
exports.BoxesResponse = BoxesResponse;
class BuildVersion {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: 'branch', valueSchema: new index_js_1.StringSchema(), omitEmpty: true }, {
                key: 'build_number',
                valueSchema: new index_js_1.Uint64Schema(),
                omitEmpty: true,
            }, { key: 'channel', valueSchema: new index_js_1.StringSchema(), omitEmpty: true }, {
                key: 'commit_hash',
                valueSchema: new index_js_1.StringSchema(),
                omitEmpty: true,
            }, { key: 'major', valueSchema: new index_js_1.Uint64Schema(), omitEmpty: true }, { key: 'minor', valueSchema: new index_js_1.Uint64Schema(), omitEmpty: true });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `BuildVersion` object.
     * @param branch -
     * @param buildNumber -
     * @param channel -
     * @param commitHash -
     * @param major -
     * @param minor -
     */
    constructor({ branch, buildNumber, channel, commitHash, major, minor, }) {
        this.branch = branch;
        this.buildNumber = (0, utils_js_1.ensureSafeInteger)(buildNumber);
        this.channel = channel;
        this.commitHash = commitHash;
        this.major = (0, utils_js_1.ensureSafeInteger)(major);
        this.minor = (0, utils_js_1.ensureSafeInteger)(minor);
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return BuildVersion.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['branch', this.branch],
            ['build_number', this.buildNumber],
            ['channel', this.channel],
            ['commit_hash', this.commitHash],
            ['major', this.major],
            ['minor', this.minor],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded BuildVersion: ${data}`);
        }
        return new BuildVersion({
            branch: data.get('branch'),
            buildNumber: data.get('build_number'),
            channel: data.get('channel'),
            commitHash: data.get('commit_hash'),
            major: data.get('major'),
            minor: data.get('minor'),
        });
    }
}
exports.BuildVersion = BuildVersion;
/**
 * Teal compile Result
 */
class CompileResponse {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: 'hash', valueSchema: new index_js_1.StringSchema(), omitEmpty: true }, { key: 'result', valueSchema: new index_js_1.StringSchema(), omitEmpty: true }, {
                key: 'sourcemap',
                valueSchema: new index_js_1.OptionalSchema(untypedmodel_js_1.UntypedValue.encodingSchema),
                omitEmpty: true,
            });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `CompileResponse` object.
     * @param hash - base32 SHA512_256 of program bytes (Address style)
     * @param result - base64 encoded program bytes
     * @param sourcemap - JSON of the source map
     */
    constructor({ hash, result, sourcemap, }) {
        this.hash = hash;
        this.result = result;
        this.sourcemap = sourcemap;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return CompileResponse.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['hash', this.hash],
            ['result', this.result],
            [
                'sourcemap',
                typeof this.sourcemap !== 'undefined'
                    ? this.sourcemap.toEncodingData()
                    : undefined,
            ],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded CompileResponse: ${data}`);
        }
        return new CompileResponse({
            hash: data.get('hash'),
            result: data.get('result'),
            sourcemap: typeof data.get('sourcemap') !== 'undefined'
                ? untypedmodel_js_1.UntypedValue.fromEncodingData(data.get('sourcemap'))
                : undefined,
        });
    }
}
exports.CompileResponse = CompileResponse;
/**
 * Teal disassembly Result
 */
class DisassembleResponse {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
                key: 'result',
                valueSchema: new index_js_1.StringSchema(),
                omitEmpty: true,
            });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `DisassembleResponse` object.
     * @param result - disassembled Teal code
     */
    constructor({ result }) {
        this.result = result;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return DisassembleResponse.encodingSchema;
    }
    toEncodingData() {
        return new Map([['result', this.result]]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded DisassembleResponse: ${data}`);
        }
        return new DisassembleResponse({
            result: data.get('result'),
        });
    }
}
exports.DisassembleResponse = DisassembleResponse;
/**
 * Request data type for dryrun endpoint. Given the Transactions and simulated
 * ledger state upload, run TEAL scripts and return debugging information.
 */
class DryrunRequest {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
                key: 'accounts',
                valueSchema: new index_js_1.ArraySchema(Account.encodingSchema),
                omitEmpty: true,
            }, {
                key: 'apps',
                valueSchema: new index_js_1.ArraySchema(Application.encodingSchema),
                omitEmpty: true,
            }, {
                key: 'latest-timestamp',
                valueSchema: new index_js_1.Uint64Schema(),
                omitEmpty: true,
            }, {
                key: 'protocol-version',
                valueSchema: new index_js_1.StringSchema(),
                omitEmpty: true,
            }, { key: 'round', valueSchema: new index_js_1.Uint64Schema(), omitEmpty: true }, {
                key: 'sources',
                valueSchema: new index_js_1.ArraySchema(DryrunSource.encodingSchema),
                omitEmpty: true,
            }, {
                key: 'txns',
                valueSchema: new index_js_1.ArraySchema(signedTransaction_js_1.SignedTransaction.encodingSchema),
                omitEmpty: true,
            });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `DryrunRequest` object.
     * @param accounts -
     * @param apps -
     * @param latestTimestamp - LatestTimestamp is available to some TEAL scripts. Defaults to the latest
     * confirmed timestamp this algod is attached to.
     * @param protocolVersion - ProtocolVersion specifies a specific version string to operate under, otherwise
     * whatever the current protocol of the network this algod is running in.
     * @param round - Round is available to some TEAL scripts. Defaults to the current round on the
     * network this algod is attached to.
     * @param sources -
     * @param txns -
     */
    constructor({ accounts, apps, latestTimestamp, protocolVersion, round, sources, txns, }) {
        this.accounts = accounts;
        this.apps = apps;
        this.latestTimestamp = (0, utils_js_1.ensureSafeInteger)(latestTimestamp);
        this.protocolVersion = protocolVersion;
        this.round = (0, utils_js_1.ensureBigInt)(round);
        this.sources = sources;
        this.txns = txns;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return DryrunRequest.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['accounts', this.accounts.map((v) => v.toEncodingData())],
            ['apps', this.apps.map((v) => v.toEncodingData())],
            ['latest-timestamp', this.latestTimestamp],
            ['protocol-version', this.protocolVersion],
            ['round', this.round],
            ['sources', this.sources.map((v) => v.toEncodingData())],
            ['txns', this.txns.map((v) => v.toEncodingData())],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded DryrunRequest: ${data}`);
        }
        return new DryrunRequest({
            accounts: (data.get('accounts') ?? []).map((v) => Account.fromEncodingData(v)),
            apps: (data.get('apps') ?? []).map((v) => Application.fromEncodingData(v)),
            latestTimestamp: data.get('latest-timestamp'),
            protocolVersion: data.get('protocol-version'),
            round: data.get('round'),
            sources: (data.get('sources') ?? []).map((v) => DryrunSource.fromEncodingData(v)),
            txns: (data.get('txns') ?? []).map((v) => signedTransaction_js_1.SignedTransaction.fromEncodingData(v)),
        });
    }
}
exports.DryrunRequest = DryrunRequest;
/**
 * DryrunResponse contains per-txn debug information from a dryrun.
 */
class DryrunResponse {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: 'error', valueSchema: new index_js_1.StringSchema(), omitEmpty: true }, {
                key: 'protocol-version',
                valueSchema: new index_js_1.StringSchema(),
                omitEmpty: true,
            }, {
                key: 'txns',
                valueSchema: new index_js_1.ArraySchema(DryrunTxnResult.encodingSchema),
                omitEmpty: true,
            });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `DryrunResponse` object.
     * @param error -
     * @param protocolVersion - Protocol version is the protocol version Dryrun was operated under.
     * @param txns -
     */
    constructor({ error, protocolVersion, txns, }) {
        this.error = error;
        this.protocolVersion = protocolVersion;
        this.txns = txns;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return DryrunResponse.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['error', this.error],
            ['protocol-version', this.protocolVersion],
            ['txns', this.txns.map((v) => v.toEncodingData())],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded DryrunResponse: ${data}`);
        }
        return new DryrunResponse({
            error: data.get('error'),
            protocolVersion: data.get('protocol-version'),
            txns: (data.get('txns') ?? []).map((v) => DryrunTxnResult.fromEncodingData(v)),
        });
    }
}
exports.DryrunResponse = DryrunResponse;
/**
 * DryrunSource is TEAL source text that gets uploaded, compiled, and inserted into
 * transactions or application state.
 */
class DryrunSource {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: 'app-index', valueSchema: new index_js_1.Uint64Schema(), omitEmpty: true }, { key: 'field-name', valueSchema: new index_js_1.StringSchema(), omitEmpty: true }, { key: 'source', valueSchema: new index_js_1.StringSchema(), omitEmpty: true }, { key: 'txn-index', valueSchema: new index_js_1.Uint64Schema(), omitEmpty: true });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `DryrunSource` object.
     * @param appIndex -
     * @param fieldName - FieldName is what kind of sources this is. If lsig then it goes into the
     * transactions[this.TxnIndex].LogicSig. If approv or clearp it goes into the
     * Approval Program or Clear State Program of application[this.AppIndex].
     * @param source -
     * @param txnIndex -
     */
    constructor({ appIndex, fieldName, source, txnIndex, }) {
        this.appIndex = (0, utils_js_1.ensureBigInt)(appIndex);
        this.fieldName = fieldName;
        this.source = source;
        this.txnIndex = (0, utils_js_1.ensureSafeInteger)(txnIndex);
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return DryrunSource.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['app-index', this.appIndex],
            ['field-name', this.fieldName],
            ['source', this.source],
            ['txn-index', this.txnIndex],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded DryrunSource: ${data}`);
        }
        return new DryrunSource({
            appIndex: data.get('app-index'),
            fieldName: data.get('field-name'),
            source: data.get('source'),
            txnIndex: data.get('txn-index'),
        });
    }
}
exports.DryrunSource = DryrunSource;
/**
 * Stores the TEAL eval step data
 */
class DryrunState {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: 'line', valueSchema: new index_js_1.Uint64Schema(), omitEmpty: true }, { key: 'pc', valueSchema: new index_js_1.Uint64Schema(), omitEmpty: true }, {
                key: 'stack',
                valueSchema: new index_js_1.ArraySchema(TealValue.encodingSchema),
                omitEmpty: true,
            }, {
                key: 'error',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.StringSchema()),
                omitEmpty: true,
            }, {
                key: 'scratch',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.ArraySchema(TealValue.encodingSchema)),
                omitEmpty: true,
            });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `DryrunState` object.
     * @param line - Line number
     * @param pc - Program counter
     * @param stack -
     * @param error - Evaluation error if any
     * @param scratch -
     */
    constructor({ line, pc, stack, error, scratch, }) {
        this.line = (0, utils_js_1.ensureSafeInteger)(line);
        this.pc = (0, utils_js_1.ensureSafeInteger)(pc);
        this.stack = stack;
        this.error = error;
        this.scratch = scratch;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return DryrunState.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['line', this.line],
            ['pc', this.pc],
            ['stack', this.stack.map((v) => v.toEncodingData())],
            ['error', this.error],
            [
                'scratch',
                typeof this.scratch !== 'undefined'
                    ? this.scratch.map((v) => v.toEncodingData())
                    : undefined,
            ],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded DryrunState: ${data}`);
        }
        return new DryrunState({
            line: data.get('line'),
            pc: data.get('pc'),
            stack: (data.get('stack') ?? []).map((v) => TealValue.fromEncodingData(v)),
            error: data.get('error'),
            scratch: typeof data.get('scratch') !== 'undefined'
                ? data
                    .get('scratch')
                    .map((v) => TealValue.fromEncodingData(v))
                : undefined,
        });
    }
}
exports.DryrunState = DryrunState;
/**
 * DryrunTxnResult contains any LogicSig or ApplicationCall program debug
 * information and state updates from a dryrun.
 */
class DryrunTxnResult {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
                key: 'disassembly',
                valueSchema: new index_js_1.ArraySchema(new index_js_1.StringSchema()),
                omitEmpty: true,
            }, {
                key: 'app-call-messages',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.ArraySchema(new index_js_1.StringSchema())),
                omitEmpty: true,
            }, {
                key: 'app-call-trace',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.ArraySchema(DryrunState.encodingSchema)),
                omitEmpty: true,
            }, {
                key: 'budget-added',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()),
                omitEmpty: true,
            }, {
                key: 'budget-consumed',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()),
                omitEmpty: true,
            }, {
                key: 'global-delta',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.ArraySchema(EvalDeltaKeyValue.encodingSchema)),
                omitEmpty: true,
            }, {
                key: 'local-deltas',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.ArraySchema(AccountStateDelta.encodingSchema)),
                omitEmpty: true,
            }, {
                key: 'logic-sig-disassembly',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.ArraySchema(new index_js_1.StringSchema())),
                omitEmpty: true,
            }, {
                key: 'logic-sig-messages',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.ArraySchema(new index_js_1.StringSchema())),
                omitEmpty: true,
            }, {
                key: 'logic-sig-trace',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.ArraySchema(DryrunState.encodingSchema)),
                omitEmpty: true,
            }, {
                key: 'logs',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.ArraySchema(new index_js_1.ByteArraySchema())),
                omitEmpty: true,
            });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `DryrunTxnResult` object.
     * @param disassembly - Disassembled program line by line.
     * @param appCallMessages -
     * @param appCallTrace -
     * @param budgetAdded - Budget added during execution of app call transaction.
     * @param budgetConsumed - Budget consumed during execution of app call transaction.
     * @param globalDelta - Application state delta.
     * @param localDeltas -
     * @param logicSigDisassembly - Disassembled lsig program line by line.
     * @param logicSigMessages -
     * @param logicSigTrace -
     * @param logs -
     */
    constructor({ disassembly, appCallMessages, appCallTrace, budgetAdded, budgetConsumed, globalDelta, localDeltas, logicSigDisassembly, logicSigMessages, logicSigTrace, logs, }) {
        this.disassembly = disassembly;
        this.appCallMessages = appCallMessages;
        this.appCallTrace = appCallTrace;
        this.budgetAdded =
            typeof budgetAdded === 'undefined'
                ? undefined
                : (0, utils_js_1.ensureSafeInteger)(budgetAdded);
        this.budgetConsumed =
            typeof budgetConsumed === 'undefined'
                ? undefined
                : (0, utils_js_1.ensureSafeInteger)(budgetConsumed);
        this.globalDelta = globalDelta;
        this.localDeltas = localDeltas;
        this.logicSigDisassembly = logicSigDisassembly;
        this.logicSigMessages = logicSigMessages;
        this.logicSigTrace = logicSigTrace;
        this.logs = logs;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return DryrunTxnResult.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['disassembly', this.disassembly],
            ['app-call-messages', this.appCallMessages],
            [
                'app-call-trace',
                typeof this.appCallTrace !== 'undefined'
                    ? this.appCallTrace.map((v) => v.toEncodingData())
                    : undefined,
            ],
            ['budget-added', this.budgetAdded],
            ['budget-consumed', this.budgetConsumed],
            [
                'global-delta',
                typeof this.globalDelta !== 'undefined'
                    ? this.globalDelta.map((v) => v.toEncodingData())
                    : undefined,
            ],
            [
                'local-deltas',
                typeof this.localDeltas !== 'undefined'
                    ? this.localDeltas.map((v) => v.toEncodingData())
                    : undefined,
            ],
            ['logic-sig-disassembly', this.logicSigDisassembly],
            ['logic-sig-messages', this.logicSigMessages],
            [
                'logic-sig-trace',
                typeof this.logicSigTrace !== 'undefined'
                    ? this.logicSigTrace.map((v) => v.toEncodingData())
                    : undefined,
            ],
            ['logs', this.logs],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded DryrunTxnResult: ${data}`);
        }
        return new DryrunTxnResult({
            disassembly: data.get('disassembly'),
            appCallMessages: data.get('app-call-messages'),
            appCallTrace: typeof data.get('app-call-trace') !== 'undefined'
                ? data
                    .get('app-call-trace')
                    .map((v) => DryrunState.fromEncodingData(v))
                : undefined,
            budgetAdded: data.get('budget-added'),
            budgetConsumed: data.get('budget-consumed'),
            globalDelta: typeof data.get('global-delta') !== 'undefined'
                ? data
                    .get('global-delta')
                    .map((v) => EvalDeltaKeyValue.fromEncodingData(v))
                : undefined,
            localDeltas: typeof data.get('local-deltas') !== 'undefined'
                ? data
                    .get('local-deltas')
                    .map((v) => AccountStateDelta.fromEncodingData(v))
                : undefined,
            logicSigDisassembly: data.get('logic-sig-disassembly'),
            logicSigMessages: data.get('logic-sig-messages'),
            logicSigTrace: typeof data.get('logic-sig-trace') !== 'undefined'
                ? data
                    .get('logic-sig-trace')
                    .map((v) => DryrunState.fromEncodingData(v))
                : undefined,
            logs: data.get('logs'),
        });
    }
}
exports.DryrunTxnResult = DryrunTxnResult;
/**
 * An error response with optional data field.
 */
class ErrorResponse {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: 'message', valueSchema: new index_js_1.StringSchema(), omitEmpty: true }, {
                key: 'data',
                valueSchema: new index_js_1.OptionalSchema(untypedmodel_js_1.UntypedValue.encodingSchema),
                omitEmpty: true,
            });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `ErrorResponse` object.
     * @param message -
     * @param data -
     */
    constructor({ message, data }) {
        this.message = message;
        this.data = data;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return ErrorResponse.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['message', this.message],
            [
                'data',
                typeof this.data !== 'undefined'
                    ? this.data.toEncodingData()
                    : undefined,
            ],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded ErrorResponse: ${data}`);
        }
        return new ErrorResponse({
            message: data.get('message'),
            data: typeof data.get('data') !== 'undefined'
                ? untypedmodel_js_1.UntypedValue.fromEncodingData(data.get('data'))
                : undefined,
        });
    }
}
exports.ErrorResponse = ErrorResponse;
/**
 * Represents a TEAL value delta.
 */
class EvalDelta {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: 'action', valueSchema: new index_js_1.Uint64Schema(), omitEmpty: true }, {
                key: 'bytes',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.StringSchema()),
                omitEmpty: true,
            }, {
                key: 'uint',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()),
                omitEmpty: true,
            });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `EvalDelta` object.
     * @param action - (at) delta action.
     * @param bytes - (bs) bytes value.
     * @param uint - (ui) uint value.
     */
    constructor({ action, bytes, uint, }) {
        this.action = (0, utils_js_1.ensureSafeInteger)(action);
        this.bytes = bytes;
        this.uint = typeof uint === 'undefined' ? undefined : (0, utils_js_1.ensureBigInt)(uint);
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return EvalDelta.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['action', this.action],
            ['bytes', this.bytes],
            ['uint', this.uint],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded EvalDelta: ${data}`);
        }
        return new EvalDelta({
            action: data.get('action'),
            bytes: data.get('bytes'),
            uint: data.get('uint'),
        });
    }
}
exports.EvalDelta = EvalDelta;
/**
 * Key-value pairs for StateDelta.
 */
class EvalDeltaKeyValue {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: 'key', valueSchema: new index_js_1.StringSchema(), omitEmpty: true }, { key: 'value', valueSchema: EvalDelta.encodingSchema, omitEmpty: true });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `EvalDeltaKeyValue` object.
     * @param key -
     * @param value - Represents a TEAL value delta.
     */
    constructor({ key, value }) {
        this.key = key;
        this.value = value;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return EvalDeltaKeyValue.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['key', this.key],
            ['value', this.value.toEncodingData()],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded EvalDeltaKeyValue: ${data}`);
        }
        return new EvalDeltaKeyValue({
            key: data.get('key'),
            value: EvalDelta.fromEncodingData(data.get('value') ?? new Map()),
        });
    }
}
exports.EvalDeltaKeyValue = EvalDeltaKeyValue;
class Genesis {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
                key: 'alloc',
                valueSchema: new index_js_1.ArraySchema(GenesisAllocation.encodingSchema),
                omitEmpty: true,
            }, { key: 'fees', valueSchema: new index_js_1.StringSchema(), omitEmpty: true }, { key: 'id', valueSchema: new index_js_1.StringSchema(), omitEmpty: true }, { key: 'network', valueSchema: new index_js_1.StringSchema(), omitEmpty: true }, { key: 'proto', valueSchema: new index_js_1.StringSchema(), omitEmpty: true }, { key: 'rwd', valueSchema: new index_js_1.StringSchema(), omitEmpty: true }, { key: 'timestamp', valueSchema: new index_js_1.Uint64Schema(), omitEmpty: true }, {
                key: 'comment',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.StringSchema()),
                omitEmpty: true,
            }, {
                key: 'devmode',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.BooleanSchema()),
                omitEmpty: true,
            });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `Genesis` object.
     * @param alloc -
     * @param fees -
     * @param id -
     * @param network -
     * @param proto -
     * @param rwd -
     * @param timestamp -
     * @param comment -
     * @param devmode -
     */
    constructor({ alloc, fees, id, network, proto, rwd, timestamp, comment, devmode, }) {
        this.alloc = alloc;
        this.fees = fees;
        this.id = id;
        this.network = network;
        this.proto = proto;
        this.rwd = rwd;
        this.timestamp = (0, utils_js_1.ensureSafeInteger)(timestamp);
        this.comment = comment;
        this.devmode = devmode;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return Genesis.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['alloc', this.alloc.map((v) => v.toEncodingData())],
            ['fees', this.fees],
            ['id', this.id],
            ['network', this.network],
            ['proto', this.proto],
            ['rwd', this.rwd],
            ['timestamp', this.timestamp],
            ['comment', this.comment],
            ['devmode', this.devmode],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded Genesis: ${data}`);
        }
        return new Genesis({
            alloc: (data.get('alloc') ?? []).map((v) => GenesisAllocation.fromEncodingData(v)),
            fees: data.get('fees'),
            id: data.get('id'),
            network: data.get('network'),
            proto: data.get('proto'),
            rwd: data.get('rwd'),
            timestamp: data.get('timestamp'),
            comment: data.get('comment'),
            devmode: data.get('devmode'),
        });
    }
}
exports.Genesis = Genesis;
class GenesisAllocation {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: 'addr', valueSchema: new index_js_1.StringSchema(), omitEmpty: true }, { key: 'comment', valueSchema: new index_js_1.StringSchema(), omitEmpty: true }, {
                key: 'state',
                valueSchema: untypedmodel_js_1.UntypedValue.encodingSchema,
                omitEmpty: true,
            });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `GenesisAllocation` object.
     * @param addr -
     * @param comment -
     * @param state -
     */
    constructor({ addr, comment, state, }) {
        this.addr = addr;
        this.comment = comment;
        this.state = state;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return GenesisAllocation.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['addr', this.addr],
            ['comment', this.comment],
            ['state', this.state.toEncodingData()],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded GenesisAllocation: ${data}`);
        }
        return new GenesisAllocation({
            addr: data.get('addr'),
            comment: data.get('comment'),
            state: untypedmodel_js_1.UntypedValue.fromEncodingData(data.get('state') ?? new Map()),
        });
    }
}
exports.GenesisAllocation = GenesisAllocation;
/**
 * Response containing the timestamp offset in seconds
 */
class GetBlockTimeStampOffsetResponse {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
                key: 'offset',
                valueSchema: new index_js_1.Uint64Schema(),
                omitEmpty: true,
            });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `GetBlockTimeStampOffsetResponse` object.
     * @param offset - Timestamp offset in seconds.
     */
    constructor({ offset }) {
        this.offset = (0, utils_js_1.ensureSafeInteger)(offset);
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return GetBlockTimeStampOffsetResponse.encodingSchema;
    }
    toEncodingData() {
        return new Map([['offset', this.offset]]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded GetBlockTimeStampOffsetResponse: ${data}`);
        }
        return new GetBlockTimeStampOffsetResponse({
            offset: data.get('offset'),
        });
    }
}
exports.GetBlockTimeStampOffsetResponse = GetBlockTimeStampOffsetResponse;
/**
 * Response containing the ledger's minimum sync round
 */
class GetSyncRoundResponse {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
                key: 'round',
                valueSchema: new index_js_1.Uint64Schema(),
                omitEmpty: true,
            });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `GetSyncRoundResponse` object.
     * @param round - The minimum sync round for the ledger.
     */
    constructor({ round }) {
        this.round = (0, utils_js_1.ensureBigInt)(round);
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return GetSyncRoundResponse.encodingSchema;
    }
    toEncodingData() {
        return new Map([['round', this.round]]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded GetSyncRoundResponse: ${data}`);
        }
        return new GetSyncRoundResponse({
            round: data.get('round'),
        });
    }
}
exports.GetSyncRoundResponse = GetSyncRoundResponse;
/**
 * Contains a ledger delta for a single transaction group
 */
class LedgerStateDeltaForTransactionGroup {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
                key: 'Delta',
                valueSchema: statedelta_js_1.LedgerStateDelta.encodingSchema,
                omitEmpty: true,
            }, {
                key: 'Ids',
                valueSchema: new index_js_1.ArraySchema(new index_js_1.StringSchema()),
                omitEmpty: true,
            });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `LedgerStateDeltaForTransactionGroup` object.
     * @param delta - Ledger StateDelta object
     * @param ids -
     */
    constructor({ delta, ids }) {
        this.delta = delta;
        this.ids = ids;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return LedgerStateDeltaForTransactionGroup.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['Delta', this.delta.toEncodingData()],
            ['Ids', this.ids],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded LedgerStateDeltaForTransactionGroup: ${data}`);
        }
        return new LedgerStateDeltaForTransactionGroup({
            delta: statedelta_js_1.LedgerStateDelta.fromEncodingData(data.get('Delta') ?? new Map()),
            ids: data.get('Ids'),
        });
    }
}
exports.LedgerStateDeltaForTransactionGroup = LedgerStateDeltaForTransactionGroup;
/**
 * Proof of membership and position of a light block header.
 */
class LightBlockHeaderProof {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: 'index', valueSchema: new index_js_1.Uint64Schema(), omitEmpty: true }, { key: 'proof', valueSchema: new index_js_1.ByteArraySchema(), omitEmpty: true }, { key: 'treedepth', valueSchema: new index_js_1.Uint64Schema(), omitEmpty: true });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `LightBlockHeaderProof` object.
     * @param index - The index of the light block header in the vector commitment tree
     * @param proof - The encoded proof.
     * @param treedepth - Represents the depth of the tree that is being proven, i.e. the number of edges
     * from a leaf to the root.
     */
    constructor({ index, proof, treedepth, }) {
        this.index = (0, utils_js_1.ensureSafeInteger)(index);
        this.proof = typeof proof === 'string' ? (0, binarydata_js_1.base64ToBytes)(proof) : proof;
        this.treedepth = (0, utils_js_1.ensureSafeInteger)(treedepth);
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return LightBlockHeaderProof.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['index', this.index],
            ['proof', this.proof],
            ['treedepth', this.treedepth],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded LightBlockHeaderProof: ${data}`);
        }
        return new LightBlockHeaderProof({
            index: data.get('index'),
            proof: data.get('proof'),
            treedepth: data.get('treedepth'),
        });
    }
}
exports.LightBlockHeaderProof = LightBlockHeaderProof;
/**
 *
 */
class NodeStatusResponse {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
                key: 'catchup-time',
                valueSchema: new index_js_1.Uint64Schema(),
                omitEmpty: true,
            }, { key: 'last-round', valueSchema: new index_js_1.Uint64Schema(), omitEmpty: true }, {
                key: 'last-version',
                valueSchema: new index_js_1.StringSchema(),
                omitEmpty: true,
            }, {
                key: 'next-version',
                valueSchema: new index_js_1.StringSchema(),
                omitEmpty: true,
            }, {
                key: 'next-version-round',
                valueSchema: new index_js_1.Uint64Schema(),
                omitEmpty: true,
            }, {
                key: 'next-version-supported',
                valueSchema: new index_js_1.BooleanSchema(),
                omitEmpty: true,
            }, {
                key: 'stopped-at-unsupported-round',
                valueSchema: new index_js_1.BooleanSchema(),
                omitEmpty: true,
            }, {
                key: 'time-since-last-round',
                valueSchema: new index_js_1.Uint64Schema(),
                omitEmpty: true,
            }, {
                key: 'catchpoint',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.StringSchema()),
                omitEmpty: true,
            }, {
                key: 'catchpoint-acquired-blocks',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()),
                omitEmpty: true,
            }, {
                key: 'catchpoint-processed-accounts',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()),
                omitEmpty: true,
            }, {
                key: 'catchpoint-processed-kvs',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()),
                omitEmpty: true,
            }, {
                key: 'catchpoint-total-accounts',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()),
                omitEmpty: true,
            }, {
                key: 'catchpoint-total-blocks',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()),
                omitEmpty: true,
            }, {
                key: 'catchpoint-total-kvs',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()),
                omitEmpty: true,
            }, {
                key: 'catchpoint-verified-accounts',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()),
                omitEmpty: true,
            }, {
                key: 'catchpoint-verified-kvs',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()),
                omitEmpty: true,
            }, {
                key: 'last-catchpoint',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.StringSchema()),
                omitEmpty: true,
            }, {
                key: 'upgrade-delay',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()),
                omitEmpty: true,
            }, {
                key: 'upgrade-next-protocol-vote-before',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()),
                omitEmpty: true,
            }, {
                key: 'upgrade-no-votes',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()),
                omitEmpty: true,
            }, {
                key: 'upgrade-node-vote',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.BooleanSchema()),
                omitEmpty: true,
            }, {
                key: 'upgrade-vote-rounds',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()),
                omitEmpty: true,
            }, {
                key: 'upgrade-votes',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()),
                omitEmpty: true,
            }, {
                key: 'upgrade-votes-required',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()),
                omitEmpty: true,
            }, {
                key: 'upgrade-yes-votes',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()),
                omitEmpty: true,
            });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `NodeStatusResponse` object.
     * @param catchupTime - CatchupTime in nanoseconds
     * @param lastRound - LastRound indicates the last round seen
     * @param lastVersion - LastVersion indicates the last consensus version supported
     * @param nextVersion - NextVersion of consensus protocol to use
     * @param nextVersionRound - NextVersionRound is the round at which the next consensus version will apply
     * @param nextVersionSupported - NextVersionSupported indicates whether the next consensus version is supported
     * by this node
     * @param stoppedAtUnsupportedRound - StoppedAtUnsupportedRound indicates that the node does not support the new
     * rounds and has stopped making progress
     * @param timeSinceLastRound - TimeSinceLastRound in nanoseconds
     * @param catchpoint - The current catchpoint that is being caught up to
     * @param catchpointAcquiredBlocks - The number of blocks that have already been obtained by the node as part of the
     * catchup
     * @param catchpointProcessedAccounts - The number of accounts from the current catchpoint that have been processed so
     * far as part of the catchup
     * @param catchpointProcessedKvs - The number of key-values (KVs) from the current catchpoint that have been
     * processed so far as part of the catchup
     * @param catchpointTotalAccounts - The total number of accounts included in the current catchpoint
     * @param catchpointTotalBlocks - The total number of blocks that are required to complete the current catchpoint
     * catchup
     * @param catchpointTotalKvs - The total number of key-values (KVs) included in the current catchpoint
     * @param catchpointVerifiedAccounts - The number of accounts from the current catchpoint that have been verified so
     * far as part of the catchup
     * @param catchpointVerifiedKvs - The number of key-values (KVs) from the current catchpoint that have been
     * verified so far as part of the catchup
     * @param lastCatchpoint - The last catchpoint seen by the node
     * @param upgradeDelay - Upgrade delay
     * @param upgradeNextProtocolVoteBefore - Next protocol round
     * @param upgradeNoVotes - No votes cast for consensus upgrade
     * @param upgradeNodeVote - This node's upgrade vote
     * @param upgradeVoteRounds - Total voting rounds for current upgrade
     * @param upgradeVotes - Total votes cast for consensus upgrade
     * @param upgradeVotesRequired - Yes votes required for consensus upgrade
     * @param upgradeYesVotes - Yes votes cast for consensus upgrade
     */
    constructor({ catchupTime, lastRound, lastVersion, nextVersion, nextVersionRound, nextVersionSupported, stoppedAtUnsupportedRound, timeSinceLastRound, catchpoint, catchpointAcquiredBlocks, catchpointProcessedAccounts, catchpointProcessedKvs, catchpointTotalAccounts, catchpointTotalBlocks, catchpointTotalKvs, catchpointVerifiedAccounts, catchpointVerifiedKvs, lastCatchpoint, upgradeDelay, upgradeNextProtocolVoteBefore, upgradeNoVotes, upgradeNodeVote, upgradeVoteRounds, upgradeVotes, upgradeVotesRequired, upgradeYesVotes, }) {
        this.catchupTime = (0, utils_js_1.ensureBigInt)(catchupTime);
        this.lastRound = (0, utils_js_1.ensureBigInt)(lastRound);
        this.lastVersion = lastVersion;
        this.nextVersion = nextVersion;
        this.nextVersionRound = (0, utils_js_1.ensureBigInt)(nextVersionRound);
        this.nextVersionSupported = nextVersionSupported;
        this.stoppedAtUnsupportedRound = stoppedAtUnsupportedRound;
        this.timeSinceLastRound = (0, utils_js_1.ensureBigInt)(timeSinceLastRound);
        this.catchpoint = catchpoint;
        this.catchpointAcquiredBlocks =
            typeof catchpointAcquiredBlocks === 'undefined'
                ? undefined
                : (0, utils_js_1.ensureSafeInteger)(catchpointAcquiredBlocks);
        this.catchpointProcessedAccounts =
            typeof catchpointProcessedAccounts === 'undefined'
                ? undefined
                : (0, utils_js_1.ensureSafeInteger)(catchpointProcessedAccounts);
        this.catchpointProcessedKvs =
            typeof catchpointProcessedKvs === 'undefined'
                ? undefined
                : (0, utils_js_1.ensureSafeInteger)(catchpointProcessedKvs);
        this.catchpointTotalAccounts =
            typeof catchpointTotalAccounts === 'undefined'
                ? undefined
                : (0, utils_js_1.ensureSafeInteger)(catchpointTotalAccounts);
        this.catchpointTotalBlocks =
            typeof catchpointTotalBlocks === 'undefined'
                ? undefined
                : (0, utils_js_1.ensureSafeInteger)(catchpointTotalBlocks);
        this.catchpointTotalKvs =
            typeof catchpointTotalKvs === 'undefined'
                ? undefined
                : (0, utils_js_1.ensureSafeInteger)(catchpointTotalKvs);
        this.catchpointVerifiedAccounts =
            typeof catchpointVerifiedAccounts === 'undefined'
                ? undefined
                : (0, utils_js_1.ensureSafeInteger)(catchpointVerifiedAccounts);
        this.catchpointVerifiedKvs =
            typeof catchpointVerifiedKvs === 'undefined'
                ? undefined
                : (0, utils_js_1.ensureSafeInteger)(catchpointVerifiedKvs);
        this.lastCatchpoint = lastCatchpoint;
        this.upgradeDelay =
            typeof upgradeDelay === 'undefined'
                ? undefined
                : (0, utils_js_1.ensureBigInt)(upgradeDelay);
        this.upgradeNextProtocolVoteBefore =
            typeof upgradeNextProtocolVoteBefore === 'undefined'
                ? undefined
                : (0, utils_js_1.ensureBigInt)(upgradeNextProtocolVoteBefore);
        this.upgradeNoVotes =
            typeof upgradeNoVotes === 'undefined'
                ? undefined
                : (0, utils_js_1.ensureSafeInteger)(upgradeNoVotes);
        this.upgradeNodeVote = upgradeNodeVote;
        this.upgradeVoteRounds =
            typeof upgradeVoteRounds === 'undefined'
                ? undefined
                : (0, utils_js_1.ensureSafeInteger)(upgradeVoteRounds);
        this.upgradeVotes =
            typeof upgradeVotes === 'undefined'
                ? undefined
                : (0, utils_js_1.ensureSafeInteger)(upgradeVotes);
        this.upgradeVotesRequired =
            typeof upgradeVotesRequired === 'undefined'
                ? undefined
                : (0, utils_js_1.ensureSafeInteger)(upgradeVotesRequired);
        this.upgradeYesVotes =
            typeof upgradeYesVotes === 'undefined'
                ? undefined
                : (0, utils_js_1.ensureSafeInteger)(upgradeYesVotes);
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return NodeStatusResponse.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['catchup-time', this.catchupTime],
            ['last-round', this.lastRound],
            ['last-version', this.lastVersion],
            ['next-version', this.nextVersion],
            ['next-version-round', this.nextVersionRound],
            ['next-version-supported', this.nextVersionSupported],
            ['stopped-at-unsupported-round', this.stoppedAtUnsupportedRound],
            ['time-since-last-round', this.timeSinceLastRound],
            ['catchpoint', this.catchpoint],
            ['catchpoint-acquired-blocks', this.catchpointAcquiredBlocks],
            ['catchpoint-processed-accounts', this.catchpointProcessedAccounts],
            ['catchpoint-processed-kvs', this.catchpointProcessedKvs],
            ['catchpoint-total-accounts', this.catchpointTotalAccounts],
            ['catchpoint-total-blocks', this.catchpointTotalBlocks],
            ['catchpoint-total-kvs', this.catchpointTotalKvs],
            ['catchpoint-verified-accounts', this.catchpointVerifiedAccounts],
            ['catchpoint-verified-kvs', this.catchpointVerifiedKvs],
            ['last-catchpoint', this.lastCatchpoint],
            ['upgrade-delay', this.upgradeDelay],
            ['upgrade-next-protocol-vote-before', this.upgradeNextProtocolVoteBefore],
            ['upgrade-no-votes', this.upgradeNoVotes],
            ['upgrade-node-vote', this.upgradeNodeVote],
            ['upgrade-vote-rounds', this.upgradeVoteRounds],
            ['upgrade-votes', this.upgradeVotes],
            ['upgrade-votes-required', this.upgradeVotesRequired],
            ['upgrade-yes-votes', this.upgradeYesVotes],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded NodeStatusResponse: ${data}`);
        }
        return new NodeStatusResponse({
            catchupTime: data.get('catchup-time'),
            lastRound: data.get('last-round'),
            lastVersion: data.get('last-version'),
            nextVersion: data.get('next-version'),
            nextVersionRound: data.get('next-version-round'),
            nextVersionSupported: data.get('next-version-supported'),
            stoppedAtUnsupportedRound: data.get('stopped-at-unsupported-round'),
            timeSinceLastRound: data.get('time-since-last-round'),
            catchpoint: data.get('catchpoint'),
            catchpointAcquiredBlocks: data.get('catchpoint-acquired-blocks'),
            catchpointProcessedAccounts: data.get('catchpoint-processed-accounts'),
            catchpointProcessedKvs: data.get('catchpoint-processed-kvs'),
            catchpointTotalAccounts: data.get('catchpoint-total-accounts'),
            catchpointTotalBlocks: data.get('catchpoint-total-blocks'),
            catchpointTotalKvs: data.get('catchpoint-total-kvs'),
            catchpointVerifiedAccounts: data.get('catchpoint-verified-accounts'),
            catchpointVerifiedKvs: data.get('catchpoint-verified-kvs'),
            lastCatchpoint: data.get('last-catchpoint'),
            upgradeDelay: data.get('upgrade-delay'),
            upgradeNextProtocolVoteBefore: data.get('upgrade-next-protocol-vote-before'),
            upgradeNoVotes: data.get('upgrade-no-votes'),
            upgradeNodeVote: data.get('upgrade-node-vote'),
            upgradeVoteRounds: data.get('upgrade-vote-rounds'),
            upgradeVotes: data.get('upgrade-votes'),
            upgradeVotesRequired: data.get('upgrade-votes-required'),
            upgradeYesVotes: data.get('upgrade-yes-votes'),
        });
    }
}
exports.NodeStatusResponse = NodeStatusResponse;
/**
 * Details about a pending transaction. If the transaction was recently confirmed,
 * includes confirmation details like the round and reward details.
 */
class PendingTransactionResponse {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: 'pool-error', valueSchema: new index_js_1.StringSchema(), omitEmpty: true }, {
                key: 'txn',
                valueSchema: signedTransaction_js_1.SignedTransaction.encodingSchema,
                omitEmpty: true,
            }, {
                key: 'application-index',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()),
                omitEmpty: true,
            }, {
                key: 'asset-closing-amount',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()),
                omitEmpty: true,
            }, {
                key: 'asset-index',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()),
                omitEmpty: true,
            }, {
                key: 'close-rewards',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()),
                omitEmpty: true,
            }, {
                key: 'closing-amount',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()),
                omitEmpty: true,
            }, {
                key: 'confirmed-round',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()),
                omitEmpty: true,
            }, {
                key: 'global-state-delta',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.ArraySchema(EvalDeltaKeyValue.encodingSchema)),
                omitEmpty: true,
            }, {
                key: 'inner-txns',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.ArraySchema(PendingTransactionResponse.encodingSchema)),
                omitEmpty: true,
            }, {
                key: 'local-state-delta',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.ArraySchema(AccountStateDelta.encodingSchema)),
                omitEmpty: true,
            }, {
                key: 'logs',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.ArraySchema(new index_js_1.ByteArraySchema())),
                omitEmpty: true,
            }, {
                key: 'receiver-rewards',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()),
                omitEmpty: true,
            }, {
                key: 'sender-rewards',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()),
                omitEmpty: true,
            });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `PendingTransactionResponse` object.
     * @param poolError - Indicates that the transaction was kicked out of this node's transaction pool
     * (and specifies why that happened). An empty string indicates the transaction
     * wasn't kicked out of this node's txpool due to an error.
     * @param txn - The raw signed transaction.
     * @param applicationIndex - The application index if the transaction was found and it created an
     * application.
     * @param assetClosingAmount - The number of the asset's unit that were transferred to the close-to address.
     * @param assetIndex - The asset index if the transaction was found and it created an asset.
     * @param closeRewards - Rewards in microalgos applied to the close remainder to account.
     * @param closingAmount - Closing amount for the transaction.
     * @param confirmedRound - The round where this transaction was confirmed, if present.
     * @param globalStateDelta - Global state key/value changes for the application being executed by this
     * transaction.
     * @param innerTxns - Inner transactions produced by application execution.
     * @param localStateDelta - Local state key/value changes for the application being executed by this
     * transaction.
     * @param logs - Logs for the application being executed by this transaction.
     * @param receiverRewards - Rewards in microalgos applied to the receiver account.
     * @param senderRewards - Rewards in microalgos applied to the sender account.
     */
    constructor({ poolError, txn, applicationIndex, assetClosingAmount, assetIndex, closeRewards, closingAmount, confirmedRound, globalStateDelta, innerTxns, localStateDelta, logs, receiverRewards, senderRewards, }) {
        this.poolError = poolError;
        this.txn = txn;
        this.applicationIndex =
            typeof applicationIndex === 'undefined'
                ? undefined
                : (0, utils_js_1.ensureBigInt)(applicationIndex);
        this.assetClosingAmount =
            typeof assetClosingAmount === 'undefined'
                ? undefined
                : (0, utils_js_1.ensureBigInt)(assetClosingAmount);
        this.assetIndex =
            typeof assetIndex === 'undefined' ? undefined : (0, utils_js_1.ensureBigInt)(assetIndex);
        this.closeRewards =
            typeof closeRewards === 'undefined'
                ? undefined
                : (0, utils_js_1.ensureBigInt)(closeRewards);
        this.closingAmount =
            typeof closingAmount === 'undefined'
                ? undefined
                : (0, utils_js_1.ensureBigInt)(closingAmount);
        this.confirmedRound =
            typeof confirmedRound === 'undefined'
                ? undefined
                : (0, utils_js_1.ensureBigInt)(confirmedRound);
        this.globalStateDelta = globalStateDelta;
        this.innerTxns = innerTxns;
        this.localStateDelta = localStateDelta;
        this.logs = logs;
        this.receiverRewards =
            typeof receiverRewards === 'undefined'
                ? undefined
                : (0, utils_js_1.ensureBigInt)(receiverRewards);
        this.senderRewards =
            typeof senderRewards === 'undefined'
                ? undefined
                : (0, utils_js_1.ensureBigInt)(senderRewards);
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return PendingTransactionResponse.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['pool-error', this.poolError],
            ['txn', this.txn.toEncodingData()],
            ['application-index', this.applicationIndex],
            ['asset-closing-amount', this.assetClosingAmount],
            ['asset-index', this.assetIndex],
            ['close-rewards', this.closeRewards],
            ['closing-amount', this.closingAmount],
            ['confirmed-round', this.confirmedRound],
            [
                'global-state-delta',
                typeof this.globalStateDelta !== 'undefined'
                    ? this.globalStateDelta.map((v) => v.toEncodingData())
                    : undefined,
            ],
            [
                'inner-txns',
                typeof this.innerTxns !== 'undefined'
                    ? this.innerTxns.map((v) => v.toEncodingData())
                    : undefined,
            ],
            [
                'local-state-delta',
                typeof this.localStateDelta !== 'undefined'
                    ? this.localStateDelta.map((v) => v.toEncodingData())
                    : undefined,
            ],
            ['logs', this.logs],
            ['receiver-rewards', this.receiverRewards],
            ['sender-rewards', this.senderRewards],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded PendingTransactionResponse: ${data}`);
        }
        return new PendingTransactionResponse({
            poolError: data.get('pool-error'),
            txn: signedTransaction_js_1.SignedTransaction.fromEncodingData(data.get('txn') ?? new Map()),
            applicationIndex: data.get('application-index'),
            assetClosingAmount: data.get('asset-closing-amount'),
            assetIndex: data.get('asset-index'),
            closeRewards: data.get('close-rewards'),
            closingAmount: data.get('closing-amount'),
            confirmedRound: data.get('confirmed-round'),
            globalStateDelta: typeof data.get('global-state-delta') !== 'undefined'
                ? data
                    .get('global-state-delta')
                    .map((v) => EvalDeltaKeyValue.fromEncodingData(v))
                : undefined,
            innerTxns: typeof data.get('inner-txns') !== 'undefined'
                ? data
                    .get('inner-txns')
                    .map((v) => PendingTransactionResponse.fromEncodingData(v))
                : undefined,
            localStateDelta: typeof data.get('local-state-delta') !== 'undefined'
                ? data
                    .get('local-state-delta')
                    .map((v) => AccountStateDelta.fromEncodingData(v))
                : undefined,
            logs: data.get('logs'),
            receiverRewards: data.get('receiver-rewards'),
            senderRewards: data.get('sender-rewards'),
        });
    }
}
exports.PendingTransactionResponse = PendingTransactionResponse;
/**
 * A potentially truncated list of transactions currently in the node's transaction
 * pool. You can compute whether or not the list is truncated if the number of
 * elements in the **top-transactions** array is fewer than **total-transactions**.
 */
class PendingTransactionsResponse {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
                key: 'top-transactions',
                valueSchema: new index_js_1.ArraySchema(signedTransaction_js_1.SignedTransaction.encodingSchema),
                omitEmpty: true,
            }, {
                key: 'total-transactions',
                valueSchema: new index_js_1.Uint64Schema(),
                omitEmpty: true,
            });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `PendingTransactionsResponse` object.
     * @param topTransactions - An array of signed transaction objects.
     * @param totalTransactions - Total number of transactions in the pool.
     */
    constructor({ topTransactions, totalTransactions, }) {
        this.topTransactions = topTransactions;
        this.totalTransactions = (0, utils_js_1.ensureSafeInteger)(totalTransactions);
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return PendingTransactionsResponse.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['top-transactions', this.topTransactions.map((v) => v.toEncodingData())],
            ['total-transactions', this.totalTransactions],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded PendingTransactionsResponse: ${data}`);
        }
        return new PendingTransactionsResponse({
            topTransactions: (data.get('top-transactions') ?? []).map((v) => signedTransaction_js_1.SignedTransaction.fromEncodingData(v)),
            totalTransactions: data.get('total-transactions'),
        });
    }
}
exports.PendingTransactionsResponse = PendingTransactionsResponse;
/**
 * Transaction ID of the submission.
 */
class PostTransactionsResponse {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
                key: 'txId',
                valueSchema: new index_js_1.StringSchema(),
                omitEmpty: true,
            });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `PostTransactionsResponse` object.
     * @param txid - encoding of the transaction hash.
     */
    constructor({ txid }) {
        this.txid = txid;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return PostTransactionsResponse.encodingSchema;
    }
    toEncodingData() {
        return new Map([['txId', this.txid]]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded PostTransactionsResponse: ${data}`);
        }
        return new PostTransactionsResponse({
            txid: data.get('txId'),
        });
    }
}
exports.PostTransactionsResponse = PostTransactionsResponse;
/**
 * A write operation into a scratch slot.
 */
class ScratchChange {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
                key: 'new-value',
                valueSchema: AvmValue.encodingSchema,
                omitEmpty: true,
            }, { key: 'slot', valueSchema: new index_js_1.Uint64Schema(), omitEmpty: true });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `ScratchChange` object.
     * @param newValue - Represents an AVM value.
     * @param slot - The scratch slot written.
     */
    constructor({ newValue, slot, }) {
        this.newValue = newValue;
        this.slot = (0, utils_js_1.ensureSafeInteger)(slot);
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return ScratchChange.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['new-value', this.newValue.toEncodingData()],
            ['slot', this.slot],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded ScratchChange: ${data}`);
        }
        return new ScratchChange({
            newValue: AvmValue.fromEncodingData(data.get('new-value') ?? new Map()),
            slot: data.get('slot'),
        });
    }
}
exports.ScratchChange = ScratchChange;
/**
 * Initial states of resources that were accessed during simulation.
 */
class SimulateInitialStates {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
                key: 'app-initial-states',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.ArraySchema(ApplicationInitialStates.encodingSchema)),
                omitEmpty: true,
            });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `SimulateInitialStates` object.
     * @param appInitialStates - The initial states of accessed application before simulation. The order of this
     * array is arbitrary.
     */
    constructor({ appInitialStates, }) {
        this.appInitialStates = appInitialStates;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return SimulateInitialStates.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            [
                'app-initial-states',
                typeof this.appInitialStates !== 'undefined'
                    ? this.appInitialStates.map((v) => v.toEncodingData())
                    : undefined,
            ],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded SimulateInitialStates: ${data}`);
        }
        return new SimulateInitialStates({
            appInitialStates: typeof data.get('app-initial-states') !== 'undefined'
                ? data
                    .get('app-initial-states')
                    .map((v) => ApplicationInitialStates.fromEncodingData(v))
                : undefined,
        });
    }
}
exports.SimulateInitialStates = SimulateInitialStates;
/**
 * Request type for simulation endpoint.
 */
class SimulateRequest {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
                key: 'txn-groups',
                valueSchema: new index_js_1.ArraySchema(SimulateRequestTransactionGroup.encodingSchema),
                omitEmpty: true,
            }, {
                key: 'allow-empty-signatures',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.BooleanSchema()),
                omitEmpty: true,
            }, {
                key: 'allow-more-logging',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.BooleanSchema()),
                omitEmpty: true,
            }, {
                key: 'allow-unnamed-resources',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.BooleanSchema()),
                omitEmpty: true,
            }, {
                key: 'exec-trace-config',
                valueSchema: new index_js_1.OptionalSchema(SimulateTraceConfig.encodingSchema),
                omitEmpty: true,
            }, {
                key: 'extra-opcode-budget',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()),
                omitEmpty: true,
            }, {
                key: 'fix-signers',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.BooleanSchema()),
                omitEmpty: true,
            }, {
                key: 'round',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()),
                omitEmpty: true,
            });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `SimulateRequest` object.
     * @param txnGroups - The transaction groups to simulate.
     * @param allowEmptySignatures - Allows transactions without signatures to be simulated as if they had correct
     * signatures.
     * @param allowMoreLogging - Lifts limits on log opcode usage during simulation.
     * @param allowUnnamedResources - Allows access to unnamed resources during simulation.
     * @param execTraceConfig - An object that configures simulation execution trace.
     * @param extraOpcodeBudget - Applies extra opcode budget during simulation for each transaction group.
     * @param fixSigners - If true, signers for transactions that are missing signatures will be fixed
     * during evaluation.
     * @param round - If provided, specifies the round preceding the simulation. State changes through
     * this round will be used to run this simulation. Usually only the 4 most recent
     * rounds will be available (controlled by the node config value MaxAcctLookback).
     * If not specified, defaults to the latest available round.
     */
    constructor({ txnGroups, allowEmptySignatures, allowMoreLogging, allowUnnamedResources, execTraceConfig, extraOpcodeBudget, fixSigners, round, }) {
        this.txnGroups = txnGroups;
        this.allowEmptySignatures = allowEmptySignatures;
        this.allowMoreLogging = allowMoreLogging;
        this.allowUnnamedResources = allowUnnamedResources;
        this.execTraceConfig = execTraceConfig;
        this.extraOpcodeBudget =
            typeof extraOpcodeBudget === 'undefined'
                ? undefined
                : (0, utils_js_1.ensureSafeInteger)(extraOpcodeBudget);
        this.fixSigners = fixSigners;
        this.round = typeof round === 'undefined' ? undefined : (0, utils_js_1.ensureBigInt)(round);
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return SimulateRequest.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['txn-groups', this.txnGroups.map((v) => v.toEncodingData())],
            ['allow-empty-signatures', this.allowEmptySignatures],
            ['allow-more-logging', this.allowMoreLogging],
            ['allow-unnamed-resources', this.allowUnnamedResources],
            [
                'exec-trace-config',
                typeof this.execTraceConfig !== 'undefined'
                    ? this.execTraceConfig.toEncodingData()
                    : undefined,
            ],
            ['extra-opcode-budget', this.extraOpcodeBudget],
            ['fix-signers', this.fixSigners],
            ['round', this.round],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded SimulateRequest: ${data}`);
        }
        return new SimulateRequest({
            txnGroups: (data.get('txn-groups') ?? []).map((v) => SimulateRequestTransactionGroup.fromEncodingData(v)),
            allowEmptySignatures: data.get('allow-empty-signatures'),
            allowMoreLogging: data.get('allow-more-logging'),
            allowUnnamedResources: data.get('allow-unnamed-resources'),
            execTraceConfig: typeof data.get('exec-trace-config') !== 'undefined'
                ? SimulateTraceConfig.fromEncodingData(data.get('exec-trace-config'))
                : undefined,
            extraOpcodeBudget: data.get('extra-opcode-budget'),
            fixSigners: data.get('fix-signers'),
            round: data.get('round'),
        });
    }
}
exports.SimulateRequest = SimulateRequest;
/**
 * A transaction group to simulate.
 */
class SimulateRequestTransactionGroup {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
                key: 'txns',
                valueSchema: new index_js_1.ArraySchema(signedTransaction_js_1.SignedTransaction.encodingSchema),
                omitEmpty: true,
            });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `SimulateRequestTransactionGroup` object.
     * @param txns - An atomic transaction group.
     */
    constructor({ txns }) {
        this.txns = txns;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return SimulateRequestTransactionGroup.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['txns', this.txns.map((v) => v.toEncodingData())],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded SimulateRequestTransactionGroup: ${data}`);
        }
        return new SimulateRequestTransactionGroup({
            txns: (data.get('txns') ?? []).map((v) => signedTransaction_js_1.SignedTransaction.fromEncodingData(v)),
        });
    }
}
exports.SimulateRequestTransactionGroup = SimulateRequestTransactionGroup;
/**
 * Result of a transaction group simulation.
 */
class SimulateResponse {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: 'last-round', valueSchema: new index_js_1.Uint64Schema(), omitEmpty: true }, {
                key: 'txn-groups',
                valueSchema: new index_js_1.ArraySchema(SimulateTransactionGroupResult.encodingSchema),
                omitEmpty: true,
            }, { key: 'version', valueSchema: new index_js_1.Uint64Schema(), omitEmpty: true }, {
                key: 'eval-overrides',
                valueSchema: new index_js_1.OptionalSchema(SimulationEvalOverrides.encodingSchema),
                omitEmpty: true,
            }, {
                key: 'exec-trace-config',
                valueSchema: new index_js_1.OptionalSchema(SimulateTraceConfig.encodingSchema),
                omitEmpty: true,
            }, {
                key: 'initial-states',
                valueSchema: new index_js_1.OptionalSchema(SimulateInitialStates.encodingSchema),
                omitEmpty: true,
            });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `SimulateResponse` object.
     * @param lastRound - The round immediately preceding this simulation. State changes through this
     * round were used to run this simulation.
     * @param txnGroups - A result object for each transaction group that was simulated.
     * @param version - The version of this response object.
     * @param evalOverrides - The set of parameters and limits override during simulation. If this set of
     * parameters is present, then evaluation parameters may differ from standard
     * evaluation in certain ways.
     * @param execTraceConfig - An object that configures simulation execution trace.
     * @param initialStates - Initial states of resources that were accessed during simulation.
     */
    constructor({ lastRound, txnGroups, version, evalOverrides, execTraceConfig, initialStates, }) {
        this.lastRound = (0, utils_js_1.ensureBigInt)(lastRound);
        this.txnGroups = txnGroups;
        this.version = (0, utils_js_1.ensureSafeInteger)(version);
        this.evalOverrides = evalOverrides;
        this.execTraceConfig = execTraceConfig;
        this.initialStates = initialStates;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return SimulateResponse.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['last-round', this.lastRound],
            ['txn-groups', this.txnGroups.map((v) => v.toEncodingData())],
            ['version', this.version],
            [
                'eval-overrides',
                typeof this.evalOverrides !== 'undefined'
                    ? this.evalOverrides.toEncodingData()
                    : undefined,
            ],
            [
                'exec-trace-config',
                typeof this.execTraceConfig !== 'undefined'
                    ? this.execTraceConfig.toEncodingData()
                    : undefined,
            ],
            [
                'initial-states',
                typeof this.initialStates !== 'undefined'
                    ? this.initialStates.toEncodingData()
                    : undefined,
            ],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded SimulateResponse: ${data}`);
        }
        return new SimulateResponse({
            lastRound: data.get('last-round'),
            txnGroups: (data.get('txn-groups') ?? []).map((v) => SimulateTransactionGroupResult.fromEncodingData(v)),
            version: data.get('version'),
            evalOverrides: typeof data.get('eval-overrides') !== 'undefined'
                ? SimulationEvalOverrides.fromEncodingData(data.get('eval-overrides'))
                : undefined,
            execTraceConfig: typeof data.get('exec-trace-config') !== 'undefined'
                ? SimulateTraceConfig.fromEncodingData(data.get('exec-trace-config'))
                : undefined,
            initialStates: typeof data.get('initial-states') !== 'undefined'
                ? SimulateInitialStates.fromEncodingData(data.get('initial-states'))
                : undefined,
        });
    }
}
exports.SimulateResponse = SimulateResponse;
/**
 * An object that configures simulation execution trace.
 */
class SimulateTraceConfig {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
                key: 'enable',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.BooleanSchema()),
                omitEmpty: true,
            }, {
                key: 'scratch-change',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.BooleanSchema()),
                omitEmpty: true,
            }, {
                key: 'stack-change',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.BooleanSchema()),
                omitEmpty: true,
            }, {
                key: 'state-change',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.BooleanSchema()),
                omitEmpty: true,
            });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `SimulateTraceConfig` object.
     * @param enable - A boolean option for opting in execution trace features simulation endpoint.
     * @param scratchChange - A boolean option enabling returning scratch slot changes together with execution
     * trace during simulation.
     * @param stackChange - A boolean option enabling returning stack changes together with execution trace
     * during simulation.
     * @param stateChange - A boolean option enabling returning application state changes (global, local,
     * and box changes) with the execution trace during simulation.
     */
    constructor({ enable, scratchChange, stackChange, stateChange, }) {
        this.enable = enable;
        this.scratchChange = scratchChange;
        this.stackChange = stackChange;
        this.stateChange = stateChange;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return SimulateTraceConfig.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['enable', this.enable],
            ['scratch-change', this.scratchChange],
            ['stack-change', this.stackChange],
            ['state-change', this.stateChange],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded SimulateTraceConfig: ${data}`);
        }
        return new SimulateTraceConfig({
            enable: data.get('enable'),
            scratchChange: data.get('scratch-change'),
            stackChange: data.get('stack-change'),
            stateChange: data.get('state-change'),
        });
    }
}
exports.SimulateTraceConfig = SimulateTraceConfig;
/**
 * Simulation result for an atomic transaction group
 */
class SimulateTransactionGroupResult {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
                key: 'txn-results',
                valueSchema: new index_js_1.ArraySchema(SimulateTransactionResult.encodingSchema),
                omitEmpty: true,
            }, {
                key: 'app-budget-added',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()),
                omitEmpty: true,
            }, {
                key: 'app-budget-consumed',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()),
                omitEmpty: true,
            }, {
                key: 'failed-at',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.ArraySchema(new index_js_1.Uint64Schema())),
                omitEmpty: true,
            }, {
                key: 'failure-message',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.StringSchema()),
                omitEmpty: true,
            }, {
                key: 'unnamed-resources-accessed',
                valueSchema: new index_js_1.OptionalSchema(SimulateUnnamedResourcesAccessed.encodingSchema),
                omitEmpty: true,
            });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `SimulateTransactionGroupResult` object.
     * @param txnResults - Simulation result for individual transactions
     * @param appBudgetAdded - Total budget added during execution of app calls in the transaction group.
     * @param appBudgetConsumed - Total budget consumed during execution of app calls in the transaction group.
     * @param failedAt - If present, indicates which transaction in this group caused the failure. This
     * array represents the path to the failing transaction. Indexes are zero based,
     * the first element indicates the top-level transaction, and successive elements
     * indicate deeper inner transactions.
     * @param failureMessage - If present, indicates that the transaction group failed and specifies why that
     * happened
     * @param unnamedResourcesAccessed - These are resources that were accessed by this group that would normally have
     * caused failure, but were allowed in simulation. Depending on where this object
     * is in the response, the unnamed resources it contains may or may not qualify for
     * group resource sharing. If this is a field in SimulateTransactionGroupResult,
     * the resources do qualify, but if this is a field in SimulateTransactionResult,
     * they do not qualify. In order to make this group valid for actual submission,
     * resources that qualify for group sharing can be made available by any
     * transaction of the group; otherwise, resources must be placed in the same
     * transaction which accessed them.
     */
    constructor({ txnResults, appBudgetAdded, appBudgetConsumed, failedAt, failureMessage, unnamedResourcesAccessed, }) {
        this.txnResults = txnResults;
        this.appBudgetAdded =
            typeof appBudgetAdded === 'undefined'
                ? undefined
                : (0, utils_js_1.ensureSafeInteger)(appBudgetAdded);
        this.appBudgetConsumed =
            typeof appBudgetConsumed === 'undefined'
                ? undefined
                : (0, utils_js_1.ensureSafeInteger)(appBudgetConsumed);
        this.failedAt =
            typeof failedAt === 'undefined'
                ? undefined
                : failedAt.map(utils_js_1.ensureSafeInteger);
        this.failureMessage = failureMessage;
        this.unnamedResourcesAccessed = unnamedResourcesAccessed;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return SimulateTransactionGroupResult.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['txn-results', this.txnResults.map((v) => v.toEncodingData())],
            ['app-budget-added', this.appBudgetAdded],
            ['app-budget-consumed', this.appBudgetConsumed],
            ['failed-at', this.failedAt],
            ['failure-message', this.failureMessage],
            [
                'unnamed-resources-accessed',
                typeof this.unnamedResourcesAccessed !== 'undefined'
                    ? this.unnamedResourcesAccessed.toEncodingData()
                    : undefined,
            ],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded SimulateTransactionGroupResult: ${data}`);
        }
        return new SimulateTransactionGroupResult({
            txnResults: (data.get('txn-results') ?? []).map((v) => SimulateTransactionResult.fromEncodingData(v)),
            appBudgetAdded: data.get('app-budget-added'),
            appBudgetConsumed: data.get('app-budget-consumed'),
            failedAt: data.get('failed-at'),
            failureMessage: data.get('failure-message'),
            unnamedResourcesAccessed: typeof data.get('unnamed-resources-accessed') !== 'undefined'
                ? SimulateUnnamedResourcesAccessed.fromEncodingData(data.get('unnamed-resources-accessed'))
                : undefined,
        });
    }
}
exports.SimulateTransactionGroupResult = SimulateTransactionGroupResult;
/**
 * Simulation result for an individual transaction
 */
class SimulateTransactionResult {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
                key: 'txn-result',
                valueSchema: PendingTransactionResponse.encodingSchema,
                omitEmpty: true,
            }, {
                key: 'app-budget-consumed',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()),
                omitEmpty: true,
            }, {
                key: 'exec-trace',
                valueSchema: new index_js_1.OptionalSchema(SimulationTransactionExecTrace.encodingSchema),
                omitEmpty: true,
            }, {
                key: 'fixed-signer',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.StringSchema()),
                omitEmpty: true,
            }, {
                key: 'logic-sig-budget-consumed',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()),
                omitEmpty: true,
            }, {
                key: 'unnamed-resources-accessed',
                valueSchema: new index_js_1.OptionalSchema(SimulateUnnamedResourcesAccessed.encodingSchema),
                omitEmpty: true,
            });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `SimulateTransactionResult` object.
     * @param txnResult - Details about a pending transaction. If the transaction was recently confirmed,
     * includes confirmation details like the round and reward details.
     * @param appBudgetConsumed - Budget used during execution of an app call transaction. This value includes
     * budged used by inner app calls spawned by this transaction.
     * @param execTrace - The execution trace of calling an app or a logic sig, containing the inner app
     * call trace in a recursive way.
     * @param fixedSigner - The account that needed to sign this transaction when no signature was provided
     * and the provided signer was incorrect.
     * @param logicSigBudgetConsumed - Budget used during execution of a logic sig transaction.
     * @param unnamedResourcesAccessed - These are resources that were accessed by this group that would normally have
     * caused failure, but were allowed in simulation. Depending on where this object
     * is in the response, the unnamed resources it contains may or may not qualify for
     * group resource sharing. If this is a field in SimulateTransactionGroupResult,
     * the resources do qualify, but if this is a field in SimulateTransactionResult,
     * they do not qualify. In order to make this group valid for actual submission,
     * resources that qualify for group sharing can be made available by any
     * transaction of the group; otherwise, resources must be placed in the same
     * transaction which accessed them.
     */
    constructor({ txnResult, appBudgetConsumed, execTrace, fixedSigner, logicSigBudgetConsumed, unnamedResourcesAccessed, }) {
        this.txnResult = txnResult;
        this.appBudgetConsumed =
            typeof appBudgetConsumed === 'undefined'
                ? undefined
                : (0, utils_js_1.ensureSafeInteger)(appBudgetConsumed);
        this.execTrace = execTrace;
        this.fixedSigner =
            typeof fixedSigner === 'string'
                ? address_js_1.Address.fromString(fixedSigner)
                : fixedSigner;
        this.logicSigBudgetConsumed =
            typeof logicSigBudgetConsumed === 'undefined'
                ? undefined
                : (0, utils_js_1.ensureSafeInteger)(logicSigBudgetConsumed);
        this.unnamedResourcesAccessed = unnamedResourcesAccessed;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return SimulateTransactionResult.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['txn-result', this.txnResult.toEncodingData()],
            ['app-budget-consumed', this.appBudgetConsumed],
            [
                'exec-trace',
                typeof this.execTrace !== 'undefined'
                    ? this.execTrace.toEncodingData()
                    : undefined,
            ],
            [
                'fixed-signer',
                typeof this.fixedSigner !== 'undefined'
                    ? this.fixedSigner.toString()
                    : undefined,
            ],
            ['logic-sig-budget-consumed', this.logicSigBudgetConsumed],
            [
                'unnamed-resources-accessed',
                typeof this.unnamedResourcesAccessed !== 'undefined'
                    ? this.unnamedResourcesAccessed.toEncodingData()
                    : undefined,
            ],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded SimulateTransactionResult: ${data}`);
        }
        return new SimulateTransactionResult({
            txnResult: PendingTransactionResponse.fromEncodingData(data.get('txn-result') ?? new Map()),
            appBudgetConsumed: data.get('app-budget-consumed'),
            execTrace: typeof data.get('exec-trace') !== 'undefined'
                ? SimulationTransactionExecTrace.fromEncodingData(data.get('exec-trace'))
                : undefined,
            fixedSigner: data.get('fixed-signer'),
            logicSigBudgetConsumed: data.get('logic-sig-budget-consumed'),
            unnamedResourcesAccessed: typeof data.get('unnamed-resources-accessed') !== 'undefined'
                ? SimulateUnnamedResourcesAccessed.fromEncodingData(data.get('unnamed-resources-accessed'))
                : undefined,
        });
    }
}
exports.SimulateTransactionResult = SimulateTransactionResult;
/**
 * These are resources that were accessed by this group that would normally have
 * caused failure, but were allowed in simulation. Depending on where this object
 * is in the response, the unnamed resources it contains may or may not qualify for
 * group resource sharing. If this is a field in SimulateTransactionGroupResult,
 * the resources do qualify, but if this is a field in SimulateTransactionResult,
 * they do not qualify. In order to make this group valid for actual submission,
 * resources that qualify for group sharing can be made available by any
 * transaction of the group; otherwise, resources must be placed in the same
 * transaction which accessed them.
 */
class SimulateUnnamedResourcesAccessed {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
                key: 'accounts',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.ArraySchema(new index_js_1.StringSchema())),
                omitEmpty: true,
            }, {
                key: 'app-locals',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.ArraySchema(ApplicationLocalReference.encodingSchema)),
                omitEmpty: true,
            }, {
                key: 'apps',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.ArraySchema(new index_js_1.Uint64Schema())),
                omitEmpty: true,
            }, {
                key: 'asset-holdings',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.ArraySchema(AssetHoldingReference.encodingSchema)),
                omitEmpty: true,
            }, {
                key: 'assets',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.ArraySchema(new index_js_1.Uint64Schema())),
                omitEmpty: true,
            }, {
                key: 'boxes',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.ArraySchema(BoxReference.encodingSchema)),
                omitEmpty: true,
            }, {
                key: 'extra-box-refs',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()),
                omitEmpty: true,
            });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `SimulateUnnamedResourcesAccessed` object.
     * @param accounts - The unnamed accounts that were referenced. The order of this array is arbitrary.
     * @param appLocals - The unnamed application local states that were referenced. The order of this
     * array is arbitrary.
     * @param apps - The unnamed applications that were referenced. The order of this array is
     * arbitrary.
     * @param assetHoldings - The unnamed asset holdings that were referenced. The order of this array is
     * arbitrary.
     * @param assets - The unnamed assets that were referenced. The order of this array is arbitrary.
     * @param boxes - The unnamed boxes that were referenced. The order of this array is arbitrary.
     * @param extraBoxRefs - The number of extra box references used to increase the IO budget. This is in
     * addition to the references defined in the input transaction group and any
     * referenced to unnamed boxes.
     */
    constructor({ accounts, appLocals, apps, assetHoldings, assets, boxes, extraBoxRefs, }) {
        this.accounts =
            typeof accounts !== 'undefined'
                ? accounts.map((addr) => typeof addr === 'string' ? address_js_1.Address.fromString(addr) : addr)
                : undefined;
        this.appLocals = appLocals;
        this.apps =
            typeof apps === 'undefined' ? undefined : apps.map(utils_js_1.ensureBigInt);
        this.assetHoldings = assetHoldings;
        this.assets =
            typeof assets === 'undefined' ? undefined : assets.map(utils_js_1.ensureBigInt);
        this.boxes = boxes;
        this.extraBoxRefs =
            typeof extraBoxRefs === 'undefined'
                ? undefined
                : (0, utils_js_1.ensureSafeInteger)(extraBoxRefs);
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return SimulateUnnamedResourcesAccessed.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            [
                'accounts',
                typeof this.accounts !== 'undefined'
                    ? this.accounts.map((v) => v.toString())
                    : undefined,
            ],
            [
                'app-locals',
                typeof this.appLocals !== 'undefined'
                    ? this.appLocals.map((v) => v.toEncodingData())
                    : undefined,
            ],
            ['apps', this.apps],
            [
                'asset-holdings',
                typeof this.assetHoldings !== 'undefined'
                    ? this.assetHoldings.map((v) => v.toEncodingData())
                    : undefined,
            ],
            ['assets', this.assets],
            [
                'boxes',
                typeof this.boxes !== 'undefined'
                    ? this.boxes.map((v) => v.toEncodingData())
                    : undefined,
            ],
            ['extra-box-refs', this.extraBoxRefs],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded SimulateUnnamedResourcesAccessed: ${data}`);
        }
        return new SimulateUnnamedResourcesAccessed({
            accounts: data.get('accounts'),
            appLocals: typeof data.get('app-locals') !== 'undefined'
                ? data
                    .get('app-locals')
                    .map((v) => ApplicationLocalReference.fromEncodingData(v))
                : undefined,
            apps: data.get('apps'),
            assetHoldings: typeof data.get('asset-holdings') !== 'undefined'
                ? data
                    .get('asset-holdings')
                    .map((v) => AssetHoldingReference.fromEncodingData(v))
                : undefined,
            assets: data.get('assets'),
            boxes: typeof data.get('boxes') !== 'undefined'
                ? data
                    .get('boxes')
                    .map((v) => BoxReference.fromEncodingData(v))
                : undefined,
            extraBoxRefs: data.get('extra-box-refs'),
        });
    }
}
exports.SimulateUnnamedResourcesAccessed = SimulateUnnamedResourcesAccessed;
/**
 * The set of parameters and limits override during simulation. If this set of
 * parameters is present, then evaluation parameters may differ from standard
 * evaluation in certain ways.
 */
class SimulationEvalOverrides {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
                key: 'allow-empty-signatures',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.BooleanSchema()),
                omitEmpty: true,
            }, {
                key: 'allow-unnamed-resources',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.BooleanSchema()),
                omitEmpty: true,
            }, {
                key: 'extra-opcode-budget',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()),
                omitEmpty: true,
            }, {
                key: 'fix-signers',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.BooleanSchema()),
                omitEmpty: true,
            }, {
                key: 'max-log-calls',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()),
                omitEmpty: true,
            }, {
                key: 'max-log-size',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()),
                omitEmpty: true,
            });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `SimulationEvalOverrides` object.
     * @param allowEmptySignatures - If true, transactions without signatures are allowed and simulated as if they
     * were properly signed.
     * @param allowUnnamedResources - If true, allows access to unnamed resources during simulation.
     * @param extraOpcodeBudget - The extra opcode budget added to each transaction group during simulation
     * @param fixSigners - If true, signers for transactions that are missing signatures will be fixed
     * during evaluation.
     * @param maxLogCalls - The maximum log calls one can make during simulation
     * @param maxLogSize - The maximum byte number to log during simulation
     */
    constructor({ allowEmptySignatures, allowUnnamedResources, extraOpcodeBudget, fixSigners, maxLogCalls, maxLogSize, }) {
        this.allowEmptySignatures = allowEmptySignatures;
        this.allowUnnamedResources = allowUnnamedResources;
        this.extraOpcodeBudget =
            typeof extraOpcodeBudget === 'undefined'
                ? undefined
                : (0, utils_js_1.ensureSafeInteger)(extraOpcodeBudget);
        this.fixSigners = fixSigners;
        this.maxLogCalls =
            typeof maxLogCalls === 'undefined'
                ? undefined
                : (0, utils_js_1.ensureSafeInteger)(maxLogCalls);
        this.maxLogSize =
            typeof maxLogSize === 'undefined'
                ? undefined
                : (0, utils_js_1.ensureSafeInteger)(maxLogSize);
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return SimulationEvalOverrides.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['allow-empty-signatures', this.allowEmptySignatures],
            ['allow-unnamed-resources', this.allowUnnamedResources],
            ['extra-opcode-budget', this.extraOpcodeBudget],
            ['fix-signers', this.fixSigners],
            ['max-log-calls', this.maxLogCalls],
            ['max-log-size', this.maxLogSize],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded SimulationEvalOverrides: ${data}`);
        }
        return new SimulationEvalOverrides({
            allowEmptySignatures: data.get('allow-empty-signatures'),
            allowUnnamedResources: data.get('allow-unnamed-resources'),
            extraOpcodeBudget: data.get('extra-opcode-budget'),
            fixSigners: data.get('fix-signers'),
            maxLogCalls: data.get('max-log-calls'),
            maxLogSize: data.get('max-log-size'),
        });
    }
}
exports.SimulationEvalOverrides = SimulationEvalOverrides;
/**
 * The set of trace information and effect from evaluating a single opcode.
 */
class SimulationOpcodeTraceUnit {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: 'pc', valueSchema: new index_js_1.Uint64Schema(), omitEmpty: true }, {
                key: 'scratch-changes',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.ArraySchema(ScratchChange.encodingSchema)),
                omitEmpty: true,
            }, {
                key: 'spawned-inners',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.ArraySchema(new index_js_1.Uint64Schema())),
                omitEmpty: true,
            }, {
                key: 'stack-additions',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.ArraySchema(AvmValue.encodingSchema)),
                omitEmpty: true,
            }, {
                key: 'stack-pop-count',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()),
                omitEmpty: true,
            }, {
                key: 'state-changes',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.ArraySchema(ApplicationStateOperation.encodingSchema)),
                omitEmpty: true,
            });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `SimulationOpcodeTraceUnit` object.
     * @param pc - The program counter of the current opcode being evaluated.
     * @param scratchChanges - The writes into scratch slots.
     * @param spawnedInners - The indexes of the traces for inner transactions spawned by this opcode, if any.
     * @param stackAdditions - The values added by this opcode to the stack.
     * @param stackPopCount - The number of deleted stack values by this opcode.
     * @param stateChanges - The operations against the current application's states.
     */
    constructor({ pc, scratchChanges, spawnedInners, stackAdditions, stackPopCount, stateChanges, }) {
        this.pc = (0, utils_js_1.ensureSafeInteger)(pc);
        this.scratchChanges = scratchChanges;
        this.spawnedInners =
            typeof spawnedInners === 'undefined'
                ? undefined
                : spawnedInners.map(utils_js_1.ensureSafeInteger);
        this.stackAdditions = stackAdditions;
        this.stackPopCount =
            typeof stackPopCount === 'undefined'
                ? undefined
                : (0, utils_js_1.ensureSafeInteger)(stackPopCount);
        this.stateChanges = stateChanges;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return SimulationOpcodeTraceUnit.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['pc', this.pc],
            [
                'scratch-changes',
                typeof this.scratchChanges !== 'undefined'
                    ? this.scratchChanges.map((v) => v.toEncodingData())
                    : undefined,
            ],
            ['spawned-inners', this.spawnedInners],
            [
                'stack-additions',
                typeof this.stackAdditions !== 'undefined'
                    ? this.stackAdditions.map((v) => v.toEncodingData())
                    : undefined,
            ],
            ['stack-pop-count', this.stackPopCount],
            [
                'state-changes',
                typeof this.stateChanges !== 'undefined'
                    ? this.stateChanges.map((v) => v.toEncodingData())
                    : undefined,
            ],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded SimulationOpcodeTraceUnit: ${data}`);
        }
        return new SimulationOpcodeTraceUnit({
            pc: data.get('pc'),
            scratchChanges: typeof data.get('scratch-changes') !== 'undefined'
                ? data
                    .get('scratch-changes')
                    .map((v) => ScratchChange.fromEncodingData(v))
                : undefined,
            spawnedInners: data.get('spawned-inners'),
            stackAdditions: typeof data.get('stack-additions') !== 'undefined'
                ? data
                    .get('stack-additions')
                    .map((v) => AvmValue.fromEncodingData(v))
                : undefined,
            stackPopCount: data.get('stack-pop-count'),
            stateChanges: typeof data.get('state-changes') !== 'undefined'
                ? data
                    .get('state-changes')
                    .map((v) => ApplicationStateOperation.fromEncodingData(v))
                : undefined,
        });
    }
}
exports.SimulationOpcodeTraceUnit = SimulationOpcodeTraceUnit;
/**
 * The execution trace of calling an app or a logic sig, containing the inner app
 * call trace in a recursive way.
 */
class SimulationTransactionExecTrace {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
                key: 'approval-program-hash',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.ByteArraySchema()),
                omitEmpty: true,
            }, {
                key: 'approval-program-trace',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.ArraySchema(SimulationOpcodeTraceUnit.encodingSchema)),
                omitEmpty: true,
            }, {
                key: 'clear-state-program-hash',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.ByteArraySchema()),
                omitEmpty: true,
            }, {
                key: 'clear-state-program-trace',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.ArraySchema(SimulationOpcodeTraceUnit.encodingSchema)),
                omitEmpty: true,
            }, {
                key: 'clear-state-rollback',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.BooleanSchema()),
                omitEmpty: true,
            }, {
                key: 'clear-state-rollback-error',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.StringSchema()),
                omitEmpty: true,
            }, {
                key: 'inner-trace',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.ArraySchema(SimulationTransactionExecTrace.encodingSchema)),
                omitEmpty: true,
            }, {
                key: 'logic-sig-hash',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.ByteArraySchema()),
                omitEmpty: true,
            }, {
                key: 'logic-sig-trace',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.ArraySchema(SimulationOpcodeTraceUnit.encodingSchema)),
                omitEmpty: true,
            });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `SimulationTransactionExecTrace` object.
     * @param approvalProgramHash - SHA512_256 hash digest of the approval program executed in transaction.
     * @param approvalProgramTrace - Program trace that contains a trace of opcode effects in an approval program.
     * @param clearStateProgramHash - SHA512_256 hash digest of the clear state program executed in transaction.
     * @param clearStateProgramTrace - Program trace that contains a trace of opcode effects in a clear state program.
     * @param clearStateRollback - If true, indicates that the clear state program failed and any persistent state
     * changes it produced should be reverted once the program exits.
     * @param clearStateRollbackError - The error message explaining why the clear state program failed. This field will
     * only be populated if clear-state-rollback is true and the failure was due to an
     * execution error.
     * @param innerTrace - An array of SimulationTransactionExecTrace representing the execution trace of
     * any inner transactions executed.
     * @param logicSigHash - SHA512_256 hash digest of the logic sig executed in transaction.
     * @param logicSigTrace - Program trace that contains a trace of opcode effects in a logic sig.
     */
    constructor({ approvalProgramHash, approvalProgramTrace, clearStateProgramHash, clearStateProgramTrace, clearStateRollback, clearStateRollbackError, innerTrace, logicSigHash, logicSigTrace, }) {
        this.approvalProgramHash =
            typeof approvalProgramHash === 'string'
                ? (0, binarydata_js_1.base64ToBytes)(approvalProgramHash)
                : approvalProgramHash;
        this.approvalProgramTrace = approvalProgramTrace;
        this.clearStateProgramHash =
            typeof clearStateProgramHash === 'string'
                ? (0, binarydata_js_1.base64ToBytes)(clearStateProgramHash)
                : clearStateProgramHash;
        this.clearStateProgramTrace = clearStateProgramTrace;
        this.clearStateRollback = clearStateRollback;
        this.clearStateRollbackError = clearStateRollbackError;
        this.innerTrace = innerTrace;
        this.logicSigHash =
            typeof logicSigHash === 'string'
                ? (0, binarydata_js_1.base64ToBytes)(logicSigHash)
                : logicSigHash;
        this.logicSigTrace = logicSigTrace;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return SimulationTransactionExecTrace.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['approval-program-hash', this.approvalProgramHash],
            [
                'approval-program-trace',
                typeof this.approvalProgramTrace !== 'undefined'
                    ? this.approvalProgramTrace.map((v) => v.toEncodingData())
                    : undefined,
            ],
            ['clear-state-program-hash', this.clearStateProgramHash],
            [
                'clear-state-program-trace',
                typeof this.clearStateProgramTrace !== 'undefined'
                    ? this.clearStateProgramTrace.map((v) => v.toEncodingData())
                    : undefined,
            ],
            ['clear-state-rollback', this.clearStateRollback],
            ['clear-state-rollback-error', this.clearStateRollbackError],
            [
                'inner-trace',
                typeof this.innerTrace !== 'undefined'
                    ? this.innerTrace.map((v) => v.toEncodingData())
                    : undefined,
            ],
            ['logic-sig-hash', this.logicSigHash],
            [
                'logic-sig-trace',
                typeof this.logicSigTrace !== 'undefined'
                    ? this.logicSigTrace.map((v) => v.toEncodingData())
                    : undefined,
            ],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded SimulationTransactionExecTrace: ${data}`);
        }
        return new SimulationTransactionExecTrace({
            approvalProgramHash: data.get('approval-program-hash'),
            approvalProgramTrace: typeof data.get('approval-program-trace') !== 'undefined'
                ? data
                    .get('approval-program-trace')
                    .map((v) => SimulationOpcodeTraceUnit.fromEncodingData(v))
                : undefined,
            clearStateProgramHash: data.get('clear-state-program-hash'),
            clearStateProgramTrace: typeof data.get('clear-state-program-trace') !== 'undefined'
                ? data
                    .get('clear-state-program-trace')
                    .map((v) => SimulationOpcodeTraceUnit.fromEncodingData(v))
                : undefined,
            clearStateRollback: data.get('clear-state-rollback'),
            clearStateRollbackError: data.get('clear-state-rollback-error'),
            innerTrace: typeof data.get('inner-trace') !== 'undefined'
                ? data
                    .get('inner-trace')
                    .map((v) => SimulationTransactionExecTrace.fromEncodingData(v))
                : undefined,
            logicSigHash: data.get('logic-sig-hash'),
            logicSigTrace: typeof data.get('logic-sig-trace') !== 'undefined'
                ? data
                    .get('logic-sig-trace')
                    .map((v) => SimulationOpcodeTraceUnit.fromEncodingData(v))
                : undefined,
        });
    }
}
exports.SimulationTransactionExecTrace = SimulationTransactionExecTrace;
/**
 * Represents a state proof and its corresponding message
 */
class StateProof {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
                key: 'Message',
                valueSchema: StateProofMessage.encodingSchema,
                omitEmpty: true,
            }, {
                key: 'StateProof',
                valueSchema: new index_js_1.ByteArraySchema(),
                omitEmpty: true,
            });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `StateProof` object.
     * @param message - Represents the message that the state proofs are attesting to.
     * @param stateproof - The encoded StateProof for the message.
     */
    constructor({ message, stateproof, }) {
        this.message = message;
        this.stateproof =
            typeof stateproof === 'string' ? (0, binarydata_js_1.base64ToBytes)(stateproof) : stateproof;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return StateProof.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['Message', this.message.toEncodingData()],
            ['StateProof', this.stateproof],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded StateProof: ${data}`);
        }
        return new StateProof({
            message: StateProofMessage.fromEncodingData(data.get('Message') ?? new Map()),
            stateproof: data.get('StateProof'),
        });
    }
}
exports.StateProof = StateProof;
/**
 * Represents the message that the state proofs are attesting to.
 */
class StateProofMessage {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
                key: 'BlockHeadersCommitment',
                valueSchema: new index_js_1.ByteArraySchema(),
                omitEmpty: true,
            }, {
                key: 'FirstAttestedRound',
                valueSchema: new index_js_1.Uint64Schema(),
                omitEmpty: true,
            }, {
                key: 'LastAttestedRound',
                valueSchema: new index_js_1.Uint64Schema(),
                omitEmpty: true,
            }, {
                key: 'LnProvenWeight',
                valueSchema: new index_js_1.Uint64Schema(),
                omitEmpty: true,
            }, {
                key: 'VotersCommitment',
                valueSchema: new index_js_1.ByteArraySchema(),
                omitEmpty: true,
            });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `StateProofMessage` object.
     * @param blockheaderscommitment - The vector commitment root on all light block headers within a state proof
     * interval.
     * @param firstattestedround - The first round the message attests to.
     * @param lastattestedround - The last round the message attests to.
     * @param lnprovenweight - An integer value representing the natural log of the proven weight with 16 bits
     * of precision. This value would be used to verify the next state proof.
     * @param voterscommitment - The vector commitment root of the top N accounts to sign the next StateProof.
     */
    constructor({ blockheaderscommitment, firstattestedround, lastattestedround, lnprovenweight, voterscommitment, }) {
        this.blockheaderscommitment =
            typeof blockheaderscommitment === 'string'
                ? (0, binarydata_js_1.base64ToBytes)(blockheaderscommitment)
                : blockheaderscommitment;
        this.firstattestedround = (0, utils_js_1.ensureBigInt)(firstattestedround);
        this.lastattestedround = (0, utils_js_1.ensureBigInt)(lastattestedround);
        this.lnprovenweight = (0, utils_js_1.ensureBigInt)(lnprovenweight);
        this.voterscommitment =
            typeof voterscommitment === 'string'
                ? (0, binarydata_js_1.base64ToBytes)(voterscommitment)
                : voterscommitment;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return StateProofMessage.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['BlockHeadersCommitment', this.blockheaderscommitment],
            ['FirstAttestedRound', this.firstattestedround],
            ['LastAttestedRound', this.lastattestedround],
            ['LnProvenWeight', this.lnprovenweight],
            ['VotersCommitment', this.voterscommitment],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded StateProofMessage: ${data}`);
        }
        return new StateProofMessage({
            blockheaderscommitment: data.get('BlockHeadersCommitment'),
            firstattestedround: data.get('FirstAttestedRound'),
            lastattestedround: data.get('LastAttestedRound'),
            lnprovenweight: data.get('LnProvenWeight'),
            voterscommitment: data.get('VotersCommitment'),
        });
    }
}
exports.StateProofMessage = StateProofMessage;
/**
 * Supply represents the current supply of MicroAlgos in the system.
 */
class SupplyResponse {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
                key: 'current_round',
                valueSchema: new index_js_1.Uint64Schema(),
                omitEmpty: true,
            }, {
                key: 'online-money',
                valueSchema: new index_js_1.Uint64Schema(),
                omitEmpty: true,
            }, { key: 'total-money', valueSchema: new index_js_1.Uint64Schema(), omitEmpty: true });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `SupplyResponse` object.
     * @param currentRound - Round
     * @param onlineMoney - OnlineMoney
     * @param totalMoney - TotalMoney
     */
    constructor({ currentRound, onlineMoney, totalMoney, }) {
        this.currentRound = (0, utils_js_1.ensureBigInt)(currentRound);
        this.onlineMoney = (0, utils_js_1.ensureBigInt)(onlineMoney);
        this.totalMoney = (0, utils_js_1.ensureBigInt)(totalMoney);
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return SupplyResponse.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['current_round', this.currentRound],
            ['online-money', this.onlineMoney],
            ['total-money', this.totalMoney],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded SupplyResponse: ${data}`);
        }
        return new SupplyResponse({
            currentRound: data.get('current_round'),
            onlineMoney: data.get('online-money'),
            totalMoney: data.get('total-money'),
        });
    }
}
exports.SupplyResponse = SupplyResponse;
/**
 * Represents a key-value pair in an application store.
 */
class TealKeyValue {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: 'key', valueSchema: new index_js_1.ByteArraySchema(), omitEmpty: true }, { key: 'value', valueSchema: TealValue.encodingSchema, omitEmpty: true });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `TealKeyValue` object.
     * @param key -
     * @param value - Represents a TEAL value.
     */
    constructor({ key, value }) {
        this.key = typeof key === 'string' ? (0, binarydata_js_1.base64ToBytes)(key) : key;
        this.value = value;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return TealKeyValue.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['key', this.key],
            ['value', this.value.toEncodingData()],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded TealKeyValue: ${data}`);
        }
        return new TealKeyValue({
            key: data.get('key'),
            value: TealValue.fromEncodingData(data.get('value') ?? new Map()),
        });
    }
}
exports.TealKeyValue = TealKeyValue;
/**
 * Represents a TEAL value.
 */
class TealValue {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: 'bytes', valueSchema: new index_js_1.ByteArraySchema(), omitEmpty: true }, { key: 'type', valueSchema: new index_js_1.Uint64Schema(), omitEmpty: true }, { key: 'uint', valueSchema: new index_js_1.Uint64Schema(), omitEmpty: true });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `TealValue` object.
     * @param bytes - (tb) bytes value.
     * @param type - (tt) value type. Value `1` refers to **bytes**, value `2` refers to **uint**
     * @param uint - (ui) uint value.
     */
    constructor({ bytes, type, uint, }) {
        this.bytes = typeof bytes === 'string' ? (0, binarydata_js_1.base64ToBytes)(bytes) : bytes;
        this.type = (0, utils_js_1.ensureSafeInteger)(type);
        this.uint = (0, utils_js_1.ensureBigInt)(uint);
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return TealValue.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['bytes', this.bytes],
            ['type', this.type],
            ['uint', this.uint],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded TealValue: ${data}`);
        }
        return new TealValue({
            bytes: data.get('bytes'),
            type: data.get('type'),
            uint: data.get('uint'),
        });
    }
}
exports.TealValue = TealValue;
/**
 * Response containing all ledger state deltas for transaction groups, with their
 * associated Ids, in a single round.
 */
class TransactionGroupLedgerStateDeltasForRoundResponse {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
                key: 'Deltas',
                valueSchema: new index_js_1.ArraySchema(LedgerStateDeltaForTransactionGroup.encodingSchema),
                omitEmpty: true,
            });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `TransactionGroupLedgerStateDeltasForRoundResponse` object.
     * @param deltas -
     */
    constructor({ deltas }) {
        this.deltas = deltas;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return TransactionGroupLedgerStateDeltasForRoundResponse.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['Deltas', this.deltas.map((v) => v.toEncodingData())],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded TransactionGroupLedgerStateDeltasForRoundResponse: ${data}`);
        }
        return new TransactionGroupLedgerStateDeltasForRoundResponse({
            deltas: (data.get('Deltas') ?? []).map((v) => LedgerStateDeltaForTransactionGroup.fromEncodingData(v)),
        });
    }
}
exports.TransactionGroupLedgerStateDeltasForRoundResponse = TransactionGroupLedgerStateDeltasForRoundResponse;
/**
 * TransactionParams contains the parameters that help a client construct a new
 * transaction.
 */
class TransactionParametersResponse {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
                key: 'consensus-version',
                valueSchema: new index_js_1.StringSchema(),
                omitEmpty: true,
            }, { key: 'fee', valueSchema: new index_js_1.Uint64Schema(), omitEmpty: true }, {
                key: 'genesis-hash',
                valueSchema: new index_js_1.ByteArraySchema(),
                omitEmpty: true,
            }, { key: 'genesis-id', valueSchema: new index_js_1.StringSchema(), omitEmpty: true }, { key: 'last-round', valueSchema: new index_js_1.Uint64Schema(), omitEmpty: true }, { key: 'min-fee', valueSchema: new index_js_1.Uint64Schema(), omitEmpty: true });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `TransactionParametersResponse` object.
     * @param consensusVersion - ConsensusVersion indicates the consensus protocol version
     * as of LastRound.
     * @param fee - Fee is the suggested transaction fee
     * Fee is in units of micro-Algos per byte.
     * Fee may fall to zero but transactions must still have a fee of
     * at least MinTxnFee for the current network protocol.
     * @param genesisHash - GenesisHash is the hash of the genesis block.
     * @param genesisId - GenesisID is an ID listed in the genesis block.
     * @param lastRound - LastRound indicates the last round seen
     * @param minFee - The minimum transaction fee (not per byte) required for the
     * txn to validate for the current network protocol.
     */
    constructor({ consensusVersion, fee, genesisHash, genesisId, lastRound, minFee, }) {
        this.consensusVersion = consensusVersion;
        this.fee = (0, utils_js_1.ensureBigInt)(fee);
        this.genesisHash =
            typeof genesisHash === 'string'
                ? (0, binarydata_js_1.base64ToBytes)(genesisHash)
                : genesisHash;
        this.genesisId = genesisId;
        this.lastRound = (0, utils_js_1.ensureBigInt)(lastRound);
        this.minFee = (0, utils_js_1.ensureBigInt)(minFee);
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return TransactionParametersResponse.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['consensus-version', this.consensusVersion],
            ['fee', this.fee],
            ['genesis-hash', this.genesisHash],
            ['genesis-id', this.genesisId],
            ['last-round', this.lastRound],
            ['min-fee', this.minFee],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded TransactionParametersResponse: ${data}`);
        }
        return new TransactionParametersResponse({
            consensusVersion: data.get('consensus-version'),
            fee: data.get('fee'),
            genesisHash: data.get('genesis-hash'),
            genesisId: data.get('genesis-id'),
            lastRound: data.get('last-round'),
            minFee: data.get('min-fee'),
        });
    }
}
exports.TransactionParametersResponse = TransactionParametersResponse;
/**
 * Proof of transaction in a block.
 */
class TransactionProof {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: 'idx', valueSchema: new index_js_1.Uint64Schema(), omitEmpty: true }, { key: 'proof', valueSchema: new index_js_1.ByteArraySchema(), omitEmpty: true }, {
                key: 'stibhash',
                valueSchema: new index_js_1.ByteArraySchema(),
                omitEmpty: true,
            }, { key: 'treedepth', valueSchema: new index_js_1.Uint64Schema(), omitEmpty: true }, {
                key: 'hashtype',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.StringSchema()),
                omitEmpty: true,
            });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `TransactionProof` object.
     * @param idx - Index of the transaction in the block's payset.
     * @param proof - Proof of transaction membership.
     * @param stibhash - Hash of SignedTxnInBlock for verifying proof.
     * @param treedepth - Represents the depth of the tree that is being proven, i.e. the number of edges
     * from a leaf to the root.
     * @param hashtype - The type of hash function used to create the proof, must be one of:
     * * sha512_256
     * * sha256
     */
    constructor({ idx, proof, stibhash, treedepth, hashtype, }) {
        this.idx = (0, utils_js_1.ensureSafeInteger)(idx);
        this.proof = typeof proof === 'string' ? (0, binarydata_js_1.base64ToBytes)(proof) : proof;
        this.stibhash =
            typeof stibhash === 'string' ? (0, binarydata_js_1.base64ToBytes)(stibhash) : stibhash;
        this.treedepth = (0, utils_js_1.ensureSafeInteger)(treedepth);
        this.hashtype = hashtype;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return TransactionProof.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['idx', this.idx],
            ['proof', this.proof],
            ['stibhash', this.stibhash],
            ['treedepth', this.treedepth],
            ['hashtype', this.hashtype],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded TransactionProof: ${data}`);
        }
        return new TransactionProof({
            idx: data.get('idx'),
            proof: data.get('proof'),
            stibhash: data.get('stibhash'),
            treedepth: data.get('treedepth'),
            hashtype: data.get('hashtype'),
        });
    }
}
exports.TransactionProof = TransactionProof;
/**
 * algod version information.
 */
class Version {
    static get encodingSchema() {
        if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new index_js_1.NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
                key: 'build',
                valueSchema: BuildVersion.encodingSchema,
                omitEmpty: true,
            }, {
                key: 'genesis_hash_b64',
                valueSchema: new index_js_1.ByteArraySchema(),
                omitEmpty: true,
            }, { key: 'genesis_id', valueSchema: new index_js_1.StringSchema(), omitEmpty: true }, {
                key: 'versions',
                valueSchema: new index_js_1.ArraySchema(new index_js_1.StringSchema()),
                omitEmpty: true,
            });
        }
        return this.encodingSchemaValue;
    }
    /**
     * Creates a new `Version` object.
     * @param build -
     * @param genesisHashB64 -
     * @param genesisId -
     * @param versions -
     */
    constructor({ build, genesisHashB64, genesisId, versions, }) {
        this.build = build;
        this.genesisHashB64 =
            typeof genesisHashB64 === 'string'
                ? (0, binarydata_js_1.base64ToBytes)(genesisHashB64)
                : genesisHashB64;
        this.genesisId = genesisId;
        this.versions = versions;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return Version.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['build', this.build.toEncodingData()],
            ['genesis_hash_b64', this.genesisHashB64],
            ['genesis_id', this.genesisId],
            ['versions', this.versions],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded Version: ${data}`);
        }
        return new Version({
            build: BuildVersion.fromEncodingData(data.get('build') ?? new Map()),
            genesisHashB64: data.get('genesis_hash_b64'),
            genesisId: data.get('genesis_id'),
            versions: data.get('versions'),
        });
    }
}
exports.Version = Version;
//# sourceMappingURL=types.js.map