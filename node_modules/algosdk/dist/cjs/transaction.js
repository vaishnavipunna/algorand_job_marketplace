"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeUnsignedTransaction = exports.encodeUnsignedTransaction = exports.Transaction = void 0;
const hi_base32_1 = __importDefault(require("hi-base32"));
const boxStorage_js_1 = require("./boxStorage.js");
const appAccess_js_1 = require("./appAccess.js");
const address_js_1 = require("./encoding/address.js");
const encoding = __importStar(require("./encoding/encoding.js"));
const index_js_1 = require("./encoding/schema/index.js");
const nacl = __importStar(require("./nacl/naclWrappers.js"));
const base_js_1 = require("./types/transactions/base.js");
const stateproof_js_1 = require("./stateproof.js");
const heartbeat_js_1 = require("./heartbeat.js");
const utils = __importStar(require("./utils/utils.js"));
const ALGORAND_TRANSACTION_LENGTH = 52;
const ALGORAND_TRANSACTION_LEASE_LENGTH = 32;
const NUM_ADDL_BYTES_AFTER_SIGNING = 75; // NUM_ADDL_BYTES_AFTER_SIGNING is the number of bytes added to a txn after signing it
const ASSET_METADATA_HASH_LENGTH = 32;
const KEYREG_VOTE_KEY_LENGTH = 32;
const KEYREG_SELECTION_KEY_LENGTH = 32;
const KEYREG_STATE_PROOF_KEY_LENGTH = 64;
const ALGORAND_TRANSACTION_GROUP_LENGTH = 32;
function uint8ArrayIsEmpty(input) {
    return input.every((value) => value === 0);
}
function getKeyregKey(input, inputName, length) {
    if (input == null) {
        return undefined;
    }
    let inputBytes;
    if (input instanceof Uint8Array) {
        inputBytes = input;
    }
    if (inputBytes == null || inputBytes.byteLength !== length) {
        throw Error(`${inputName} must be a ${length} byte Uint8Array`);
    }
    return inputBytes;
}
function ensureAddress(input) {
    if (input == null) {
        throw new Error('Address must not be null or undefined');
    }
    if (typeof input === 'string') {
        return address_js_1.Address.fromString(input);
    }
    if (input instanceof address_js_1.Address) {
        return input;
    }
    throw new Error(`Not an address: ${input}`);
}
function optionalAddress(input) {
    if (input == null) {
        return undefined;
    }
    let addr;
    if (input instanceof address_js_1.Address) {
        addr = input;
    }
    else if (typeof input === 'string') {
        addr = address_js_1.Address.fromString(input);
    }
    else {
        throw new Error(`Not an address: ${input}`);
    }
    if (uint8ArrayIsEmpty(addr.publicKey)) {
        // If it's the zero address, throw an error so that the user won't be surprised that this gets dropped
        throw new Error('Invalid use of the zero address. To omit this value, pass in undefined');
    }
    return addr;
}
function optionalUint8Array(input) {
    if (typeof input === 'undefined') {
        return undefined;
    }
    if (input instanceof Uint8Array) {
        return input;
    }
    throw new Error(`Not a Uint8Array: ${input}`);
}
function ensureUint8Array(input) {
    if (input instanceof Uint8Array) {
        return input;
    }
    throw new Error(`Not a Uint8Array: ${input}`);
}
function optionalUint64(input) {
    if (typeof input === 'undefined') {
        return undefined;
    }
    return utils.ensureUint64(input);
}
function ensureBoolean(input) {
    if (input === true || input === false) {
        return input;
    }
    throw new Error(`Not a boolean: ${input}`);
}
function ensureArray(input) {
    if (Array.isArray(input)) {
        return input.slice();
    }
    throw new Error(`Not an array: ${input}`);
}
function optionalFixedLengthByteArray(input, length, name) {
    const bytes = optionalUint8Array(input);
    if (typeof bytes === 'undefined') {
        return undefined;
    }
    if (bytes.byteLength !== length) {
        throw new Error(`${name} must be ${length} bytes long, was ${bytes.byteLength}`);
    }
    if (uint8ArrayIsEmpty(bytes)) {
        // if contains all 0s, omit it
        return undefined;
    }
    return bytes;
}
function ensureBoxReference(input) {
    if (input != null && typeof input === 'object') {
        const { appIndex, name } = input;
        return {
            appIndex: utils.ensureUint64(appIndex),
            name: ensureUint8Array(name),
        };
    }
    throw new Error(`Not a box reference: ${input}`);
}
function ensureHoldingReference(input) {
    if (input != null && typeof input === 'object') {
        const { assetIndex, address } = input;
        return {
            assetIndex: utils.ensureUint64(assetIndex),
            address: ensureAddress(address),
        };
    }
    throw new Error(`Not a holding reference: ${input}`);
}
function ensureLocalsReference(input) {
    if (input != null && typeof input === 'object') {
        const { appIndex, address } = input;
        return {
            appIndex: utils.ensureUint64(appIndex),
            address: ensureAddress(address),
        };
    }
    throw new Error(`Not a locals reference: ${input}`);
}
function ensureResourceReference(input) {
    if (input != null && typeof input === 'object') {
        const { address, appIndex, assetIndex, holding, locals, box } = input;
        if (address !== undefined) {
            return { address: ensureAddress(address) };
        }
        if (appIndex !== undefined) {
            return { appIndex: utils.ensureUint64(appIndex) };
        }
        if (assetIndex !== undefined) {
            return { assetIndex: utils.ensureUint64(assetIndex) };
        }
        if (holding !== undefined) {
            return { holding: ensureHoldingReference(holding) };
        }
        if (locals !== undefined) {
            return { locals: ensureLocalsReference(locals) };
        }
        if (box !== undefined) {
            return { box: ensureBoxReference(box) };
        }
    }
    throw new Error(`Not a resource reference: ${input}`);
}
const TX_TAG = new TextEncoder().encode('TX');
/**
 * Transaction enables construction of Algorand transactions
 * */
class Transaction {
    constructor(params) {
        if (!(0, base_js_1.isTransactionType)(params.type)) {
            throw new Error(`Invalid transaction type: ${params.type}`);
        }
        // Common fields
        this.type = params.type; // verified above
        this.sender = ensureAddress(params.sender);
        this.note = ensureUint8Array(params.note ?? new Uint8Array());
        this.lease = optionalFixedLengthByteArray(params.lease, ALGORAND_TRANSACTION_LEASE_LENGTH, 'lease');
        this.rekeyTo = optionalAddress(params.rekeyTo);
        // Group
        this.group = undefined;
        // Suggested params fields
        this.firstValid = utils.ensureUint64(params.suggestedParams.firstValid);
        this.lastValid = utils.ensureUint64(params.suggestedParams.lastValid);
        if (params.suggestedParams.genesisID) {
            if (typeof params.suggestedParams.genesisID !== 'string') {
                throw new Error('Genesis ID must be a string if present');
            }
            this.genesisID = params.suggestedParams.genesisID;
        }
        this.genesisHash = optionalUint8Array(params.suggestedParams.genesisHash);
        // Fee is handled at the end
        const fieldsPresent = [];
        if (params.paymentParams)
            fieldsPresent.push(base_js_1.TransactionType.pay);
        if (params.keyregParams)
            fieldsPresent.push(base_js_1.TransactionType.keyreg);
        if (params.assetConfigParams)
            fieldsPresent.push(base_js_1.TransactionType.acfg);
        if (params.assetTransferParams)
            fieldsPresent.push(base_js_1.TransactionType.axfer);
        if (params.assetFreezeParams)
            fieldsPresent.push(base_js_1.TransactionType.afrz);
        if (params.appCallParams)
            fieldsPresent.push(base_js_1.TransactionType.appl);
        if (params.stateProofParams)
            fieldsPresent.push(base_js_1.TransactionType.stpf);
        if (params.heartbeatParams)
            fieldsPresent.push(base_js_1.TransactionType.hb);
        if (fieldsPresent.length !== 1) {
            throw new Error(`Transaction has wrong number of type fields present (${fieldsPresent.length}): ${fieldsPresent}`);
        }
        if (this.type !== fieldsPresent[0]) {
            throw new Error(`Transaction has type ${this.type} but fields present for ${fieldsPresent[0]}`);
        }
        if (params.paymentParams) {
            this.payment = {
                receiver: ensureAddress(params.paymentParams.receiver),
                amount: utils.ensureUint64(params.paymentParams.amount),
                closeRemainderTo: optionalAddress(params.paymentParams.closeRemainderTo),
            };
        }
        if (params.keyregParams) {
            this.keyreg = {
                voteKey: getKeyregKey(params.keyregParams.voteKey, 'voteKey', KEYREG_VOTE_KEY_LENGTH),
                selectionKey: getKeyregKey(params.keyregParams.selectionKey, 'selectionKey', KEYREG_SELECTION_KEY_LENGTH),
                stateProofKey: getKeyregKey(params.keyregParams.stateProofKey, 'stateProofKey', KEYREG_STATE_PROOF_KEY_LENGTH),
                voteFirst: optionalUint64(params.keyregParams.voteFirst),
                voteLast: optionalUint64(params.keyregParams.voteLast),
                voteKeyDilution: optionalUint64(params.keyregParams.voteKeyDilution),
                nonParticipation: ensureBoolean(params.keyregParams.nonParticipation ?? false),
            };
            // Checking non-participation key registration
            if (this.keyreg.nonParticipation &&
                (this.keyreg.voteKey ||
                    this.keyreg.selectionKey ||
                    this.keyreg.stateProofKey ||
                    typeof this.keyreg.voteFirst !== 'undefined' ||
                    typeof this.keyreg.voteLast !== 'undefined' ||
                    typeof this.keyreg.voteKeyDilution !== 'undefined')) {
                throw new Error('nonParticipation is true but participation params are present.');
            }
            // Checking online key registration
            if (
            // If we are participating
            !this.keyreg.nonParticipation &&
                // And *ANY* participating fields are present
                (this.keyreg.voteKey ||
                    this.keyreg.selectionKey ||
                    this.keyreg.stateProofKey ||
                    typeof this.keyreg.voteFirst !== 'undefined' ||
                    typeof this.keyreg.voteLast !== 'undefined' ||
                    typeof this.keyreg.voteKeyDilution !== 'undefined') &&
                // Then *ALL* participating fields must be present (with an exception for stateProofKey,
                // which was introduced later so for backwards compatibility we don't require it)
                !(this.keyreg.voteKey &&
                    this.keyreg.selectionKey &&
                    typeof this.keyreg.voteFirst !== 'undefined' &&
                    typeof this.keyreg.voteLast !== 'undefined' &&
                    typeof this.keyreg.voteKeyDilution !== 'undefined')) {
                throw new Error(`Online key registration missing at least one of the following fields: voteKey, selectionKey, voteFirst, voteLast, voteKeyDilution`);
            }
            // The last option is an offline key registration where all the fields
            // nonParticipation, voteKey, selectionKey, stateProofKey, voteFirst, voteLast, voteKeyDilution
            // are all undefined
        }
        if (params.assetConfigParams) {
            this.assetConfig = {
                assetIndex: utils.ensureUint64(params.assetConfigParams.assetIndex ?? 0),
                total: utils.ensureUint64(params.assetConfigParams.total ?? 0),
                decimals: utils.ensureSafeUnsignedInteger(params.assetConfigParams.decimals ?? 0),
                defaultFrozen: ensureBoolean(params.assetConfigParams.defaultFrozen ?? false),
                manager: optionalAddress(params.assetConfigParams.manager),
                reserve: optionalAddress(params.assetConfigParams.reserve),
                freeze: optionalAddress(params.assetConfigParams.freeze),
                clawback: optionalAddress(params.assetConfigParams.clawback),
                unitName: params.assetConfigParams.unitName,
                assetName: params.assetConfigParams.assetName,
                assetURL: params.assetConfigParams.assetURL,
                assetMetadataHash: optionalFixedLengthByteArray(params.assetConfigParams.assetMetadataHash, ASSET_METADATA_HASH_LENGTH, 'assetMetadataHash'),
            };
        }
        if (params.assetTransferParams) {
            this.assetTransfer = {
                assetIndex: utils.ensureUint64(params.assetTransferParams.assetIndex),
                amount: utils.ensureUint64(params.assetTransferParams.amount),
                assetSender: optionalAddress(params.assetTransferParams.assetSender),
                receiver: ensureAddress(params.assetTransferParams.receiver),
                closeRemainderTo: optionalAddress(params.assetTransferParams.closeRemainderTo),
            };
        }
        if (params.assetFreezeParams) {
            this.assetFreeze = {
                assetIndex: utils.ensureUint64(params.assetFreezeParams.assetIndex),
                freezeAccount: ensureAddress(params.assetFreezeParams.freezeTarget),
                frozen: ensureBoolean(params.assetFreezeParams.frozen),
            };
        }
        if (params.appCallParams) {
            const { onComplete } = params.appCallParams;
            if (!(0, base_js_1.isOnApplicationComplete)(onComplete)) {
                throw new Error(`Invalid onCompletion value: ${onComplete}`);
            }
            this.applicationCall = {
                appIndex: utils.ensureUint64(params.appCallParams.appIndex),
                onComplete,
                numLocalInts: utils.ensureSafeUnsignedInteger(params.appCallParams.numLocalInts ?? 0),
                numLocalByteSlices: utils.ensureSafeUnsignedInteger(params.appCallParams.numLocalByteSlices ?? 0),
                numGlobalInts: utils.ensureSafeUnsignedInteger(params.appCallParams.numGlobalInts ?? 0),
                numGlobalByteSlices: utils.ensureSafeUnsignedInteger(params.appCallParams.numGlobalByteSlices ?? 0),
                extraPages: utils.ensureSafeUnsignedInteger(params.appCallParams.extraPages ?? 0),
                approvalProgram: ensureUint8Array(params.appCallParams.approvalProgram ?? new Uint8Array()),
                clearProgram: ensureUint8Array(params.appCallParams.clearProgram ?? new Uint8Array()),
                appArgs: ensureArray(params.appCallParams.appArgs ?? []).map(ensureUint8Array),
                accounts: ensureArray(params.appCallParams.accounts ?? []).map(ensureAddress),
                foreignApps: ensureArray(params.appCallParams.foreignApps ?? []).map(utils.ensureUint64),
                foreignAssets: ensureArray(params.appCallParams.foreignAssets ?? []).map(utils.ensureUint64),
                boxes: ensureArray(params.appCallParams.boxes ?? []).map(ensureBoxReference),
                access: ensureArray(params.appCallParams.access ?? []).map(ensureResourceReference),
                rejectVersion: utils.ensureSafeUnsignedInteger(params.appCallParams.rejectVersion ?? 0),
            };
        }
        if (params.stateProofParams) {
            this.stateProof = {
                stateProofType: utils.ensureSafeUnsignedInteger(params.stateProofParams.stateProofType ?? 0),
                stateProof: params.stateProofParams.stateProof,
                message: params.stateProofParams.message,
            };
        }
        if (params.heartbeatParams) {
            this.heartbeat = new heartbeat_js_1.Heartbeat({
                address: params.heartbeatParams.address,
                proof: params.heartbeatParams.proof,
                seed: params.heartbeatParams.seed,
                voteID: params.heartbeatParams.voteID,
                keyDilution: params.heartbeatParams.keyDilution,
            });
        }
        // Determine fee
        this.fee = utils.ensureUint64(params.suggestedParams.fee);
        const feeDependsOnSize = !ensureBoolean(params.suggestedParams.flatFee ?? false);
        if (feeDependsOnSize) {
            const minFee = utils.ensureUint64(params.suggestedParams.minFee);
            this.fee *= BigInt(this.estimateSize());
            // If suggested fee too small and will be rejected, set to min tx fee
            if (this.fee < minFee) {
                this.fee = minFee;
            }
        }
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return Transaction.encodingSchema;
    }
    toEncodingData() {
        const data = new Map([
            ['type', this.type],
            ['fv', this.firstValid],
            ['lv', this.lastValid],
            ['snd', this.sender],
            ['gen', this.genesisID],
            ['gh', this.genesisHash],
            ['fee', this.fee],
            ['note', this.note],
            ['lx', this.lease],
            ['rekey', this.rekeyTo],
            ['grp', this.group],
        ]);
        if (this.payment) {
            data.set('amt', this.payment.amount);
            data.set('rcv', this.payment.receiver);
            data.set('close', this.payment.closeRemainderTo);
            return data;
        }
        if (this.keyreg) {
            data.set('votekey', this.keyreg.voteKey);
            data.set('selkey', this.keyreg.selectionKey);
            data.set('sprfkey', this.keyreg.stateProofKey);
            data.set('votefst', this.keyreg.voteFirst);
            data.set('votelst', this.keyreg.voteLast);
            data.set('votekd', this.keyreg.voteKeyDilution);
            data.set('nonpart', this.keyreg.nonParticipation);
            return data;
        }
        if (this.assetConfig) {
            data.set('caid', this.assetConfig.assetIndex);
            const assetParams = new Map([
                ['t', this.assetConfig.total],
                ['dc', this.assetConfig.decimals],
                ['df', this.assetConfig.defaultFrozen],
                ['m', this.assetConfig.manager],
                ['r', this.assetConfig.reserve],
                ['f', this.assetConfig.freeze],
                ['c', this.assetConfig.clawback],
                ['un', this.assetConfig.unitName],
                ['an', this.assetConfig.assetName],
                ['au', this.assetConfig.assetURL],
                ['am', this.assetConfig.assetMetadataHash],
            ]);
            data.set('apar', assetParams);
            return data;
        }
        if (this.assetTransfer) {
            data.set('xaid', this.assetTransfer.assetIndex);
            data.set('aamt', this.assetTransfer.amount);
            data.set('arcv', this.assetTransfer.receiver);
            data.set('aclose', this.assetTransfer.closeRemainderTo);
            data.set('asnd', this.assetTransfer.assetSender);
            return data;
        }
        if (this.assetFreeze) {
            data.set('faid', this.assetFreeze.assetIndex);
            data.set('afrz', this.assetFreeze.frozen);
            data.set('fadd', this.assetFreeze.freezeAccount);
            return data;
        }
        if (this.applicationCall) {
            data.set('apid', this.applicationCall.appIndex);
            data.set('apan', this.applicationCall.onComplete);
            data.set('apaa', this.applicationCall.appArgs);
            data.set('apat', this.applicationCall.accounts);
            data.set('apas', this.applicationCall.foreignAssets);
            data.set('apfa', this.applicationCall.foreignApps);
            data.set('apbx', (0, boxStorage_js_1.boxReferencesToEncodingData)(this.applicationCall.boxes, this.applicationCall.foreignApps, this.applicationCall.appIndex));
            data.set('al', (0, appAccess_js_1.resourceReferencesToEncodingData)(this.applicationCall.appIndex, this.applicationCall.access));
            data.set('apap', this.applicationCall.approvalProgram);
            data.set('apsu', this.applicationCall.clearProgram);
            data.set('apls', new Map([
                ['nui', this.applicationCall.numLocalInts],
                ['nbs', this.applicationCall.numLocalByteSlices],
            ]));
            data.set('apgs', new Map([
                ['nui', this.applicationCall.numGlobalInts],
                ['nbs', this.applicationCall.numGlobalByteSlices],
            ]));
            data.set('apep', this.applicationCall.extraPages);
            data.set('aprv', this.applicationCall.rejectVersion);
            return data;
        }
        if (this.stateProof) {
            data.set('sptype', this.stateProof.stateProofType);
            data.set('sp', this.stateProof.stateProof
                ? this.stateProof.stateProof.toEncodingData()
                : undefined);
            data.set('spmsg', this.stateProof.message
                ? this.stateProof.message.toEncodingData()
                : undefined);
            return data;
        }
        if (this.heartbeat) {
            const heartbeat = new heartbeat_js_1.Heartbeat({
                address: this.heartbeat.address,
                proof: this.heartbeat.proof,
                seed: this.heartbeat.seed,
                voteID: this.heartbeat.voteID,
                keyDilution: this.heartbeat.keyDilution,
            });
            data.set('hb', heartbeat.toEncodingData());
            return data;
        }
        throw new Error(`Unexpected transaction type: ${this.type}`);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded logic sig account: ${data}`);
        }
        const suggestedParams = {
            minFee: BigInt(0),
            flatFee: true,
            fee: data.get('fee') ?? 0,
            firstValid: data.get('fv') ?? 0,
            lastValid: data.get('lv') ?? 0,
            genesisHash: data.get('gh'),
            genesisID: data.get('gen'),
        };
        const txnType = data.get('type');
        if (!(0, base_js_1.isTransactionType)(txnType)) {
            throw new Error(`Unrecognized transaction type: ${txnType}`);
        }
        const params = {
            type: txnType,
            sender: data.get('snd') ?? address_js_1.Address.zeroAddress(),
            note: data.get('note'),
            lease: data.get('lx'),
            suggestedParams,
        };
        if (data.get('rekey')) {
            params.rekeyTo = data.get('rekey');
        }
        if (params.type === base_js_1.TransactionType.pay) {
            const paymentParams = {
                amount: data.get('amt') ?? 0,
                receiver: data.get('rcv') ?? address_js_1.Address.zeroAddress(),
            };
            if (data.get('close')) {
                paymentParams.closeRemainderTo = data.get('close');
            }
            params.paymentParams = paymentParams;
        }
        else if (params.type === base_js_1.TransactionType.keyreg) {
            const keyregParams = {
                voteKey: data.get('votekey'),
                selectionKey: data.get('selkey'),
                stateProofKey: data.get('sprfkey'),
                voteFirst: data.get('votefst'),
                voteLast: data.get('votelst'),
                voteKeyDilution: data.get('votekd'),
                nonParticipation: data.get('nonpart'),
            };
            params.keyregParams = keyregParams;
        }
        else if (params.type === base_js_1.TransactionType.acfg) {
            const assetConfigParams = {
                assetIndex: data.get('caid'),
            };
            if (data.get('apar')) {
                const assetParams = data.get('apar');
                assetConfigParams.total = assetParams.get('t');
                assetConfigParams.decimals = assetParams.get('dc');
                assetConfigParams.defaultFrozen = assetParams.get('df');
                assetConfigParams.unitName = assetParams.get('un');
                assetConfigParams.assetName = assetParams.get('an');
                assetConfigParams.assetURL = assetParams.get('au');
                assetConfigParams.assetMetadataHash = assetParams.get('am');
                if (assetParams.get('m')) {
                    assetConfigParams.manager = assetParams.get('m');
                }
                if (assetParams.get('r')) {
                    assetConfigParams.reserve = assetParams.get('r');
                }
                if (assetParams.get('f')) {
                    assetConfigParams.freeze = assetParams.get('f');
                }
                if (assetParams.get('c')) {
                    assetConfigParams.clawback = assetParams.get('c');
                }
            }
            params.assetConfigParams = assetConfigParams;
        }
        else if (params.type === base_js_1.TransactionType.axfer) {
            const assetTransferParams = {
                assetIndex: data.get('xaid') ?? 0,
                amount: data.get('aamt') ?? 0,
                receiver: data.get('arcv') ?? address_js_1.Address.zeroAddress(),
            };
            if (data.get('aclose')) {
                assetTransferParams.closeRemainderTo = data.get('aclose');
            }
            if (data.get('asnd')) {
                assetTransferParams.assetSender = data.get('asnd');
            }
            params.assetTransferParams = assetTransferParams;
        }
        else if (params.type === base_js_1.TransactionType.afrz) {
            const assetFreezeParams = {
                assetIndex: data.get('faid') ?? 0,
                freezeTarget: data.get('fadd') ?? address_js_1.Address.zeroAddress(),
                frozen: data.get('afrz') ?? false,
            };
            params.assetFreezeParams = assetFreezeParams;
        }
        else if (params.type === base_js_1.TransactionType.appl) {
            const appCallParams = {
                appIndex: data.get('apid') ?? 0,
                onComplete: utils.ensureSafeUnsignedInteger(data.get('apan') ?? 0),
                appArgs: data.get('apaa'),
                accounts: data.get('apat'),
                foreignAssets: data.get('apas'),
                foreignApps: data.get('apfa'),
                approvalProgram: data.get('apap'),
                clearProgram: data.get('apsu'),
                extraPages: data.get('apep'),
                rejectVersion: data.get('aprv') ?? 0,
            };
            const localSchema = data.get('apls');
            if (localSchema) {
                appCallParams.numLocalInts = localSchema.get('nui');
                appCallParams.numLocalByteSlices = localSchema.get('nbs');
            }
            const globalSchema = data.get('apgs');
            if (globalSchema) {
                appCallParams.numGlobalInts = globalSchema.get('nui');
                appCallParams.numGlobalByteSlices = globalSchema.get('nbs');
            }
            const boxes = data.get('apbx');
            if (boxes) {
                appCallParams.boxes = boxes.map((box) => {
                    const index = utils.ensureSafeUnsignedInteger(box.get('i') ?? 0);
                    const name = ensureUint8Array(box.get('n') ?? new Uint8Array());
                    if (index === 0) {
                        // We return 0 for the app ID so that it's guaranteed translateBoxReferences will
                        // translate the app index back to 0. If we instead returned the called app ID,
                        // translateBoxReferences would translate the app index to a nonzero value if the called
                        // app is also in the foreign app array.
                        return {
                            appIndex: 0,
                            name,
                        };
                    }
                    if (!appCallParams.foreignApps ||
                        index > appCallParams.foreignApps.length) {
                        throw new Error(`Cannot find foreign app index ${index} in ${appCallParams.foreignApps}`);
                    }
                    return {
                        appIndex: appCallParams.foreignApps[index - 1],
                        name,
                    };
                });
            }
            const references = data.get('al');
            if (references) {
                appCallParams.access = (0, appAccess_js_1.convertIndicesToResourceReferences)(references);
            }
            params.appCallParams = appCallParams;
        }
        else if (params.type === base_js_1.TransactionType.stpf) {
            const stateProofParams = {
                stateProofType: data.get('sptype'),
                stateProof: data.get('sp')
                    ? stateproof_js_1.StateProof.fromEncodingData(data.get('sp'))
                    : undefined,
                message: data.get('spmsg')
                    ? stateproof_js_1.StateProofMessage.fromEncodingData(data.get('spmsg'))
                    : undefined,
            };
            params.stateProofParams = stateProofParams;
        }
        else if (params.type === base_js_1.TransactionType.hb) {
            const heartbeat = heartbeat_js_1.Heartbeat.fromEncodingData(data.get('hb'));
            const heartbeatParams = {
                address: heartbeat.address,
                proof: heartbeat.proof,
                seed: heartbeat.seed,
                voteID: heartbeat.voteID,
                keyDilution: heartbeat.keyDilution,
            };
            params.heartbeatParams = heartbeatParams;
        }
        else {
            const exhaustiveCheck = params.type;
            throw new Error(`Unexpected transaction type: ${exhaustiveCheck}`);
        }
        const txn = new Transaction(params);
        if (data.get('grp')) {
            const group = ensureUint8Array(data.get('grp'));
            if (group.byteLength !== ALGORAND_TRANSACTION_GROUP_LENGTH) {
                throw new Error(`Invalid group length: ${group.byteLength}`);
            }
            txn.group = group;
        }
        return txn;
    }
    estimateSize() {
        return this.toByte().length + NUM_ADDL_BYTES_AFTER_SIGNING;
    }
    bytesToSign() {
        const encodedMsg = this.toByte();
        return utils.concatArrays(TX_TAG, encodedMsg);
    }
    toByte() {
        return encoding.encodeMsgpack(this);
    }
    // returns the raw signature
    rawSignTxn(sk) {
        const toBeSigned = this.bytesToSign();
        const sig = nacl.sign(toBeSigned, sk);
        return sig;
    }
    signTxn(sk) {
        // TODO: deprecate in favor of SignedTransaction class
        const keypair = nacl.keyPairFromSecretKey(sk);
        const signerAddr = new address_js_1.Address(keypair.publicKey);
        const sig = this.rawSignTxn(sk);
        return this.attachSignature(signerAddr, sig);
    }
    attachSignature(signerAddr, signature) {
        // TODO: deprecate in favor of SignedTransaction class
        if (!nacl.isValidSignatureLength(signature.length)) {
            throw new Error('Invalid signature length');
        }
        const sTxn = new Map([
            ['sig', signature],
            ['txn', this.toEncodingData()],
        ]);
        const signerAddrObj = ensureAddress(signerAddr);
        // add AuthAddr if signing with a different key than From indicates
        if (!this.sender.equals(signerAddrObj)) {
            sTxn.set('sgnr', signerAddrObj);
        }
        // This is a hack to avoid a circular reference with the SignedTransaction class
        const stxnSchema = new index_js_1.NamedMapSchema((0, index_js_1.allOmitEmpty)([
            {
                key: 'txn',
                valueSchema: Transaction.encodingSchema,
            },
            {
                key: 'sig',
                valueSchema: new index_js_1.FixedLengthByteArraySchema(64),
            },
            {
                key: 'sgnr',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.AddressSchema()),
            },
        ]));
        return encoding.msgpackRawEncode(stxnSchema.prepareMsgpack(sTxn));
    }
    rawTxID() {
        const enMsg = this.toByte();
        const gh = utils.concatArrays(TX_TAG, enMsg);
        return Uint8Array.from(nacl.genericHash(gh));
    }
    txID() {
        const hash = this.rawTxID();
        return hi_base32_1.default.encode(hash).slice(0, ALGORAND_TRANSACTION_LENGTH);
    }
}
exports.Transaction = Transaction;
Transaction.encodingSchema = new index_js_1.NamedMapSchema((0, index_js_1.allOmitEmpty)([
    // Common
    { key: 'type', valueSchema: new index_js_1.StringSchema() },
    { key: 'snd', valueSchema: new index_js_1.AddressSchema() },
    { key: 'lv', valueSchema: new index_js_1.Uint64Schema() },
    { key: 'gen', valueSchema: new index_js_1.OptionalSchema(new index_js_1.StringSchema()) },
    {
        key: 'gh',
        valueSchema: new index_js_1.OptionalSchema(new index_js_1.FixedLengthByteArraySchema(32)),
    },
    { key: 'fee', valueSchema: new index_js_1.Uint64Schema() },
    { key: 'fv', valueSchema: new index_js_1.Uint64Schema() },
    { key: 'note', valueSchema: new index_js_1.ByteArraySchema() },
    {
        key: 'lx',
        valueSchema: new index_js_1.OptionalSchema(new index_js_1.FixedLengthByteArraySchema(32)),
    },
    { key: 'rekey', valueSchema: new index_js_1.OptionalSchema(new index_js_1.AddressSchema()) },
    {
        key: 'grp',
        valueSchema: new index_js_1.OptionalSchema(new index_js_1.FixedLengthByteArraySchema(32)),
    },
    // We mark all top-level type-specific fields optional because they will not be present when
    // the transaction is not that type.
    // Payment
    { key: 'amt', valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()) },
    { key: 'rcv', valueSchema: new index_js_1.OptionalSchema(new index_js_1.AddressSchema()) },
    { key: 'close', valueSchema: new index_js_1.OptionalSchema(new index_js_1.AddressSchema()) },
    // Keyreg
    {
        key: 'votekey',
        valueSchema: new index_js_1.OptionalSchema(new index_js_1.FixedLengthByteArraySchema(32)),
    },
    {
        key: 'selkey',
        valueSchema: new index_js_1.OptionalSchema(new index_js_1.FixedLengthByteArraySchema(32)),
    },
    {
        key: 'sprfkey',
        valueSchema: new index_js_1.OptionalSchema(new index_js_1.FixedLengthByteArraySchema(64)),
    },
    { key: 'votefst', valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()) },
    { key: 'votelst', valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()) },
    { key: 'votekd', valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()) },
    { key: 'nonpart', valueSchema: new index_js_1.OptionalSchema(new index_js_1.BooleanSchema()) },
    // AssetConfig
    { key: 'caid', valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()) },
    {
        key: 'apar',
        valueSchema: new index_js_1.OptionalSchema(new index_js_1.NamedMapSchema((0, index_js_1.allOmitEmpty)([
            { key: 't', valueSchema: new index_js_1.Uint64Schema() },
            { key: 'dc', valueSchema: new index_js_1.Uint64Schema() },
            { key: 'df', valueSchema: new index_js_1.BooleanSchema() },
            {
                key: 'm',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.AddressSchema()),
            },
            {
                key: 'r',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.AddressSchema()),
            },
            {
                key: 'f',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.AddressSchema()),
            },
            {
                key: 'c',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.AddressSchema()),
            },
            {
                key: 'un',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.StringSchema()),
            },
            {
                key: 'an',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.StringSchema()),
            },
            {
                key: 'au',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.StringSchema()),
            },
            {
                key: 'am',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.FixedLengthByteArraySchema(32)),
            },
        ]))),
    },
    // AssetTransfer
    { key: 'xaid', valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()) },
    { key: 'aamt', valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()) },
    { key: 'arcv', valueSchema: new index_js_1.OptionalSchema(new index_js_1.AddressSchema()) },
    { key: 'aclose', valueSchema: new index_js_1.OptionalSchema(new index_js_1.AddressSchema()) },
    { key: 'asnd', valueSchema: new index_js_1.OptionalSchema(new index_js_1.AddressSchema()) },
    // AssetFreeze
    { key: 'faid', valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()) },
    { key: 'afrz', valueSchema: new index_js_1.OptionalSchema(new index_js_1.BooleanSchema()) },
    { key: 'fadd', valueSchema: new index_js_1.OptionalSchema(new index_js_1.AddressSchema()) },
    // Application
    { key: 'apid', valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()) },
    { key: 'apan', valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()) },
    {
        key: 'apaa',
        valueSchema: new index_js_1.OptionalSchema(new index_js_1.ArraySchema(new index_js_1.ByteArraySchema())),
    },
    {
        key: 'apat',
        valueSchema: new index_js_1.OptionalSchema(new index_js_1.ArraySchema(new index_js_1.AddressSchema())),
    },
    {
        key: 'apas',
        valueSchema: new index_js_1.OptionalSchema(new index_js_1.ArraySchema(new index_js_1.Uint64Schema())),
    },
    {
        key: 'apfa',
        valueSchema: new index_js_1.OptionalSchema(new index_js_1.ArraySchema(new index_js_1.Uint64Schema())),
    },
    {
        key: 'apbx',
        valueSchema: new index_js_1.OptionalSchema(new index_js_1.ArraySchema(new index_js_1.NamedMapSchema((0, index_js_1.allOmitEmpty)([
            {
                key: 'i',
                valueSchema: new index_js_1.Uint64Schema(),
            },
            {
                key: 'n',
                valueSchema: new index_js_1.ByteArraySchema(),
            },
        ])))),
    },
    {
        key: 'al',
        valueSchema: new index_js_1.OptionalSchema(new index_js_1.ArraySchema(new index_js_1.NamedMapSchema((0, index_js_1.allOmitEmpty)([
            {
                key: 'd',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.AddressSchema()),
            },
            {
                key: 's',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()),
            },
            {
                key: 'p',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()),
            },
            {
                key: 'h',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.NamedMapSchema((0, index_js_1.allOmitEmpty)([
                    {
                        key: 'd',
                        valueSchema: new index_js_1.Uint64Schema(),
                    },
                    {
                        key: 's',
                        valueSchema: new index_js_1.Uint64Schema(),
                    },
                ]))),
            },
            {
                key: 'l',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.NamedMapSchema((0, index_js_1.allOmitEmpty)([
                    {
                        key: 'd',
                        valueSchema: new index_js_1.Uint64Schema(),
                    },
                    {
                        key: 'p',
                        valueSchema: new index_js_1.Uint64Schema(),
                    },
                ]))),
            },
            {
                key: 'b',
                valueSchema: new index_js_1.OptionalSchema(new index_js_1.NamedMapSchema((0, index_js_1.allOmitEmpty)([
                    {
                        key: 'i',
                        valueSchema: new index_js_1.Uint64Schema(),
                    },
                    {
                        key: 'n',
                        valueSchema: new index_js_1.ByteArraySchema(),
                    },
                ]))),
            },
        ])))),
    },
    { key: 'apap', valueSchema: new index_js_1.OptionalSchema(new index_js_1.ByteArraySchema()) },
    { key: 'apsu', valueSchema: new index_js_1.OptionalSchema(new index_js_1.ByteArraySchema()) },
    {
        key: 'apls',
        valueSchema: new index_js_1.OptionalSchema(new index_js_1.NamedMapSchema((0, index_js_1.allOmitEmpty)([
            {
                key: 'nui',
                valueSchema: new index_js_1.Uint64Schema(),
            },
            {
                key: 'nbs',
                valueSchema: new index_js_1.Uint64Schema(),
            },
        ]))),
    },
    {
        key: 'apgs',
        valueSchema: new index_js_1.OptionalSchema(new index_js_1.NamedMapSchema((0, index_js_1.allOmitEmpty)([
            {
                key: 'nui',
                valueSchema: new index_js_1.Uint64Schema(),
            },
            {
                key: 'nbs',
                valueSchema: new index_js_1.Uint64Schema(),
            },
        ]))),
    },
    { key: 'apep', valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()) },
    { key: 'aprv', valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()) },
    // StateProof
    { key: 'sptype', valueSchema: new index_js_1.OptionalSchema(new index_js_1.Uint64Schema()) },
    { key: 'sp', valueSchema: new index_js_1.OptionalSchema(stateproof_js_1.StateProof.encodingSchema) },
    {
        key: 'spmsg',
        valueSchema: new index_js_1.OptionalSchema(stateproof_js_1.StateProofMessage.encodingSchema),
    },
    // Heartbeat
    { key: 'hb', valueSchema: new index_js_1.OptionalSchema(heartbeat_js_1.Heartbeat.encodingSchema) },
]));
/**
 * encodeUnsignedTransaction takes a completed txnBuilder.Transaction object, such as from the makeFoo
 * family of transactions, and converts it to a Buffer
 * @param transactionObject - the completed Transaction object
 */
function encodeUnsignedTransaction(transactionObject) {
    return encoding.encodeMsgpack(transactionObject);
}
exports.encodeUnsignedTransaction = encodeUnsignedTransaction;
/**
 * decodeUnsignedTransaction takes a Uint8Array (as if from encodeUnsignedTransaction) and converts it to a txnBuilder.Transaction object
 * @param transactionBuffer - the Uint8Array containing a transaction
 */
function decodeUnsignedTransaction(transactionBuffer) {
    return encoding.decodeMsgpack(transactionBuffer, Transaction);
}
exports.decodeUnsignedTransaction = decodeUnsignedTransaction;
//# sourceMappingURL=transaction.js.map