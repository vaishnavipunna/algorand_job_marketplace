"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.appendSignRawMultisigSignature = exports.appendSignMultisigTransaction = exports.signMultisigTransaction = exports.mergeMultisigTransactions = exports.createMultisigTransaction = exports.MULTISIG_SIGNATURE_LENGTH_ERROR_MSG = exports.MULTISIG_USE_PARTIAL_SIGN_ERROR_MSG = exports.MULTISIG_NO_MUTATE_ERROR_MSG = exports.MULTISIG_MERGE_SIG_MISMATCH_ERROR_MSG = exports.MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG = exports.MULTISIG_MERGE_MISMATCH_AUTH_ADDR_MSG = exports.MULTISIG_MERGE_MISMATCH_ERROR_MSG = exports.MULTISIG_MERGE_LESSTHANTWO_ERROR_MSG = void 0;
const nacl = __importStar(require("./nacl/naclWrappers.js"));
const address_js_1 = require("./encoding/address.js");
const encoding = __importStar(require("./encoding/encoding.js"));
const utils = __importStar(require("./utils/utils.js"));
const signedTransaction_js_1 = require("./signedTransaction.js");
const multisig_js_1 = require("./multisig.js");
exports.MULTISIG_MERGE_LESSTHANTWO_ERROR_MSG = 'Not enough multisig transactions to merge. Need at least two';
exports.MULTISIG_MERGE_MISMATCH_ERROR_MSG = 'Cannot merge txs. txIDs differ';
exports.MULTISIG_MERGE_MISMATCH_AUTH_ADDR_MSG = 'Cannot merge txs. Auth addrs differ';
exports.MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG = 'Cannot merge txs. Multisig preimages differ';
exports.MULTISIG_MERGE_SIG_MISMATCH_ERROR_MSG = 'Cannot merge txs. subsigs are mismatched.';
exports.MULTISIG_NO_MUTATE_ERROR_MSG = 'Cannot mutate a multisig field as it would invalidate all existing signatures.';
exports.MULTISIG_USE_PARTIAL_SIGN_ERROR_MSG = 'Cannot sign a multisig transaction using `signTxn`. Use `partialSignTxn` instead.';
exports.MULTISIG_SIGNATURE_LENGTH_ERROR_MSG = 'Cannot add multisig signature. Signature is not of the correct length.';
const MULTISIG_KEY_NOT_EXIST_ERROR_MSG = 'Key does not exist';
/**
 * createMultisigTransaction creates a raw, unsigned multisig transaction blob.
 * @param txn - the actual transaction.
 * @param version - multisig version
 * @param threshold - multisig threshold
 * @param pks - ordered list of public keys in this multisig
 * @returns encoded multisig blob
 */
function createMultisigTransaction(txn, { version, threshold, addrs }) {
    // construct the appendable multisigned transaction format
    const pks = (0, multisig_js_1.pksFromAddresses)(addrs);
    const subsigs = pks.map((pk) => ({ pk }));
    const msig = {
        v: version,
        thr: threshold,
        subsig: subsigs,
    };
    // if the address of this multisig is different from the transaction sender,
    // we need to add the auth-addr field
    const msigAddr = (0, multisig_js_1.addressFromMultisigPreImg)({
        version,
        threshold,
        pks,
    });
    let sgnr;
    if (!txn.sender.equals(msigAddr)) {
        sgnr = msigAddr;
    }
    const signedTxn = new signedTransaction_js_1.SignedTransaction({
        txn,
        msig,
        sgnr,
    });
    return encoding.encodeMsgpack(signedTxn);
}
exports.createMultisigTransaction = createMultisigTransaction;
/**
 * createMultisigTransactionWithSignature creates a multisig transaction blob with an included signature.
 * @param txn - the actual transaction to sign.
 * @param rawSig - a Uint8Array raw signature of that transaction
 * @param myPk - a public key that corresponds with rawSig
 * @param version - multisig version
 * @param threshold - multisig threshold
 * @param pks - ordered list of public keys in this multisig
 * @returns encoded multisig blob
 */
function createMultisigTransactionWithSignature(txn, { rawSig, myPk }, { version, threshold, pks }) {
    // Create an empty encoded multisig transaction
    const encodedMsig = createMultisigTransaction(txn, {
        version,
        threshold,
        addrs: pks.map((pk) => new address_js_1.Address(pk)),
    });
    // note: this is not signed yet, but will be shortly
    const signedTxn = encoding.decodeMsgpack(encodedMsig, signedTransaction_js_1.SignedTransaction);
    let keyExist = false;
    // append the multisig signature to the corresponding public key in the multisig blob
    signedTxn.msig.subsig.forEach((subsig, i) => {
        if (nacl.bytesEqual(subsig.pk, myPk)) {
            keyExist = true;
            signedTxn.msig.subsig[i].s = rawSig;
        }
    });
    if (!keyExist) {
        throw new Error(MULTISIG_KEY_NOT_EXIST_ERROR_MSG);
    }
    return encoding.encodeMsgpack(signedTxn);
}
/**
 * partialSignTxn partially signs this transaction and returns a partially-signed multisig transaction,
 * encoded with msgpack as a typed array.
 * @param transaction - The transaction to sign
 * @param version - multisig version
 * @param threshold - multisig threshold
 * @param pks - multisig public key list, order is important.
 * @param sk - an Algorand secret key to sign with.
 * @returns an encoded, partially signed multisig transaction.
 */
function partialSignTxn(transaction, { version, threshold, pks }, sk) {
    // get signature verifier
    const myPk = nacl.keyPairFromSecretKey(sk).publicKey;
    return createMultisigTransactionWithSignature(transaction, { rawSig: transaction.rawSignTxn(sk), myPk }, { version, threshold, pks });
}
/**
 * partialSignWithMultisigSignature partially signs this transaction with an external raw multisig signature and returns
 * a partially-signed multisig transaction, encoded with msgpack as a typed array.
 * @param transaction - The transaction to sign
 * @param metadata - multisig metadata
 * @param signerAddr - address of the signer
 * @param signature - raw multisig signature
 * @returns an encoded, partially signed multisig transaction.
 */
function partialSignWithMultisigSignature(transaction, metadata, signerAddr, signature) {
    if (!nacl.isValidSignatureLength(signature.length)) {
        throw new Error(exports.MULTISIG_SIGNATURE_LENGTH_ERROR_MSG);
    }
    const signerAddressObj = typeof signerAddr === 'string'
        ? address_js_1.Address.fromString(signerAddr)
        : signerAddr;
    return createMultisigTransactionWithSignature(transaction, {
        rawSig: signature,
        myPk: signerAddressObj.publicKey,
    }, metadata);
}
/**
 * mergeMultisigTransactions takes a list of multisig transaction blobs, and merges them.
 * @param multisigTxnBlobs - a list of blobs representing encoded multisig txns
 * @returns typed array msg-pack encoded multisig txn
 */
function mergeMultisigTransactions(multisigTxnBlobs) {
    if (multisigTxnBlobs.length < 2) {
        throw new Error(exports.MULTISIG_MERGE_LESSTHANTWO_ERROR_MSG);
    }
    const refSigTx = encoding.decodeMsgpack(multisigTxnBlobs[0], signedTransaction_js_1.SignedTransaction);
    if (!refSigTx.msig) {
        throw new Error('Invalid multisig transaction, multisig structure missing at index 0');
    }
    const refTxID = refSigTx.txn.txID();
    const refAuthAddr = refSigTx.sgnr ? refSigTx.sgnr.toString() : undefined;
    const refPreImage = {
        version: refSigTx.msig.v,
        threshold: refSigTx.msig.thr,
        pks: refSigTx.msig.subsig.map((subsig) => subsig.pk),
    };
    const refMsigAddr = (0, multisig_js_1.addressFromMultisigPreImg)(refPreImage);
    const newSubsigs = refSigTx.msig.subsig.map((sig) => ({ ...sig }));
    for (let i = 1; i < multisigTxnBlobs.length; i++) {
        const unisig = encoding.decodeMsgpack(multisigTxnBlobs[i], signedTransaction_js_1.SignedTransaction);
        if (!unisig.msig) {
            throw new Error(`Invalid multisig transaction, multisig structure missing at index ${i}`);
        }
        if (unisig.txn.txID() !== refTxID) {
            throw new Error(exports.MULTISIG_MERGE_MISMATCH_ERROR_MSG);
        }
        const authAddr = unisig.sgnr ? unisig.sgnr.toString() : undefined;
        if (refAuthAddr !== authAddr) {
            throw new Error(exports.MULTISIG_MERGE_MISMATCH_AUTH_ADDR_MSG);
        }
        // check multisig has same preimage as reference
        if (unisig.msig.subsig.length !== refSigTx.msig.subsig.length) {
            throw new Error(exports.MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG);
        }
        const preimg = {
            version: unisig.msig.v,
            threshold: unisig.msig.thr,
            pks: unisig.msig.subsig.map((subsig) => subsig.pk),
        };
        const msgigAddr = (0, multisig_js_1.addressFromMultisigPreImg)(preimg);
        if (!refMsigAddr.equals(msgigAddr)) {
            throw new Error(exports.MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG);
        }
        // now, we can merge
        unisig.msig.subsig.forEach((uniSubsig, index) => {
            if (!uniSubsig.s)
                return;
            const current = newSubsigs[index];
            if (current.s && !utils.arrayEqual(uniSubsig.s, current.s)) {
                // mismatch
                throw new Error(exports.MULTISIG_MERGE_SIG_MISMATCH_ERROR_MSG);
            }
            current.s = uniSubsig.s;
        });
    }
    const msig = {
        v: refSigTx.msig.v,
        thr: refSigTx.msig.thr,
        subsig: newSubsigs,
    };
    const refSgnr = typeof refAuthAddr !== 'undefined' ? refSigTx.sgnr : undefined;
    const signedTxn = new signedTransaction_js_1.SignedTransaction({
        msig,
        txn: refSigTx.txn,
        sgnr: refSgnr,
    });
    return encoding.encodeMsgpack(signedTxn);
}
exports.mergeMultisigTransactions = mergeMultisigTransactions;
/**
 * signMultisigTransaction takes a raw transaction (see signTransaction), a multisig preimage, a secret key, and returns
 * a multisig transaction, which is a blob representing a transaction and multisignature account preimage. The returned
 * multisig txn can accumulate additional signatures through mergeMultisigTransactions or appendSignMultisigTransaction.
 * @param txn - object with either payment or key registration fields
 * @param version - multisig version
 * @param threshold - multisig threshold
 * @param addrs - a list of Algorand addresses representing possible signers for this multisig. Order is important.
 * @param sk - Algorand secret key. The corresponding pk should be in the pre image.
 * @returns object containing txID, and blob of partially signed multisig transaction (with multisig preimage information)
 * If the final calculated fee is lower than the protocol minimum fee, the fee will be increased to match the minimum.
 */
function signMultisigTransaction(txn, { version, threshold, addrs }, sk) {
    // build pks for partialSign
    const pks = (0, multisig_js_1.pksFromAddresses)(addrs);
    const blob = partialSignTxn(txn, { version, threshold, pks }, sk);
    return {
        txID: txn.txID(),
        blob,
    };
}
exports.signMultisigTransaction = signMultisigTransaction;
/**
 * appendSignMultisigTransaction takes a multisig transaction blob, and appends our signature to it.
 * While we could derive public key preimagery from the partially-signed multisig transaction,
 * we ask the caller to pass it back in, to ensure they know what they are signing.
 * @param multisigTxnBlob - an encoded multisig txn. Supports non-payment txn types.
 * @param version - multisig version
 * @param threshold - multisig threshold
 * @param addrs - a list of Algorand addresses representing possible signers for this multisig. Order is important.
 * @param sk - Algorand secret key
 * @returns object containing txID, and blob representing encoded multisig txn
 */
function appendSignMultisigTransaction(multisigTxnBlob, { version, threshold, addrs }, sk) {
    const pks = (0, multisig_js_1.pksFromAddresses)(addrs);
    // obtain underlying txn, sign it, and merge it
    const multisigTxObj = encoding.decodeMsgpack(multisigTxnBlob, signedTransaction_js_1.SignedTransaction);
    const partialSignedBlob = partialSignTxn(multisigTxObj.txn, { version, threshold, pks }, sk);
    return {
        txID: multisigTxObj.txn.txID(),
        blob: mergeMultisigTransactions([multisigTxnBlob, partialSignedBlob]),
    };
}
exports.appendSignMultisigTransaction = appendSignMultisigTransaction;
/**
 * appendMultisigTransactionSignature takes a multisig transaction blob, and appends a given raw signature to it.
 * This makes it possible to compile a multisig signature using only raw signatures from external methods.
 * @param multisigTxnBlob - an encoded multisig txn. Supports non-payment txn types.
 * @param version - multisig version
 * @param threshold - multisig threshold
 * @param addrs - a list of Algorand addresses representing possible signers for this multisig. Order is important.
 * @param signerAddr - address of the signer
 * @param signature - raw multisig signature
 * @returns object containing txID, and blob representing encoded multisig txn
 */
function appendSignRawMultisigSignature(multisigTxnBlob, { version, threshold, addrs }, signerAddr, signature) {
    const pks = (0, multisig_js_1.pksFromAddresses)(addrs);
    // obtain underlying txn, sign it, and merge it
    const multisigTxObj = encoding.decodeMsgpack(multisigTxnBlob, signedTransaction_js_1.SignedTransaction);
    const partialSignedBlob = partialSignWithMultisigSignature(multisigTxObj.txn, { version, threshold, pks }, signerAddr, signature);
    return {
        txID: multisigTxObj.txn.txID(),
        blob: mergeMultisigTransactions([multisigTxnBlob, partialSignedBlob]),
    };
}
exports.appendSignRawMultisigSignature = appendSignRawMultisigSignature;
//# sourceMappingURL=multisigSigning.js.map