"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.multisigAddress = exports.verifyMultisig = exports.addressFromMultisigPreImgAddrs = exports.addressFromMultisigPreImg = exports.pksFromAddresses = void 0;
const nacl = __importStar(require("./nacl/naclWrappers.js"));
const address_js_1 = require("./encoding/address.js");
const utils = __importStar(require("./utils/utils.js"));
// Convert "MultisigAddr" UTF-8 to byte array
const MULTISIG_PREIMG2ADDR_PREFIX = new Uint8Array([
    77, 117, 108, 116, 105, 115, 105, 103, 65, 100, 100, 114,
]);
const INVALID_MSIG_VERSION_ERROR_MSG = 'invalid multisig version';
const INVALID_MSIG_THRESHOLD_ERROR_MSG = 'bad multisig threshold';
const INVALID_MSIG_PK_ERROR_MSG = 'bad multisig public key - wrong length';
const UNEXPECTED_PK_LEN_ERROR_MSG = 'nacl public key length is not 32 bytes';
function pksFromAddresses(addrs) {
    return addrs.map((addr) => {
        if (typeof addr === 'string') {
            return address_js_1.Address.fromString(addr).publicKey;
        }
        return addr.publicKey;
    });
}
exports.pksFromAddresses = pksFromAddresses;
/**
 * fromMultisigPreImg takes multisig parameters and returns a 32 byte typed array public key,
 * representing an address that identifies the "exact group, version, and public keys" that are required for signing.
 * Hash("MultisigAddr" || version uint8 || threshold uint8 || PK1 || PK2 || ...)
 * Encoding this output yields a human readable address.
 * @param version - multisig version
 * @param threshold - multisig threshold
 * @param pks - array of typed array public keys
 */
function addressFromMultisigPreImg({ version, threshold, pks, }) {
    if (version !== 1 || version > 255 || version < 0) {
        // ^ a tad redundant, but in case in the future version != 1, still check for uint8
        throw new Error(INVALID_MSIG_VERSION_ERROR_MSG);
    }
    if (threshold === 0 ||
        pks.length === 0 ||
        threshold > pks.length ||
        threshold > 255) {
        throw new Error(INVALID_MSIG_THRESHOLD_ERROR_MSG);
    }
    const pkLen = address_js_1.ALGORAND_ADDRESS_BYTE_LENGTH - address_js_1.ALGORAND_CHECKSUM_BYTE_LENGTH;
    if (pkLen !== nacl.PUBLIC_KEY_LENGTH) {
        throw new Error(UNEXPECTED_PK_LEN_ERROR_MSG);
    }
    const merged = new Uint8Array(MULTISIG_PREIMG2ADDR_PREFIX.length + 2 + pkLen * pks.length);
    merged.set(MULTISIG_PREIMG2ADDR_PREFIX, 0);
    merged.set([version], MULTISIG_PREIMG2ADDR_PREFIX.length);
    merged.set([threshold], MULTISIG_PREIMG2ADDR_PREFIX.length + 1);
    for (let i = 0; i < pks.length; i++) {
        if (pks[i].length !== pkLen) {
            throw new Error(INVALID_MSIG_PK_ERROR_MSG);
        }
        merged.set(pks[i], MULTISIG_PREIMG2ADDR_PREFIX.length + 2 + i * pkLen);
    }
    return new address_js_1.Address(Uint8Array.from(nacl.genericHash(merged)));
}
exports.addressFromMultisigPreImg = addressFromMultisigPreImg;
/**
 * fromMultisigPreImgAddrs takes multisig parameters and returns a human readable Algorand address.
 * This is equivalent to fromMultisigPreImg, but interfaces with encoded addresses.
 * @param version - multisig version
 * @param threshold - multisig threshold
 * @param addrs - array of encoded addresses
 */
function addressFromMultisigPreImgAddrs({ version, threshold, addrs, }) {
    const pks = pksFromAddresses(addrs);
    return addressFromMultisigPreImg({ version, threshold, pks });
}
exports.addressFromMultisigPreImgAddrs = addressFromMultisigPreImgAddrs;
function verifyMultisig(toBeVerified, msig, publicKey) {
    const version = msig.v;
    const threshold = msig.thr;
    const subsigs = msig.subsig;
    const pks = subsigs.map((subsig) => subsig.pk);
    if (msig.subsig.length < threshold) {
        return false;
    }
    let pk;
    try {
        pk = addressFromMultisigPreImg({ version, threshold, pks }).publicKey;
    }
    catch (e) {
        return false;
    }
    if (!utils.arrayEqual(pk, publicKey)) {
        return false;
    }
    let counter = 0;
    for (const subsig of subsigs) {
        if (subsig.s !== undefined) {
            counter += 1;
        }
    }
    if (counter < threshold) {
        return false;
    }
    let verifiedCounter = 0;
    for (const subsig of subsigs) {
        if (subsig.s !== undefined) {
            if (nacl.verify(toBeVerified, subsig.s, subsig.pk)) {
                verifiedCounter += 1;
            }
        }
    }
    if (verifiedCounter < threshold) {
        return false;
    }
    return true;
}
exports.verifyMultisig = verifyMultisig;
/**
 * multisigAddress takes multisig metadata (preimage) and returns the corresponding human readable Algorand address.
 * @param version - multisig version
 * @param threshold - multisig threshold
 * @param addrs - list of Algorand addresses
 */
function multisigAddress({ version, threshold, addrs, }) {
    return addressFromMultisigPreImgAddrs({ version, threshold, addrs });
}
exports.multisigAddress = multisigAddress;
//# sourceMappingURL=multisig.js.map