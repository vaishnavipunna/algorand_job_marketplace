"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StateProofMessage = exports.StateProof = exports.Reveal = exports.SigslotCommit = exports.FalconSignatureStruct = exports.FalconVerifier = exports.Participant = exports.MerkleSignatureVerifier = exports.MerkleArrayProof = exports.HashFactory = void 0;
const index_js_1 = require("./encoding/schema/index.js");
class HashFactory {
    constructor(params) {
        this.hashType = params.hashType;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return HashFactory.encodingSchema;
    }
    toEncodingData() {
        return new Map([['t', this.hashType]]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded HashFactory: ${data}`);
        }
        return new HashFactory({
            hashType: Number(data.get('t')),
        });
    }
}
exports.HashFactory = HashFactory;
HashFactory.encodingSchema = new index_js_1.NamedMapSchema((0, index_js_1.allOmitEmpty)([
    { key: 't', valueSchema: new index_js_1.Uint64Schema() }, // hashType
]));
class MerkleArrayProof {
    constructor(params) {
        this.path = params.path;
        this.hashFactory = params.hashFactory;
        this.treeDepth = params.treeDepth;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return MerkleArrayProof.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['pth', this.path],
            ['hsh', this.hashFactory.toEncodingData()],
            ['td', this.treeDepth],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded MerkleArrayProof: ${data}`);
        }
        return new MerkleArrayProof({
            path: data.get('pth'),
            hashFactory: HashFactory.fromEncodingData(data.get('hsh')),
            treeDepth: Number(data.get('td')),
        });
    }
}
exports.MerkleArrayProof = MerkleArrayProof;
MerkleArrayProof.encodingSchema = new index_js_1.NamedMapSchema((0, index_js_1.allOmitEmpty)([
    {
        key: 'pth', // path
        valueSchema: new index_js_1.ArraySchema(new index_js_1.ByteArraySchema()),
    },
    {
        key: 'hsh', // hashFactory
        valueSchema: HashFactory.encodingSchema,
    },
    {
        key: 'td', // treeDepth
        valueSchema: new index_js_1.Uint64Schema(),
    },
]));
/**
 * MerkleSignatureVerifier is used to verify a merkle signature.
 */
class MerkleSignatureVerifier {
    constructor(params) {
        this.commitment = params.commitment;
        this.keyLifetime = params.keyLifetime;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return MerkleSignatureVerifier.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['cmt', this.commitment],
            ['lf', this.keyLifetime],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded MerkleSignatureVerifier: ${data}`);
        }
        return new MerkleSignatureVerifier({
            commitment: data.get('cmt'),
            keyLifetime: data.get('lf'),
        });
    }
}
exports.MerkleSignatureVerifier = MerkleSignatureVerifier;
MerkleSignatureVerifier.encodingSchema = new index_js_1.NamedMapSchema((0, index_js_1.allOmitEmpty)([
    {
        key: 'cmt', // commitment
        valueSchema: new index_js_1.FixedLengthByteArraySchema(64),
    },
    {
        key: 'lf', // keyLifetime
        valueSchema: new index_js_1.Uint64Schema(),
    },
]));
/**
 * A Participant corresponds to an account whose AccountData.Status is Online, and for which the
 * expected sigRound satisfies AccountData.VoteFirstValid <= sigRound <= AccountData.VoteLastValid.
 *
 * In the Algorand ledger, it is possible for multiple accounts to have the same PK. Thus, the PK is
 * not necessarily unique among Participants. However, each account will produce a unique Participant
 * struct, to avoid potential DoS attacks where one account claims to have the same VoteID PK as
 * another account.
 */
class Participant {
    constructor(params) {
        this.pk = params.pk;
        this.weight = params.weight;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return Participant.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['p', this.pk.toEncodingData()],
            ['w', this.weight],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded Participant: ${data}`);
        }
        return new Participant({
            pk: MerkleSignatureVerifier.fromEncodingData(data.get('p')),
            weight: data.get('w'),
        });
    }
}
exports.Participant = Participant;
Participant.encodingSchema = new index_js_1.NamedMapSchema((0, index_js_1.allOmitEmpty)([
    {
        key: 'p', // pk
        valueSchema: MerkleSignatureVerifier.encodingSchema,
    },
    {
        key: 'w', // weight
        valueSchema: new index_js_1.Uint64Schema(),
    },
]));
class FalconVerifier {
    constructor(params) {
        this.publicKey = params.publicKey;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return FalconVerifier.encodingSchema;
    }
    toEncodingData() {
        return new Map([['k', this.publicKey]]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded FalconVerifier: ${data}`);
        }
        return new FalconVerifier({
            publicKey: data.get('k'),
        });
    }
}
exports.FalconVerifier = FalconVerifier;
FalconVerifier.encodingSchema = new index_js_1.NamedMapSchema((0, index_js_1.allOmitEmpty)([
    { key: 'k', valueSchema: new index_js_1.FixedLengthByteArraySchema(0x701) }, // publicKey
]));
/**
 * FalconSignatureStruct represents a signature in the merkle signature scheme using falcon signatures
 * as an underlying crypto scheme. It consists of an ephemeral public key, a signature, a merkle
 * verification path and an index. The merkle signature considered valid only if the Signature is
 * verified under the ephemeral public key and the Merkle verification path verifies that the
 * ephemeral public key is located at the given index of the tree (for the root given in the
 * long-term public key). More details can be found on Algorand's spec
 */
class FalconSignatureStruct {
    constructor(params) {
        this.signature = params.signature;
        this.vectorCommitmentIndex = params.index;
        this.proof = params.proof;
        this.verifyingKey = params.verifyingKey;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return FalconSignatureStruct.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['sig', this.signature],
            ['idx', this.vectorCommitmentIndex],
            ['prf', this.proof.toEncodingData()],
            ['vkey', this.verifyingKey.toEncodingData()],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded FalconSignatureStruct: ${data}`);
        }
        return new FalconSignatureStruct({
            signature: data.get('sig'),
            index: data.get('idx'),
            proof: MerkleArrayProof.fromEncodingData(data.get('prf')),
            verifyingKey: FalconVerifier.fromEncodingData(data.get('vkey')),
        });
    }
}
exports.FalconSignatureStruct = FalconSignatureStruct;
FalconSignatureStruct.encodingSchema = new index_js_1.NamedMapSchema((0, index_js_1.allOmitEmpty)([
    { key: 'sig', valueSchema: new index_js_1.ByteArraySchema() }, // signature
    { key: 'idx', valueSchema: new index_js_1.Uint64Schema() }, // index
    { key: 'prf', valueSchema: MerkleArrayProof.encodingSchema }, // proof
    { key: 'vkey', valueSchema: FalconVerifier.encodingSchema }, // verifyingKey
]));
/**
 * A SigslotCommit is a single slot in the sigs array that forms the state proof.
 */
class SigslotCommit {
    constructor(params) {
        this.sig = params.sig;
        this.l = params.l;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return SigslotCommit.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['s', this.sig.toEncodingData()],
            ['l', this.l],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded SigslotCommit: ${data}`);
        }
        return new SigslotCommit({
            sig: FalconSignatureStruct.fromEncodingData(data.get('s')),
            l: data.get('l'),
        });
    }
}
exports.SigslotCommit = SigslotCommit;
SigslotCommit.encodingSchema = new index_js_1.NamedMapSchema((0, index_js_1.allOmitEmpty)([
    { key: 's', valueSchema: FalconSignatureStruct.encodingSchema }, // sigslot
    { key: 'l', valueSchema: new index_js_1.Uint64Schema() }, // l
]));
/**
 * Reveal is a single array position revealed as part of a state proof. It reveals an element of the
 * signature array and the corresponding element of the participants array.
 */
class Reveal {
    constructor(params) {
        this.sigslot = params.sigslot;
        this.participant = params.participant;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return Reveal.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['s', this.sigslot.toEncodingData()],
            ['p', this.participant.toEncodingData()],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded Reveal: ${data}`);
        }
        return new Reveal({
            sigslot: SigslotCommit.fromEncodingData(data.get('s')),
            participant: Participant.fromEncodingData(data.get('p')),
        });
    }
}
exports.Reveal = Reveal;
Reveal.encodingSchema = new index_js_1.NamedMapSchema((0, index_js_1.allOmitEmpty)([
    { key: 's', valueSchema: SigslotCommit.encodingSchema }, // sigslotCommit
    { key: 'p', valueSchema: Participant.encodingSchema }, // participant
]));
class StateProof {
    constructor(params) {
        this.sigCommit = params.sigCommit;
        this.signedWeight = params.signedWeight;
        this.sigProofs = params.sigProofs;
        this.partProofs = params.partProofs;
        this.merkleSignatureSaltVersion = params.merkleSignatureSaltVersion;
        this.reveals = params.reveals;
        this.positionsToReveal = params.positionsToReveal;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return StateProof.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['c', this.sigCommit],
            ['w', this.signedWeight],
            ['S', this.sigProofs.toEncodingData()],
            ['P', this.partProofs.toEncodingData()],
            ['v', this.merkleSignatureSaltVersion],
            [
                'r',
                (0, index_js_1.convertMap)(this.reveals, (key, value) => [key, value.toEncodingData()]),
            ],
            ['pr', this.positionsToReveal],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded StateProof: ${data}`);
        }
        return new StateProof({
            sigCommit: data.get('c'),
            signedWeight: data.get('w'),
            sigProofs: MerkleArrayProof.fromEncodingData(data.get('S')),
            partProofs: MerkleArrayProof.fromEncodingData(data.get('P')),
            merkleSignatureSaltVersion: Number(data.get('v')),
            reveals: (0, index_js_1.convertMap)(data.get('r'), (key, value) => [
                key,
                Reveal.fromEncodingData(value),
            ]),
            positionsToReveal: data.get('pr'),
        });
    }
}
exports.StateProof = StateProof;
StateProof.encodingSchema = new index_js_1.NamedMapSchema((0, index_js_1.allOmitEmpty)([
    {
        key: 'c', // sigCommit
        valueSchema: new index_js_1.ByteArraySchema(),
    },
    {
        key: 'w', // signedWeight
        valueSchema: new index_js_1.Uint64Schema(),
    },
    {
        key: 'S', // sigProofs
        valueSchema: MerkleArrayProof.encodingSchema,
    },
    {
        key: 'P', // partProofs
        valueSchema: MerkleArrayProof.encodingSchema,
    },
    {
        key: 'v', // merkleSignatureSaltVersion
        valueSchema: new index_js_1.Uint64Schema(),
    },
    {
        key: 'r', // reveals
        valueSchema: new index_js_1.Uint64MapSchema(Reveal.encodingSchema),
    },
    {
        key: 'pr', // positionsToReveal
        valueSchema: new index_js_1.ArraySchema(new index_js_1.Uint64Schema()),
    },
]));
class StateProofMessage {
    constructor(params) {
        this.blockHeadersCommitment = params.blockHeadersCommitment;
        this.votersCommitment = params.votersCommitment;
        this.lnProvenWeight = params.lnProvenWeight;
        this.firstAttestedRound = params.firstAttestedRound;
        this.lastAttestedRound = params.lastAttestedRound;
    }
    // eslint-disable-next-line class-methods-use-this
    getEncodingSchema() {
        return StateProofMessage.encodingSchema;
    }
    toEncodingData() {
        return new Map([
            ['b', this.blockHeadersCommitment],
            ['v', this.votersCommitment],
            ['P', this.lnProvenWeight],
            ['f', this.firstAttestedRound],
            ['l', this.lastAttestedRound],
        ]);
    }
    static fromEncodingData(data) {
        if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded StateProofMessage: ${data}`);
        }
        return new StateProofMessage({
            blockHeadersCommitment: data.get('b'),
            votersCommitment: data.get('v'),
            lnProvenWeight: data.get('P'),
            firstAttestedRound: data.get('f'),
            lastAttestedRound: data.get('l'),
        });
    }
    static fromMap(data) {
        return new StateProofMessage({
            blockHeadersCommitment: data.get('b'),
            votersCommitment: data.get('v'),
            lnProvenWeight: data.get('P'),
            firstAttestedRound: data.get('f'),
            lastAttestedRound: data.get('l'),
        });
    }
}
exports.StateProofMessage = StateProofMessage;
StateProofMessage.encodingSchema = new index_js_1.NamedMapSchema((0, index_js_1.allOmitEmpty)([
    { key: 'b', valueSchema: new index_js_1.ByteArraySchema() }, // blockHeadersCommitment
    { key: 'v', valueSchema: new index_js_1.ByteArraySchema() }, // votersCommitment
    { key: 'P', valueSchema: new index_js_1.Uint64Schema() }, // lnProvenWeight
    { key: 'f', valueSchema: new index_js_1.Uint64Schema() }, // firstAttestedRound
    { key: 'l', valueSchema: new index_js_1.Uint64Schema() }, // lastAttestedRound
]));
//# sourceMappingURL=stateproof.js.map