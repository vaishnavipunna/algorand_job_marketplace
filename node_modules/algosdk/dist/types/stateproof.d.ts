import { Encodable, Schema } from './encoding/encoding.js';
import { NamedMapSchema } from './encoding/schema/index.js';
export declare class HashFactory implements Encodable {
    static readonly encodingSchema: NamedMapSchema;
    hashType: number;
    constructor(params: {
        hashType: number;
    });
    getEncodingSchema(): Schema;
    toEncodingData(): Map<string, unknown>;
    static fromEncodingData(data: unknown): HashFactory;
}
export declare class MerkleArrayProof implements Encodable {
    static readonly encodingSchema: NamedMapSchema;
    /**
     * Path is bounded by MaxNumLeavesOnEncodedTree since there could be multiple reveals, and
     * given the distribution of the elt positions and the depth of the tree, the path length can
     * increase up to 2^MaxEncodedTreeDepth / 2
     */
    path: Uint8Array[];
    hashFactory: HashFactory;
    /**
     * TreeDepth represents the depth of the tree that is being proven. It is the number of edges
     * from the root to a leaf.
     */
    treeDepth: number;
    constructor(params: {
        path: Uint8Array[];
        hashFactory: HashFactory;
        treeDepth: number;
    });
    getEncodingSchema(): Schema;
    toEncodingData(): Map<string, unknown>;
    static fromEncodingData(data: unknown): MerkleArrayProof;
}
/**
 * MerkleSignatureVerifier is used to verify a merkle signature.
 */
export declare class MerkleSignatureVerifier implements Encodable {
    static readonly encodingSchema: NamedMapSchema;
    commitment: Uint8Array;
    keyLifetime: bigint;
    constructor(params: {
        commitment: Uint8Array;
        keyLifetime: bigint;
    });
    getEncodingSchema(): Schema;
    toEncodingData(): Map<string, unknown>;
    static fromEncodingData(data: unknown): MerkleSignatureVerifier;
}
/**
 * A Participant corresponds to an account whose AccountData.Status is Online, and for which the
 * expected sigRound satisfies AccountData.VoteFirstValid <= sigRound <= AccountData.VoteLastValid.
 *
 * In the Algorand ledger, it is possible for multiple accounts to have the same PK. Thus, the PK is
 * not necessarily unique among Participants. However, each account will produce a unique Participant
 * struct, to avoid potential DoS attacks where one account claims to have the same VoteID PK as
 * another account.
 */
export declare class Participant implements Encodable {
    static readonly encodingSchema: NamedMapSchema;
    /**
     * pk is the identifier used to verify the signature for a specific participant
     */
    pk: MerkleSignatureVerifier;
    /**
     * weight is AccountData.MicroAlgos.
     */
    weight: bigint;
    constructor(params: {
        pk: MerkleSignatureVerifier;
        weight: bigint;
    });
    getEncodingSchema(): Schema;
    toEncodingData(): Map<string, unknown>;
    static fromEncodingData(data: unknown): Participant;
}
export declare class FalconVerifier implements Encodable {
    static readonly encodingSchema: NamedMapSchema;
    publicKey: Uint8Array;
    constructor(params: {
        publicKey: Uint8Array;
    });
    getEncodingSchema(): Schema;
    toEncodingData(): Map<string, unknown>;
    static fromEncodingData(data: unknown): FalconVerifier;
}
/**
 * FalconSignatureStruct represents a signature in the merkle signature scheme using falcon signatures
 * as an underlying crypto scheme. It consists of an ephemeral public key, a signature, a merkle
 * verification path and an index. The merkle signature considered valid only if the Signature is
 * verified under the ephemeral public key and the Merkle verification path verifies that the
 * ephemeral public key is located at the given index of the tree (for the root given in the
 * long-term public key). More details can be found on Algorand's spec
 */
export declare class FalconSignatureStruct implements Encodable {
    static readonly encodingSchema: NamedMapSchema;
    signature: Uint8Array;
    vectorCommitmentIndex: bigint;
    proof: MerkleArrayProof;
    verifyingKey: FalconVerifier;
    constructor(params: {
        signature: Uint8Array;
        index: bigint;
        proof: MerkleArrayProof;
        verifyingKey: FalconVerifier;
    });
    getEncodingSchema(): Schema;
    toEncodingData(): Map<string, unknown>;
    static fromEncodingData(data: unknown): FalconSignatureStruct;
}
/**
 * A SigslotCommit is a single slot in the sigs array that forms the state proof.
 */
export declare class SigslotCommit implements Encodable {
    static readonly encodingSchema: NamedMapSchema;
    /**
     * Sig is a signature by the participant on the expected message.
     */
    sig: FalconSignatureStruct;
    /**
     * L is the total weight of signatures in lower-numbered slots. This is initialized once the builder
     * has collected a sufficient number of signatures.
     */
    l: bigint;
    constructor(params: {
        sig: FalconSignatureStruct;
        l: bigint;
    });
    getEncodingSchema(): Schema;
    toEncodingData(): Map<string, unknown>;
    static fromEncodingData(data: unknown): SigslotCommit;
}
/**
 * Reveal is a single array position revealed as part of a state proof. It reveals an element of the
 * signature array and the corresponding element of the participants array.
 */
export declare class Reveal implements Encodable {
    static readonly encodingSchema: NamedMapSchema;
    sigslot: SigslotCommit;
    participant: Participant;
    constructor(params: {
        sigslot: SigslotCommit;
        participant: Participant;
    });
    getEncodingSchema(): Schema;
    toEncodingData(): Map<string, unknown>;
    static fromEncodingData(data: unknown): Reveal;
}
export declare class StateProof implements Encodable {
    static readonly encodingSchema: NamedMapSchema;
    sigCommit: Uint8Array;
    signedWeight: bigint;
    sigProofs: MerkleArrayProof;
    partProofs: MerkleArrayProof;
    merkleSignatureSaltVersion: number;
    /**
     * Reveals is a sparse map from the position being revealed to the corresponding elements from the
     * sigs and participants arrays.
     */
    reveals: Map<bigint, Reveal>;
    positionsToReveal: bigint[];
    constructor(params: {
        sigCommit: Uint8Array;
        signedWeight: bigint;
        sigProofs: MerkleArrayProof;
        partProofs: MerkleArrayProof;
        merkleSignatureSaltVersion: number;
        reveals: Map<bigint, Reveal>;
        positionsToReveal: bigint[];
    });
    getEncodingSchema(): Schema;
    toEncodingData(): Map<string, unknown>;
    static fromEncodingData(data: unknown): StateProof;
}
export declare class StateProofMessage implements Encodable {
    static readonly encodingSchema: NamedMapSchema;
    blockHeadersCommitment: Uint8Array;
    votersCommitment: Uint8Array;
    lnProvenWeight: bigint;
    firstAttestedRound: bigint;
    lastAttestedRound: bigint;
    constructor(params: {
        blockHeadersCommitment: Uint8Array;
        votersCommitment: Uint8Array;
        lnProvenWeight: bigint;
        firstAttestedRound: bigint;
        lastAttestedRound: bigint;
    });
    getEncodingSchema(): Schema;
    toEncodingData(): Map<string, unknown>;
    static fromEncodingData(data: unknown): StateProofMessage;
    static fromMap(data: Map<string, unknown>): StateProofMessage;
}
