import { Encodable, Schema } from '../encoding/encoding.js';
import { NamedMapSchema } from '../encoding/schema/index.js';
import { Address } from '../encoding/address.js';
import { BlockHeader } from './block.js';
import { UntypedValue } from '../client/v2/untypedmodel.js';
export declare class TealValue implements Encodable {
    static readonly encodingSchema: NamedMapSchema;
    /**
     * Type determines the type of the value.
     * * 1 represents the type of a byte slice in a TEAL program
     * * 2 represents the type of an unsigned integer in a TEAL program
     */
    type: number;
    bytes?: Uint8Array;
    uint?: bigint;
    constructor(params: {
        type: number;
        bytes?: Uint8Array;
        uint?: bigint;
    });
    getEncodingSchema(): Schema;
    toEncodingData(): Map<string, unknown>;
    static fromEncodingData(data: unknown): TealValue;
}
/**
 * StateSchema sets maximums on the number of each type that may be stored
 */
export declare class StateSchema implements Encodable {
    static readonly encodingSchema: NamedMapSchema;
    numUints: number;
    numByteSlices: number;
    constructor(params: {
        numUints: number;
        numByteSlices: number;
    });
    getEncodingSchema(): Schema;
    toEncodingData(): Map<string, unknown>;
    static fromEncodingData(data: unknown): StateSchema;
}
/**
 * AppParams stores the global information associated with an application
 */
export declare class AppParams implements Encodable {
    static readonly encodingSchema: NamedMapSchema;
    approvalProgram: Uint8Array;
    clearStateProgram: Uint8Array;
    globalState: Map<Uint8Array, TealValue>;
    localStateSchema: StateSchema;
    globalStateSchema: StateSchema;
    extraProgramPages: number;
    constructor(params: {
        approvalProgram: Uint8Array;
        clearStateProgram: Uint8Array;
        globalState: Map<Uint8Array, TealValue>;
        localStateSchema: StateSchema;
        globalStateSchema: StateSchema;
        extraProgramPages: number;
    });
    getEncodingSchema(): Schema;
    toEncodingData(): Map<string, unknown>;
    static fromEncodingData(data: unknown): AppParams;
}
/**
 * AppLocalState stores the LocalState associated with an application.
 */
export declare class AppLocalState implements Encodable {
    static readonly encodingSchema: NamedMapSchema;
    schema: StateSchema;
    keyValue: Map<Uint8Array, TealValue>;
    constructor(params: {
        schema: StateSchema;
        keyValue: Map<Uint8Array, TealValue>;
    });
    getEncodingSchema(): Schema;
    toEncodingData(): Map<string, unknown>;
    static fromEncodingData(data: unknown): AppLocalState;
}
/**
 * AppLocalStateDelta tracks a changed AppLocalState, and whether it was deleted
 */
export declare class AppLocalStateDelta implements Encodable {
    static readonly encodingSchema: NamedMapSchema;
    localState?: AppLocalState;
    deleted: boolean;
    constructor(params: {
        localState?: AppLocalState;
        deleted: boolean;
    });
    getEncodingSchema(): Schema;
    toEncodingData(): Map<string, unknown>;
    static fromEncodingData(data: unknown): AppLocalStateDelta;
}
/**
 * AppParamsDelta tracks a changed AppParams, and whether it was deleted
 */
export declare class AppParamsDelta implements Encodable {
    static readonly encodingSchema: NamedMapSchema;
    params?: AppParams;
    deleted: boolean;
    constructor(params: {
        params?: AppParams;
        deleted: boolean;
    });
    getEncodingSchema(): Schema;
    toEncodingData(): Map<string, unknown>;
    static fromEncodingData(data: unknown): AppParamsDelta;
}
/**
 * AppResourceRecord represents AppParams and AppLocalState in deltas
 */
export declare class AppResourceRecord implements Encodable {
    static readonly encodingSchema: NamedMapSchema;
    id: bigint;
    address: Address;
    params: AppParamsDelta;
    state: AppLocalStateDelta;
    constructor(params: {
        id: bigint;
        address: Address;
        params: AppParamsDelta;
        state: AppLocalStateDelta;
    });
    getEncodingSchema(): Schema;
    toEncodingData(): Map<string, unknown>;
    static fromEncodingData(data: unknown): AppResourceRecord;
}
/**
 * AssetHolding describes an asset held by an account.
 */
export declare class AssetHolding implements Encodable {
    static readonly encodingSchema: NamedMapSchema;
    amount: bigint;
    frozen: boolean;
    constructor(params: {
        amount: bigint;
        frozen: boolean;
    });
    getEncodingSchema(): Schema;
    toEncodingData(): Map<string, unknown>;
    static fromEncodingData(data: unknown): AssetHolding;
}
/**
 * AssetHoldingDelta records a changed AssetHolding, and whether it was deleted
 */
export declare class AssetHoldingDelta implements Encodable {
    static readonly encodingSchema: NamedMapSchema;
    holding?: AssetHolding;
    deleted: boolean;
    constructor(params: {
        holding?: AssetHolding;
        deleted: boolean;
    });
    getEncodingSchema(): Schema;
    toEncodingData(): Map<string, unknown>;
    static fromEncodingData(data: unknown): AssetHoldingDelta;
}
/**
 * AssetParams describes the parameters of an asset.
 */
export declare class AssetParams implements Encodable {
    static readonly encodingSchema: NamedMapSchema;
    /**
     * Total specifies the total number of units of this asset created.
     */
    total: bigint;
    /**
     * Decimals specifies the number of digits to display after the decimal place when displaying this asset.
     * A value of 0 represents an asset that is not divisible, a value of 1 represents an asset divisible into tenths, and so on.
     * This value must be between 0 and 19 (inclusive).
     */
    decimals: number;
    /**
     * DefaultFrozen specifies whether slots for this asset in user accounts are frozen by default or not.
     */
    defaultFrozen: boolean;
    /**
     * UnitName specifies a hint for the name of a unit of this asset.
     */
    unitName?: Uint8Array;
    /**
     * AssetName specifies a hint for the name of the asset.
     */
    assetName?: Uint8Array;
    /**
     * URL specifies a URL where more information about the asset can be retrieved.
     */
    url?: Uint8Array;
    /**
     * MetadataHash specifies a commitment to some unspecified asset metadata. The format of this
     * metadata is up to the application.
     */
    metadataHash?: Uint8Array;
    /**
     * Manager specifies an account that is allowed to change the non-zero addresses in this AssetParams.
     */
    manager?: Address;
    /**
     * Reserve specifies an account whose holdings of this asset should be reported as "not minted".
     */
    reserve?: Address;
    /**
     * Freeze specifies an account that is allowed to change the frozen state of holdings of this asset.
     */
    freeze?: Address;
    /**
     * Clawback specifies an account that is allowed to take units of this asset from any account.
     */
    clawback?: Address;
    constructor(params: {
        total: bigint;
        decimals: number;
        defaultFrozen: boolean;
        unitName?: Uint8Array;
        assetName?: Uint8Array;
        url?: Uint8Array;
        metadataHash?: Uint8Array;
        manager?: Address;
        reserve?: Address;
        freeze?: Address;
        clawback?: Address;
    });
    getEncodingSchema(): Schema;
    toEncodingData(): Map<string, unknown>;
    static fromEncodingData(data: unknown): AssetParams;
}
/**
 * AssetParamsDelta tracks a changed AssetParams, and whether it was deleted
 */
export declare class AssetParamsDelta implements Encodable {
    static readonly encodingSchema: NamedMapSchema;
    params?: AssetParams;
    deleted: boolean;
    constructor(params: {
        params?: AssetParams;
        deleted: boolean;
    });
    getEncodingSchema(): Schema;
    toEncodingData(): Map<string, unknown>;
    static fromEncodingData(data: unknown): AssetParamsDelta;
}
/**
 * AssetResourceRecord represents AssetParams and AssetHolding in deltas
 */
export declare class AssetResourceRecord implements Encodable {
    static readonly encodingSchema: NamedMapSchema;
    id: bigint;
    address: Address;
    params: AssetParamsDelta;
    holding: AssetHoldingDelta;
    constructor(params: {
        id: bigint;
        address: Address;
        params: AssetParamsDelta;
        holding: AssetHoldingDelta;
    });
    getEncodingSchema(): Schema;
    toEncodingData(): Map<string, unknown>;
    static fromEncodingData(data: unknown): AssetResourceRecord;
}
/**
 * VotingData holds participation information
 */
export declare class VotingData implements Encodable {
    static readonly encodingSchema: NamedMapSchema;
    voteID: Uint8Array;
    selectionID: Uint8Array;
    stateProofID: Uint8Array;
    voteFirstValid: bigint;
    voteLastValid: bigint;
    voteKeyDilution: bigint;
    constructor(params: {
        voteID: Uint8Array;
        selectionID: Uint8Array;
        stateProofID: Uint8Array;
        voteFirstValid: bigint;
        voteLastValid: bigint;
        voteKeyDilution: bigint;
    });
    getEncodingSchema(): Schema;
    toEncodingData(): Map<string, unknown>;
    static fromEncodingData(data: unknown): VotingData;
}
/**
 * AccountBaseData contains base account info like balance, status and total number of resources
 */
export declare class AccountBaseData implements Encodable {
    static readonly encodingSchema: NamedMapSchema;
    /**
     * Account status. Values are:
     * * 0: Offline
     * * 1: Online
     * * 2: NotParticipating
     */
    status: number;
    microAlgos: bigint;
    rewardsBase: bigint;
    rewardedMicroAlgos: bigint;
    authAddr: Address;
    incentiveEligible: boolean;
    /**
     * Totals across created globals, and opted in locals.
     */
    totalAppSchema: StateSchema;
    /**
     * Total number of extra pages across all created apps
     */
    totalExtraAppPages: number;
    /**
     * Total number of apps this account has created
     */
    totalAppParams: bigint;
    /**
     * Total number of apps this account is opted into.
     */
    totalAppLocalStates: bigint;
    /**
     * Total number of assets created by this account
     */
    totalAssetParams: bigint;
    /**
     * Total of asset creations and optins (i.e. number of holdings)
     */
    totalAssets: bigint;
    /**
     * Total number of boxes associated to this account
     */
    totalBoxes: bigint;
    /**
     * Total bytes for this account's boxes. keys _and_ values count
     */
    totalBoxBytes: bigint;
    /**
     * The last round that this account proposed the winning block.
     */
    lastProposed: bigint;
    /**
     * The last round that this account sent a heartbeat to show it was online.
     */
    lastHeartbeat: bigint;
    constructor(params: {
        status: number;
        microAlgos: bigint;
        rewardsBase: bigint;
        rewardedMicroAlgos: bigint;
        authAddr: Address;
        incentiveEligible: boolean;
        totalAppSchema: StateSchema;
        totalExtraAppPages: number;
        totalAppParams: bigint;
        totalAppLocalStates: bigint;
        totalAssetParams: bigint;
        totalAssets: bigint;
        totalBoxes: bigint;
        totalBoxBytes: bigint;
        lastProposed: bigint;
        lastHeartbeat: bigint;
    });
    getEncodingSchema(): Schema;
    toEncodingData(): Map<string, unknown>;
    static fromEncodingData(data: unknown): AccountBaseData;
}
/**
 * AccountData provides per-account data
 */
export declare class AccountData implements Encodable {
    static readonly encodingSchema: NamedMapSchema;
    accountBaseData: AccountBaseData;
    votingData: VotingData;
    constructor(params: {
        accountBaseData: AccountBaseData;
        votingData: VotingData;
    });
    getEncodingSchema(): Schema;
    toEncodingData(): Map<string, unknown>;
    static fromEncodingData(data: unknown): AccountData;
}
export declare class BalanceRecord implements Encodable {
    static readonly encodingSchema: NamedMapSchema;
    addr: Address;
    accountData: AccountData;
    constructor(params: {
        addr: Address;
        accountData: AccountData;
    });
    getEncodingSchema(): Schema;
    toEncodingData(): Map<string, unknown>;
    static fromEncodingData(data: unknown): BalanceRecord;
}
export declare class AccountDeltas implements Encodable {
    static readonly encodingSchema: NamedMapSchema;
    accounts: BalanceRecord[];
    appResources: AppResourceRecord[];
    assetResources: AssetResourceRecord[];
    constructor(params: {
        accounts: BalanceRecord[];
        appResources: AppResourceRecord[];
        assetResources: AssetResourceRecord[];
    });
    getEncodingSchema(): Schema;
    toEncodingData(): Map<string, unknown>;
    static fromEncodingData(data: unknown): AccountDeltas;
}
/**
 * A KvValueDelta shows how the Data associated with a key in the kvstore has changed.
 */
export declare class KvValueDelta implements Encodable {
    static readonly encodingSchema: NamedMapSchema;
    /**
     * Data stores the most recent value (undefined means deleted)
     */
    data?: Uint8Array;
    /**
     * OldData stores the previous value (undefined means didn't exist)
     */
    oldData?: Uint8Array;
    constructor(params: {
        data?: Uint8Array;
        oldData?: Uint8Array;
    });
    getEncodingSchema(): Schema;
    toEncodingData(): Map<string, unknown>;
    static fromEncodingData(data: unknown): KvValueDelta;
}
/**
 * IncludedTransactions defines the transactions included in a block, their index and last valid round.
 */
export declare class IncludedTransactions implements Encodable {
    static readonly encodingSchema: NamedMapSchema;
    lastValid: bigint;
    /**
     * The index of the transaction in the block
     */
    intra: number;
    constructor(params: {
        lastValid: bigint;
        intra: number;
    });
    getEncodingSchema(): Schema;
    toEncodingData(): Map<string, unknown>;
    static fromEncodingData(data: unknown): IncludedTransactions;
}
/**
 * ModifiedCreatable represents a change to a single creatable state
 */
export declare class ModifiedCreatable implements Encodable {
    static readonly encodingSchema: NamedMapSchema;
    /**
     * Type of the creatable. The values are:
     * * 0: Asset
     * * 1: Application
     */
    creatableType: number;
    /**
     * Created if true, deleted if false
     */
    created: boolean;
    /**
     * creator of the app/asset
     */
    creator: Address;
    /**
     * Keeps track of how many times this app/asset appears in accountUpdates.creatableDeltas
     */
    ndeltas: number;
    constructor(params: {
        creatableType: number;
        created: boolean;
        creator: Address;
        ndeltas: number;
    });
    getEncodingSchema(): Schema;
    toEncodingData(): Map<string, unknown>;
    static fromEncodingData(data: unknown): ModifiedCreatable;
}
/**
 * AlgoCount represents a total of algos of a certain class of accounts (split up by their Status value).
 */
export declare class AlgoCount implements Encodable {
    static readonly encodingSchema: NamedMapSchema;
    /**
     * Sum of algos of all accounts in this class.
     */
    money: bigint;
    /**
     * Total number of whole reward units in accounts.
     */
    rewardUnits: bigint;
    constructor(params: {
        money: bigint;
        rewardUnits: bigint;
    });
    getEncodingSchema(): Schema;
    toEncodingData(): Map<string, unknown>;
    static fromEncodingData(data: unknown): AlgoCount;
}
/**
 * AccountTotals represents the totals of algos in the system grouped by different account status values.
 */
export declare class AccountTotals implements Encodable {
    static readonly encodingSchema: NamedMapSchema;
    online: AlgoCount;
    offline: AlgoCount;
    notParticipating: AlgoCount;
    /**
     * Total number of algos received per reward unit since genesis
     */
    rewardsLevel: bigint;
    constructor(params: {
        online: AlgoCount;
        offline: AlgoCount;
        notParticipating: AlgoCount;
        rewardsLevel: bigint;
    });
    getEncodingSchema(): Schema;
    toEncodingData(): Map<string, unknown>;
    static fromEncodingData(data: unknown): AccountTotals;
}
/**
 * LedgerStateDelta describes the delta between a given round to the previous round
 */
export declare class LedgerStateDelta implements Encodable {
    static readonly encodingSchema: NamedMapSchema;
    /**
     * modified new accounts
     */
    accounts: AccountDeltas;
    /**
     * modified kv pairs (nil == delete)
     */
    kvMods: Map<Uint8Array, KvValueDelta>;
    /**
     * new Txids for the txtail and TxnCounter, mapped to txn.LastValid
     */
    txids: Map<Uint8Array, IncludedTransactions>;
    /**
     *  new txleases for the txtail mapped to expiration
     */
    txleases: UntypedValue;
    /**
     * new creatables creator lookup table
     */
    creatables: Map<bigint, ModifiedCreatable>;
    /**
     * new block header
     */
    blockHeader: BlockHeader;
    /**
     * StateProofNext represents modification on StateProofNextRound field in the block header. If the block contains
     * a valid state proof transaction, this field will contain the next round for state proof.
     * otherwise it will be set to 0.
     */
    stateProofNext: bigint;
    /**
     * previous block timestamp
     */
    prevTimestamp: bigint;
    /**
     * The account totals reflecting the changes in this StateDelta object.
     */
    totals: AccountTotals;
    constructor(params: {
        accounts: AccountDeltas;
        kvMods: Map<Uint8Array, KvValueDelta>;
        txids: Map<Uint8Array, IncludedTransactions>;
        txleases: UntypedValue;
        creatables: Map<bigint, ModifiedCreatable>;
        blockHeader: BlockHeader;
        stateProofNext: bigint;
        prevTimestamp: bigint;
        totals: AccountTotals;
    });
    getEncodingSchema(): Schema;
    toEncodingData(): Map<string, unknown>;
    static fromEncodingData(data: unknown): LedgerStateDelta;
}
