import { Encodable, Schema } from '../encoding/encoding.js';
import { NamedMapSchema } from '../encoding/schema/index.js';
import { Address } from '../encoding/address.js';
import { SignedTransaction } from '../signedTransaction.js';
/**
 * StateProofTrackingData tracks the status of state proofs.
 */
export declare class StateProofTrackingData implements Encodable {
    static readonly encodingSchema: NamedMapSchema;
    /**
     * StateProofVotersCommitment is the root of a vector commitment containing the online accounts
     * that will help sign a state proof.  The VC root, and the state proof, happen on blocks that are
     * a multiple of ConsensusParams.StateProofRounds.  For blocks that are not a multiple of
     * ConsensusParams.StateProofRounds, this value is zero.
     */
    stateProofVotersCommitment: Uint8Array;
    /**
     * StateProofOnlineTotalWeight is the total number of microalgos held by the online accounts during
     * the StateProof round (or zero, if the merkle root is zero - no commitment for StateProof voters).
     * This is intended for computing the threshold of votes to expect from StateProofVotersCommitment.
     */
    stateProofOnlineTotalWeight: bigint;
    /**
     * StateProofNextRound is the next round for which we will accept a StateProof transaction.
     */
    stateProofNextRound: bigint;
    constructor(params: {
        stateProofVotersCommitment: Uint8Array;
        stateProofOnlineTotalWeight: bigint;
        stateProofNextRound: bigint;
    });
    getEncodingSchema(): Schema;
    toEncodingData(): Map<string, unknown>;
    static fromEncodingData(data: unknown): StateProofTrackingData;
}
/**
 * TxnCommitments represents the commitments computed from the transactions in the block.
 * It contains multiple commitments based on different algorithms and hash functions, to support
 * different use cases.
 */
export declare class TxnCommitments implements Encodable {
    static readonly encodingSchema: NamedMapSchema;
    /**
     * Root of transaction merkle tree using SHA512_256 hash function. This commitment is computed
     * based on the PaysetCommit type specified in the block's consensus protocol.
     */
    nativeSha512_256Commitment: Uint8Array;
    /**
     * Root of transaction vector commitment merkle tree using SHA256 hash function
     */
    sha256Commitment: Uint8Array;
    constructor(params: {
        nativeSha512_256Commitment: Uint8Array;
        sha256Commitment: Uint8Array;
    });
    getEncodingSchema(): Schema;
    toEncodingData(): Map<string, unknown>;
    static fromEncodingData(data: unknown): TxnCommitments;
}
/**
 * RewardsState represents the global parameters controlling the rate at which accounts accrue rewards.
 */
export declare class RewardState implements Encodable {
    static readonly encodingSchema: NamedMapSchema;
    /**
     * The FeeSink address.
     */
    feeSink: Address;
    /**
     * The RewardsPool address.
     */
    rewardsPool: Address;
    /**
     * RewardsLevel specifies how many rewards, in MicroAlgos, have been distributed to each
     * config.Protocol.RewardUnit of MicroAlgos since genesis.
     */
    rewardsLevel: bigint;
    /**
     * The number of new MicroAlgos added to the participation stake from rewards at the next round.
     */
    rewardsRate: bigint;
    /**
     * The number of leftover MicroAlgos after the distribution of RewardsRate/rewardUnits MicroAlgos for
     * every reward unit in the next round.
     */
    rewardsResidue: bigint;
    /**
     * The round at which the RewardsRate will be recalculated.
     */
    rewardsRecalculationRound: bigint;
    constructor(params: {
        feeSink: Address;
        rewardsPool: Address;
        rewardsLevel: bigint;
        rewardsRate: bigint;
        rewardsResidue: bigint;
        rewardsRecalculationRound: bigint;
    });
    getEncodingSchema(): Schema;
    toEncodingData(): Map<string, unknown>;
    static fromEncodingData(data: unknown): RewardState;
}
/**
 * UpgradeState tracks the protocol upgrade state machine.  It is, strictly speaking, computable from
 * the history of all UpgradeVotes but we keep it in the block for explicitness and convenience
 * (instead of materializing it separately, like balances).
 */
export declare class UpgradeState implements Encodable {
    static readonly encodingSchema: NamedMapSchema;
    currentProtocol: string;
    nextProtocol: string;
    nextProtocolApprovals: bigint;
    /**
     * NextProtocolVoteBefore specify the last voting round for the next protocol proposal. If there
     * is no voting for an upgrade taking place, this would be zero.
     */
    nextProtocolVoteBefore: bigint;
    /**
     * NextProtocolSwitchOn specify the round number at which the next protocol would be adopted. If
     * there is no upgrade taking place, nor a wait for the next protocol, this would be zero.
     */
    nextProtocolSwitchOn: bigint;
    constructor(params: {
        currentProtocol: string;
        nextProtocol: string;
        nextProtocolApprovals: bigint;
        nextProtocolVoteBefore: bigint;
        nextProtocolSwitchOn: bigint;
    });
    getEncodingSchema(): Schema;
    toEncodingData(): Map<string, unknown>;
    static fromEncodingData(data: unknown): UpgradeState;
}
/**
 * UpgradeVote represents the vote of the block proposer with respect to protocol upgrades.
 */
export declare class UpgradeVote implements Encodable {
    static readonly encodingSchema: NamedMapSchema;
    /**
     * UpgradePropose indicates a proposed upgrade
     */
    upgradePropose: string;
    /**
     * UpgradeDelay indicates the time between acceptance and execution
     */
    upgradeDelay: bigint;
    /**
     * UpgradeApprove indicates a yes vote for the current proposal
     */
    upgradeApprove: boolean;
    constructor(params: {
        upgradePropose: string;
        upgradeDelay: bigint;
        upgradeApprove: boolean;
    });
    getEncodingSchema(): Schema;
    toEncodingData(): Map<string, unknown>;
    static fromEncodingData(data: unknown): UpgradeVote;
}
/**
 * ParticipationUpdates represents participation account data that needs to be checked/acted on by
 * the network
 */
export declare class ParticipationUpdates implements Encodable {
    static readonly encodingSchema: NamedMapSchema;
    /**
     * ExpiredParticipationAccounts contains a list of online accounts that needs to be converted to
     * offline since their participation key expired.
     */
    expiredParticipationAccounts: Address[];
    /**
     * AbsentParticipationAccounts contains a list of online accounts that needs to be converted to
     * offline since they are not proposing.
     */
    absentParticipationAccounts: Address[];
    constructor(params: {
        expiredParticipationAccounts: Address[];
        absentParticipationAccounts: Address[];
    });
    getEncodingSchema(): Schema;
    toEncodingData(): Map<string, unknown>;
    static fromEncodingData(data: unknown): ParticipationUpdates;
}
/**
 * Represents the metadata and state of a block.
 *
 * For more information, refer to: https://github.com/algorand/go-algorand/blob/master/data/bookkeeping/block.go
 */
export declare class BlockHeader implements Encodable {
    static readonly encodingSchema: NamedMapSchema;
    /**
     * Round number
     */
    round: bigint;
    /**
     * Previous block hash
     */
    branch: Uint8Array;
    /**
     * Sortition seed
     */
    seed: Uint8Array;
    txnCommitments: TxnCommitments;
    /**
     * Timestamp in seconds since epoch
     */
    timestamp: bigint;
    /**
     * Genesis ID to which this block belongs.
     */
    genesisID: string;
    /**
     * Genesis hash to which this block belongs.
     */
    genesisHash: Uint8Array;
    /**
     *  Proposer is the proposer of this block. Like the Seed, agreement adds this after the block is
     * assembled by the transaction pool, so that the same block can be prepared for multiple
     * participating accounts in the same node. Populated if proto.Payouts.Enabled
     */
    proposer: Address;
    /**
     * FeesCollected is the sum of all fees paid by transactions in this block. Populated if
     * proto.EnableMining.
     */
    feesCollected: bigint;
    /**
     * Bonus is the bonus incentive to be paid for proposing this block.  It begins as a consensus
     * parameter value, and decays periodically.
     */
    bonus: bigint;
    /**
     * ProposerPayout is the amount that should be moved from the FeeSink to the Proposer at the start
     * of the next block.  It is basically the bonus + the payouts percent of FeesCollected, but may
     * be zero'd by proposer ineligibility.
     */
    proposerPayout: bigint;
    rewardState: RewardState;
    upgradeState: UpgradeState;
    upgradeVote: UpgradeVote;
    /**
     * TxnCounter is the number of the next transaction that will be committed after this block. Genesis
     * blocks can start at either 0 or 1000, depending on a consensus parameter (AppForbidLowResources).
     */
    txnCounter: bigint;
    /**
     * StateProofTracking tracks the status of the state proofs, potentially for multiple types of
     * ASPs (Algorand's State Proofs).
     */
    stateproofTracking: Map<number, StateProofTrackingData>;
    participationUpdates: ParticipationUpdates;
    constructor(params: {
        round: bigint;
        branch: Uint8Array;
        seed: Uint8Array;
        txnCommitments: TxnCommitments;
        timestamp: bigint;
        genesisID: string;
        genesisHash: Uint8Array;
        proposer: Address;
        feesCollected: bigint;
        bonus: bigint;
        proposerPayout: bigint;
        rewardState: RewardState;
        upgradeState: UpgradeState;
        upgradeVote: UpgradeVote;
        txnCounter: bigint;
        stateproofTracking: Map<number, StateProofTrackingData>;
        participationUpdates: ParticipationUpdates;
    });
    getEncodingSchema(): Schema;
    toEncodingData(): Map<string, unknown>;
    static fromEncodingData(data: unknown): BlockHeader;
}
export declare class ValueDelta implements Encodable {
    static readonly encodingSchema: NamedMapSchema;
    action: number;
    bytes: Uint8Array;
    uint: bigint;
    constructor(params: {
        action: number;
        bytes: Uint8Array;
        uint: bigint;
    });
    getEncodingSchema(): Schema;
    toEncodingData(): Map<string, unknown>;
    static fromEncodingData(data: unknown): ValueDelta;
}
export declare class EvalDelta implements Encodable {
    private static encodingSchemaValue;
    static get encodingSchema(): Schema;
    globalDelta: Map<Uint8Array, ValueDelta>;
    /**
     * When decoding EvalDeltas, the integer key represents an offset into
     * [txn.Sender, txn.Accounts[0], txn.Accounts[1], ...]
     */
    localDeltas: Map<number, Map<Uint8Array, ValueDelta>>;
    /**
     * If a program modifies the local of an account that is not the Sender, or
     * in txn.Accounts, it must be recorded here, so that the key in LocalDeltas
     * can refer to it.
     */
    sharedAccts: Address[];
    logs: Uint8Array[];
    innerTxns: SignedTxnWithAD[];
    constructor(params: {
        globalDelta?: Map<Uint8Array, ValueDelta>;
        localDeltas?: Map<number, Map<Uint8Array, ValueDelta>>;
        sharedAccts?: Address[];
        logs?: Uint8Array[];
        innerTxns?: SignedTxnWithAD[];
    });
    getEncodingSchema(): Schema;
    toEncodingData(): Map<string, unknown>;
    static fromEncodingData(data: unknown): EvalDelta;
}
export declare class ApplyData implements Encodable {
    private static encodingSchemaValue;
    static get encodingSchema(): Schema;
    /**
     * Closing amount for transaction.
     */
    closingAmount?: bigint;
    /**
     * Closing amount for asset transaction.
     */
    assetClosingAmount?: bigint;
    /**
     * Rewards applied to the Sender.
     */
    senderRewards?: bigint;
    /**
     * Rewards applied to the Receiver.
     */
    receiverRewards?: bigint;
    /**
     * Rewards applied to the CloseRemainderTo account.
     */
    closeRewards?: bigint;
    evalDelta?: EvalDelta;
    /**
     * If an ASA is being created, this is its newly created ID. Else 0.
     */
    configAsset?: bigint;
    /**
     * If an application is being created, this is its newly created ID. Else 0.
     */
    applicationID?: bigint;
    constructor(params: {
        closingAmount?: bigint;
        assetClosingAmount?: bigint;
        senderRewards?: bigint;
        receiverRewards?: bigint;
        closeRewards?: bigint;
        evalDelta?: EvalDelta;
        configAsset?: bigint;
        applicationID?: bigint;
    });
    getEncodingSchema(): Schema;
    toEncodingData(): Map<string, unknown>;
    static fromEncodingData(data: unknown): ApplyData;
}
export declare class SignedTxnWithAD implements Encodable {
    private static encodingSchemaValue;
    static get encodingSchema(): Schema;
    signedTxn: SignedTransaction;
    applyData: ApplyData;
    constructor(params: {
        signedTxn: SignedTransaction;
        applyData: ApplyData;
    });
    getEncodingSchema(): Schema;
    toEncodingData(): Map<string, unknown>;
    static fromEncodingData(data: unknown): SignedTxnWithAD;
}
/**
 * SignedTxnInBlock is how a signed transaction is encoded in a block.
 */
export declare class SignedTxnInBlock implements Encodable {
    static readonly encodingSchema: NamedMapSchema;
    signedTxn: SignedTxnWithAD;
    hasGenesisID: boolean;
    hasGenesisHash: boolean;
    constructor(params: {
        signedTxn: SignedTxnWithAD;
        hasGenesisID: boolean;
        hasGenesisHash: boolean;
    });
    getEncodingSchema(): Schema;
    toEncodingData(): Map<string, unknown>;
    static fromEncodingData(data: unknown): SignedTxnInBlock;
}
/**
 * A Block contains the Payset and metadata corresponding to a given Round.
 */
export declare class Block implements Encodable {
    static readonly encodingSchema: NamedMapSchema;
    header: BlockHeader;
    payset: SignedTxnInBlock[];
    constructor(params: {
        header: BlockHeader;
        payset: SignedTxnInBlock[];
    });
    getEncodingSchema(): Schema;
    toEncodingData(): Map<string, unknown>;
    static fromEncodingData(data: unknown): Block;
}
