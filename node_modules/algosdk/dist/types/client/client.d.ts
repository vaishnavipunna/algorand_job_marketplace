import * as utils from '../utils/utils.js';
import { BaseHTTPClient, Query } from './baseHTTPClient.js';
import { TokenHeader } from './urlTokenBaseHTTPClient.js';
export declare class HTTPClientResponse {
    /**
     * The raw response bytes
     */
    body: Uint8Array;
    /**
     * If the expected response type is JSON, this is the response bytes converted to a string.
     */
    text?: string;
    format: 'application/msgpack' | 'application/json';
    headers: Record<string, string>;
    status: number;
    ok: boolean;
    constructor(options: {
        body: Uint8Array;
        text?: string;
        format: 'application/msgpack' | 'application/json';
        headers: Record<string, string>;
        status: number;
        ok: boolean;
    });
    /**
     * Returns the response body as a string, ready to be parsed as JSON.
     */
    getJSONText(): string;
    /**
     * Parses the response body as JSON with the given options.
     */
    parseBodyAsJSON(jsonOptions: utils.ParseJSONOptions): any;
}
/**
 * HTTPClient is a wrapper around a BaseHTTPClient
 * It takes care of setting the proper "Accept" header and of
 * decoding the JSON outputs.
 */
export declare class HTTPClient {
    private bc;
    /**
     * Construct an HTTPClient from a BaseHTTPClient
     * @param bc - the BaseHTTPClient used
     */
    constructor(bc: BaseHTTPClient);
    /**
     * Construct an HTTPClient from a URL (baseServer+port) and a token
     */
    constructor(tokenHeader: TokenHeader, baseServer: string, port?: string | number, defaultHeaders?: Record<string, string>);
    /**
     * Parse JSON using utils.parseJSON
     *
     * @param text - JSON data
     * @param status - Status of the response (used in case parseJSON fails)
     * @param jsonOptions - Options object to use to decode JSON responses. See
     *   utils.parseJSON for the options available.
     */
    static parseJSON(text: string, status: number, jsonOptions: utils.ParseJSONOptions): any;
    /**
     * Serialize the data according to the requestHeaders
     * Assumes that requestHeaders contain a key "content-type"
     * If the content-type is "application/json", data is JSON serialized
     * Otherwise, data needs to be either an UTF-8 string that is converted to an Uint8Array
     * or an Uint8Array
     * @private
     */
    private static serializeData;
    /**
     * Convert a BaseHTTPClientResponse into a full HTTPClientResponse
     * Parse the body in
     * Modifies in place res and return the result
     */
    private static prepareResponse;
    /**
     * Prepare an error with a response
     * (the type of errors BaseHTTPClient are supposed to throw)
     * by adding the status and preparing the internal response
     * @private
     */
    private static prepareResponseError;
    /**
     * Send a GET request.
     *
     * @param options - The options to use for the request.
     * @param options.relativePath - The path of the request.
     * @param options.query - An object containing the query parameters of the request.
     * @param options.requestHeaders - An object containing additional request headers to use.
     *   or not.
     * @param options.customOptions - An object containing additional options to pass to the
     *   underlying BaseHTTPClient instance.
     * @returns Response object.
     */
    get({ relativePath, query, requestHeaders, customOptions, }: {
        relativePath: string;
        query?: Query<any>;
        requestHeaders?: Record<string, string>;
        customOptions?: Record<string, unknown>;
    }): Promise<HTTPClientResponse>;
    /**
     * Send a POST request.
     * If no content-type present, adds the header "content-type: application/json"
     * and data is serialized in JSON (if not empty)
     * @param options - The options to use for the request.
     */
    post({ relativePath, data, query, requestHeaders, customOptions, }: {
        relativePath: string;
        data: any;
        query?: Query<any>;
        requestHeaders?: Record<string, string>;
        customOptions?: Record<string, unknown>;
    }): Promise<HTTPClientResponse>;
    /**
     * Send a DELETE request.
     * If no content-type present, adds the header "content-type: application/json"
     * and data is serialized in JSON (if not empty)
     * @param options - The options to use for the request.
     */
    delete({ relativePath, data, requestHeaders, customOptions, }: {
        relativePath: string;
        data: any;
        requestHeaders?: Record<string, string>;
        customOptions?: Record<string, unknown>;
    }): Promise<HTTPClientResponse>;
}
