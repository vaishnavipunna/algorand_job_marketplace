import { Schema, MsgpackEncodingData, MsgpackRawStringProvider, JSONEncodingData, PrepareJSONOptions } from '../encoding.js';
/**
 * Describes a key-value entry in a NamedMapSchema.
 */
export interface NamedMapEntry {
    /**
     * Key of the entry. Must be unique for this map.
     */
    key: string;
    /**
     * The Schema for the entry's value.
     */
    valueSchema: Schema;
    /**
     * If true, the entry will be omitted from the encoding if the value is the default value.
     */
    omitEmpty: boolean;
    /**
     * If true, valueSchema must be a NamedMapSchema and key must be the empty string. The fields of
     * valueSchema will be embedded directly in the parent map.
     *
     * omitEmpty is ignored for embedded entries. Instead, the individual omitEmpty values of the
     * embedded fields are used.
     */
    embedded?: boolean;
}
/**
 * Applies the omitEmpty flag to all entries in the array.
 * @param entries - The entries to apply the flag to.
 * @returns A new array with the omitEmpty flag applied to all entries.
 */
export declare function allOmitEmpty(entries: Array<Omit<NamedMapEntry, 'omitEmpty'>>): NamedMapEntry[];
/**
 * Schema for a map/struct with a fixed set of known string fields.
 */
export declare class NamedMapSchema extends Schema {
    private readonly entries;
    constructor(entries: NamedMapEntry[]);
    /**
     * Adds new entries to the map schema. WARNING: this is a mutable operation, and you should be very
     * careful when using it. Any error that happens here is non-recoverable and will corrupt the
     * NamedMapSchema object;
     * @param entries - The entries to add.
     */
    pushEntries(...entries: NamedMapEntry[]): void;
    private checkEntries;
    /**
     * Returns all top-level entries, properly accounting for fields from embedded entries.
     * @returns An array of all top-level entries for this map.
     */
    getEntries(): NamedMapEntry[];
    defaultValue(): Map<string, unknown>;
    isDefaultValue(data: unknown): boolean;
    prepareMsgpack(data: unknown): MsgpackEncodingData;
    fromPreparedMsgpack(encoded: MsgpackEncodingData, rawStringProvider: MsgpackRawStringProvider): Map<string, unknown>;
    prepareJSON(data: unknown, options: PrepareJSONOptions): JSONEncodingData;
    fromPreparedJSON(encoded: JSONEncodingData): Map<string, unknown>;
}
/**
 * Combines multiple maps into a single map. Throws an error if any of the maps have duplicate keys.
 * @param maps - The maps to combine.
 * @returns A new map with all the entries from the input maps.
 */
export declare function combineMaps<K, V>(...maps: Array<Map<K, V>>): Map<K, V>;
/**
 * Converts a map to a new map with different keys and values.
 * @param map - The map to convert.
 * @param func - The function to convert each entry.
 * @returns A new map with the converted entries.
 */
export declare function convertMap<K1, V1, K2, V2>(map: Map<K1, V1>, func: (k: K1, v: V1) => [K2, V2]): Map<K2, V2>;
/**
 * Schema for a map with a variable number of uint64 keys.
 */
export declare class Uint64MapSchema extends Schema {
    readonly valueSchema: Schema;
    constructor(valueSchema: Schema);
    defaultValue(): Map<bigint, unknown>;
    isDefaultValue(data: unknown): boolean;
    prepareMsgpack(data: unknown): MsgpackEncodingData;
    fromPreparedMsgpack(encoded: MsgpackEncodingData, rawStringProvider: MsgpackRawStringProvider): Map<bigint, unknown>;
    prepareJSON(data: unknown, options: PrepareJSONOptions): JSONEncodingData;
    fromPreparedJSON(encoded: JSONEncodingData): Map<bigint, unknown>;
}
/**
 * Schema for a map with a variable number of string keys.
 */
export declare class StringMapSchema extends Schema {
    readonly valueSchema: Schema;
    constructor(valueSchema: Schema);
    defaultValue(): Map<string, unknown>;
    isDefaultValue(data: unknown): boolean;
    prepareMsgpack(data: unknown): MsgpackEncodingData;
    fromPreparedMsgpack(encoded: MsgpackEncodingData, rawStringProvider: MsgpackRawStringProvider): Map<string, unknown>;
    prepareJSON(data: unknown, options: PrepareJSONOptions): JSONEncodingData;
    fromPreparedJSON(encoded: JSONEncodingData): Map<string, unknown>;
}
/**
 * Schema for a map with a variable number of byte array keys.
 */
export declare class ByteArrayMapSchema extends Schema {
    readonly valueSchema: Schema;
    constructor(valueSchema: Schema);
    defaultValue(): Map<Uint8Array, unknown>;
    isDefaultValue(data: unknown): boolean;
    prepareMsgpack(data: unknown): MsgpackEncodingData;
    fromPreparedMsgpack(encoded: MsgpackEncodingData, rawStringProvider: MsgpackRawStringProvider): Map<Uint8Array, unknown>;
    prepareJSON(data: unknown, options: PrepareJSONOptions): JSONEncodingData;
    fromPreparedJSON(encoded: JSONEncodingData): Map<Uint8Array, unknown>;
}
/**
 * Schema for a map with a variable number of binary string keys.
 *
 * See SpecialCaseBinaryStringSchema for more information about the key type.
 */
export declare class SpecialCaseBinaryStringMapSchema extends Schema {
    readonly valueSchema: Schema;
    constructor(valueSchema: Schema);
    defaultValue(): Map<Uint8Array, unknown>;
    isDefaultValue(data: unknown): boolean;
    prepareMsgpack(data: unknown): MsgpackEncodingData;
    fromPreparedMsgpack(_encoded: MsgpackEncodingData, rawStringProvider: MsgpackRawStringProvider): Map<Uint8Array, unknown>;
    prepareJSON(data: unknown, options: PrepareJSONOptions): JSONEncodingData;
    fromPreparedJSON(encoded: JSONEncodingData): Map<Uint8Array, unknown>;
}
