/**
 * This file is a wrapper of msgpack.js.
 * The wrapper was written in order to ensure correct encoding of Algorand Transaction and other formats.
 * In particular, it matches go-algorand blockchain client, written in go (https://www.github.com/algorand/go-algorand.
 * Algorand's msgpack encoding follows to following rules -
 *  1. Every integer must be encoded to the smallest type possible (0-255-\>8bit, 256-65535-\>16bit, etx)
 *  2. All fields names must be sorted
 *  3. All empty and 0 fields should be omitted
 *  4. Every positive number must be encoded as uint
 *  5. Binary blob should be used for binary data and string for strings
 *  */
import { RawBinaryString } from 'algorand-msgpack';
import IntDecoding from '../types/intDecoding.js';
export declare const ERROR_CONTAINS_EMPTY_STRING = "The object contains empty or 0 values. First empty or 0 value encountered during encoding: ";
/**
 * msgpackRawEncode encodes objects using msgpack, regardless of whether there are
 * empty or 0 value fields.
 * @param obj - a dictionary to be encoded. May or may not contain empty or 0 values.
 * @returns msgpack representation of the object
 */
export declare function msgpackRawEncode(obj: unknown): Uint8Array;
/**
 * encodeObj takes a javascript object and returns its msgpack encoding
 * Note that the encoding sorts the fields alphabetically
 * @param o - js object to be encoded. Must not contain empty or 0 values.
 * @returns Uint8Array binary representation
 * @throws Error containing ERROR_CONTAINS_EMPTY_STRING if the object contains empty or zero values
 *
 * @deprecated Use {@link msgpackRawEncode} instead. Note that function does not
 *   check for empty values like this one does.
 */
export declare function encodeObj(obj: Record<string | number | symbol, any>): Uint8Array;
/**
 * Decodes msgpack bytes into a plain JavaScript object.
 * @param buffer - The msgpack bytes to decode
 * @param options - Options for decoding, including int decoding mode. See {@link IntDecoding} for more information.
 * @returns The decoded object
 */
export declare function msgpackRawDecode(buffer: ArrayLike<number>, options?: {
    intDecoding: IntDecoding;
}): unknown;
/**
 * decodeObj takes a Uint8Array and returns its javascript obj
 * @param o - Uint8Array to decode
 * @returns object
 *
 * @deprecated Use {@link msgpackRawDecode} instead. Note that this function uses `IntDecoding.MIXED`
 *   while `msgpackRawDecode` defaults to `IntDecoding.BIGINT` for int decoding, though it is
 *   configurable.
 */
export declare function decodeObj(o: ArrayLike<number>): unknown;
/**
 * Decodes msgpack bytes into a Map object. This supports decoding non-string map keys.
 * @param encoded - The msgpack bytes to decode
 * @param options - Options for decoding, including int decoding mode. See {@link IntDecoding} for more information.
 * @returns The decoded Map object
 */
export declare function msgpackRawDecodeAsMap(encoded: ArrayLike<number>, options?: {
    intDecoding: IntDecoding;
}): unknown;
export type MsgpackEncodingData = null | undefined | string | number | bigint | boolean | Uint8Array | MsgpackEncodingData[] | Map<string | number | bigint | Uint8Array, MsgpackEncodingData>;
export type JSONEncodingData = null | undefined | string | number | bigint | boolean | JSONEncodingData[] | {
    [key: string]: JSONEncodingData;
};
export declare function msgpackEncodingDataToJSONEncodingData(e: MsgpackEncodingData): JSONEncodingData;
export declare function jsonEncodingDataToMsgpackEncodingData(e: JSONEncodingData): MsgpackEncodingData;
declare enum MsgpackObjectPathSegmentKind {
    MAP_VALUE = 0,
    ARRAY_ELEMENT = 1
}
interface MsgpackObjectPathSegment {
    kind: MsgpackObjectPathSegmentKind;
    key: string | number | bigint | Uint8Array | RawBinaryString;
}
/**
 * This class is used to index into an encoded msgpack object and extract raw strings.
 */
export declare class MsgpackRawStringProvider {
    private readonly parent?;
    private readonly baseObjectBytes?;
    private readonly segment?;
    private resolvedCache;
    private resolvedCachePresent;
    constructor({ parent, segment, baseObjectBytes, }: {
        parent: MsgpackRawStringProvider;
        segment: MsgpackObjectPathSegment;
        baseObjectBytes?: undefined;
    } | {
        parent?: undefined;
        segment?: undefined;
        baseObjectBytes: ArrayLike<number>;
    });
    /**
     * Create a new provider that resolves to the current provider's map value at the given key.
     */
    withMapValue(key: string | number | bigint | Uint8Array | RawBinaryString): MsgpackRawStringProvider;
    /**
     * Create a new provider that resolves to the current provider's array element at the given index.
     */
    withArrayElement(index: number): MsgpackRawStringProvider;
    /**
     * Get the raw string at the current location. If the current location is not a raw string, an error is thrown.
     */
    getRawStringAtCurrentLocation(): Uint8Array;
    /**
     * Get the raw string map keys and values at the current location. If the current location is not a map, an error is thrown.
     */
    getRawStringKeysAndValuesAtCurrentLocation(): Map<Uint8Array, MsgpackEncodingData>;
    /**
     * Resolve the provider by extracting the value it indicates from the base msgpack object.
     */
    private resolve;
    /**
     * Get the path string of the current location indicated by the provider. Useful for debugging.
     */
    getPathString(): string;
}
/**
 * Options for {@link Schema.prepareJSON}
 */
export interface PrepareJSONOptions {
    /**
     * If true, allows invalid UTF-8 binary strings to be converted to JSON strings.
     *
     * Otherwise, an error will be thrown if encoding a binary string to a JSON cannot be done losslessly.
     */
    lossyBinaryStringConversion?: boolean;
}
/**
 * A Schema is used to prepare objects for encoding and decoding from msgpack and JSON.
 *
 * Schemas represent a specific type.
 */
export declare abstract class Schema {
    /**
     * Get the default value for this type.
     */
    abstract defaultValue(): unknown;
    /**
     * Checks if the value is the default value for this type.
     * @param data - The value to check
     * @returns True if the value is the default value, false otherwise
     */
    abstract isDefaultValue(data: unknown): boolean;
    /**
     * Prepares the encoding data for encoding to msgpack.
     * @param data - Encoding data to be prepared.
     * @returns A value ready to be msgpack encoded.
     */
    abstract prepareMsgpack(data: unknown): MsgpackEncodingData;
    /**
     * Restores the encoding data from a msgpack encoding object.
     * @param encoded - The msgpack encoding object to restore.
     * @param rawStringProvider - A provider for raw strings.
     * @returns The original encoding data.
     */
    abstract fromPreparedMsgpack(encoded: MsgpackEncodingData, rawStringProvider: MsgpackRawStringProvider): unknown;
    /**
     * Prepares the encoding data for encoding to JSON.
     * @param data - The JSON encoding data to be prepared.
     * @returns A value ready to be JSON encoded.
     */
    abstract prepareJSON(data: unknown, options: PrepareJSONOptions): JSONEncodingData;
    /**
     * Restores the encoding data from a JSON encoding object.
     * @param encoded - The JSON encoding object to restore.
     * @returns The original encoding data.
     */
    abstract fromPreparedJSON(encoded: JSONEncodingData): unknown;
}
/**
 * An interface for objects that can be encoded and decoded to/from msgpack and JSON.
 */
export interface Encodable {
    /**
     * Extract the encoding data for this object. This data, after being prepared by the encoding
     * Schema, can be encoded to msgpack or JSON.
     */
    toEncodingData(): unknown;
    /**
     * Get the encoding Schema for this object, used to prepare the encoding data for msgpack and JSON.
     */
    getEncodingSchema(): Schema;
}
/**
 * A type that represents the class of an Encodable object.
 */
export interface EncodableClass<T extends Encodable> {
    /**
     * Create a new instance of this class from the given encoding data.
     * @param data - The encoding data to create the object from
     */
    fromEncodingData(data: unknown): T;
    /**
     * The encoding Schema for this class, used to prepare encoding data from msgpack and JSON.
     */
    readonly encodingSchema: Schema;
}
/**
 * Decode a msgpack byte array to an Encodable object.
 * @param encoded - The msgpack bytes to decode
 * @param c - The class of the object to decode. This class must match the object that was encoded.
 * @returns An instance of the class with the decoded data
 */
export declare function decodeMsgpack<T extends Encodable>(encoded: ArrayLike<number>, c: EncodableClass<T>): T;
/**
 * Encode an Encodable object to a msgpack byte array.
 * @param e - The object to encode
 * @returns A msgpack byte array encoding of the object
 */
export declare function encodeMsgpack(e: Encodable): Uint8Array;
/**
 * Decode a JSON string to an Encodable object.
 * @param encoded - The JSON string to decode
 * @param c - The class of the object to decode. This class must match the object that was encoded.
 * @returns An instance of the class with the decoded data
 */
export declare function decodeJSON<T extends Encodable>(encoded: string, c: EncodableClass<T>): T;
export interface EncodeJSONOptions {
    /**
     * Adds indentation, white space, and line break characters to the return-value JSON text to make
     * it easier to read.
     */
    space?: string | number;
    /**
     * If true, allows invalid UTF-8 binary strings to be converted to JSON strings.
     *
     * Otherwise, an error will be thrown if encoding a binary string to a JSON cannot be done losslessly.
     */
    lossyBinaryStringConversion?: boolean;
}
/**
 * Encode an Encodable object to a JSON string.
 * @param e - The object to encode
 * @param options - Optional encoding options. See {@link EncodeJSONOptions} for more information.
 * @returns A JSON string encoding of the object
 */
export declare function encodeJSON(e: Encodable, options?: EncodeJSONOptions): string;
export {};
