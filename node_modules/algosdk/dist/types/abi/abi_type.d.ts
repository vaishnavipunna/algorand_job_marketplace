/**
    //ABI-Types: uint<N>: An N-bit unsigned integer (8 <= N <= 512 and N % 8 = 0).
    // | byte (alias for uint8)
    // | ufixed <N> x <M> (8 <= N <= 512, N % 8 = 0, and 0 < M <= 160)
    // | bool
    // | address (alias for byte[32])
    // | <type> [<N>]
    // | <type> []
    // | string
    // | (T1, ..., Tn)
*/
import { Address } from '../encoding/address.js';
export declare const MAX_LEN: number;
export declare const ADDR_BYTE_SIZE = 32;
export declare const SINGLE_BYTE_SIZE = 1;
export declare const SINGLE_BOOL_SIZE = 1;
export declare const LENGTH_ENCODE_BYTE_SIZE = 2;
export type ABIValue = boolean | number | bigint | string | Uint8Array | ABIValue[] | Address;
export declare abstract class ABIType {
    abstract toString(): string;
    abstract equals(other: ABIType): boolean;
    abstract isDynamic(): boolean;
    abstract byteLen(): number;
    abstract encode(value: ABIValue): Uint8Array;
    abstract decode(byteString: Uint8Array): ABIValue;
    static from(str: string): ABIType;
}
export declare class ABIUintType extends ABIType {
    bitSize: number;
    constructor(size: number);
    toString(): string;
    equals(other: ABIType): boolean;
    isDynamic(): boolean;
    byteLen(): number;
    encode(value: ABIValue): Uint8Array;
    decode(byteString: Uint8Array): bigint;
}
export declare class ABIUfixedType extends ABIType {
    bitSize: number;
    precision: number;
    constructor(size: number, denominator: number);
    toString(): string;
    equals(other: ABIType): boolean;
    isDynamic(): boolean;
    byteLen(): number;
    encode(value: ABIValue): Uint8Array;
    decode(byteString: Uint8Array): bigint;
}
export declare class ABIAddressType extends ABIType {
    toString(): string;
    equals(other: ABIType): boolean;
    isDynamic(): boolean;
    byteLen(): number;
    encode(value: ABIValue): Uint8Array;
    decode(byteString: Uint8Array): string;
}
export declare class ABIBoolType extends ABIType {
    toString(): string;
    equals(other: ABIType): boolean;
    isDynamic(): boolean;
    byteLen(): number;
    encode(value: ABIValue): Uint8Array;
    decode(byteString: Uint8Array): boolean;
}
export declare class ABIByteType extends ABIType {
    toString(): string;
    equals(other: ABIType): boolean;
    isDynamic(): boolean;
    byteLen(): number;
    encode(value: ABIValue): Uint8Array;
    decode(byteString: Uint8Array): number;
}
export declare class ABIStringType extends ABIType {
    toString(): string;
    equals(other: ABIType): boolean;
    isDynamic(): boolean;
    byteLen(): never;
    encode(value: ABIValue): Uint8Array;
    decode(byteString: Uint8Array): string;
}
export declare class ABIArrayStaticType extends ABIType {
    childType: ABIType;
    staticLength: number;
    constructor(argType: ABIType, arrayLength: number);
    toString(): string;
    equals(other: ABIType): boolean;
    isDynamic(): boolean;
    byteLen(): number;
    encode(value: ABIValue): Uint8Array;
    decode(byteString: Uint8Array): ABIValue[];
    toABITupleType(): ABITupleType;
}
export declare class ABIArrayDynamicType extends ABIType {
    childType: ABIType;
    constructor(argType: ABIType);
    toString(): string;
    equals(other: ABIType): boolean;
    isDynamic(): boolean;
    byteLen(): never;
    encode(value: ABIValue): Uint8Array;
    decode(byteString: Uint8Array): ABIValue[];
    toABITupleType(length: number): ABITupleType;
}
export declare class ABITupleType extends ABIType {
    childTypes: ABIType[];
    constructor(argTypes: ABIType[]);
    toString(): string;
    equals(other: ABIType): boolean;
    isDynamic(): boolean;
    byteLen(): number;
    encode(value: ABIValue): Uint8Array;
    decode(byteString: Uint8Array): ABIValue[];
    static parseTupleContent(str: string): string[];
}
