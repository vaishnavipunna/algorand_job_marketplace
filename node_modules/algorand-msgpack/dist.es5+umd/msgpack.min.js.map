{"version":3,"file":"msgpack.min.js","mappings":"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","sources":["webpack://MessagePack/webpack/universalModuleDefinition","webpack://MessagePack/webpack/bootstrap","webpack://MessagePack/webpack/runtime/define property getters","webpack://MessagePack/webpack/runtime/hasOwnProperty shorthand","webpack://MessagePack/webpack/runtime/make namespace object","webpack://MessagePack/./src/utils/utf8.ts","webpack://MessagePack/./src/ExtData.ts","webpack://MessagePack/./src/utils/int.ts","webpack://MessagePack/./src/DecodeError.ts","webpack://MessagePack/./src/timestamp.ts","webpack://MessagePack/./src/ExtensionCodec.ts","webpack://MessagePack/./src/utils/typedArrays.ts","webpack://MessagePack/./src/Encoder.ts","webpack://MessagePack/./src/encode.ts","webpack://MessagePack/./src/utils/prettyByte.ts","webpack://MessagePack/./src/CachedKeyDecoder.ts","webpack://MessagePack/./src/Decoder.ts","webpack://MessagePack/./src/decode.ts","webpack://MessagePack/./src/utils/stream.ts","webpack://MessagePack/./src/decodeAsync.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"MessagePack\"] = factory();\n\telse\n\t\troot[\"MessagePack\"] = factory();\n})(this, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export function utf8Count(str: string): number {\n  const strLength = str.length;\n\n  let byteLength = 0;\n  let pos = 0;\n  while (pos < strLength) {\n    let value = str.charCodeAt(pos++);\n\n    if ((value & 0xffffff80) === 0) {\n      // 1-byte\n      byteLength++;\n      continue;\n    } else if ((value & 0xfffff800) === 0) {\n      // 2-bytes\n      byteLength += 2;\n    } else {\n      // handle surrogate pair\n      if (value >= 0xd800 && value <= 0xdbff) {\n        // high surrogate\n        if (pos < strLength) {\n          const extra = str.charCodeAt(pos);\n          if ((extra & 0xfc00) === 0xdc00) {\n            ++pos;\n            value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n          }\n        }\n      }\n\n      if ((value & 0xffff0000) === 0) {\n        // 3-byte\n        byteLength += 3;\n      } else {\n        // 4-byte\n        byteLength += 4;\n      }\n    }\n  }\n  return byteLength;\n}\n\nexport function utf8EncodeJs(str: string, output: Uint8Array, outputOffset: number): void {\n  const strLength = str.length;\n  let offset = outputOffset;\n  let pos = 0;\n  while (pos < strLength) {\n    let value = str.charCodeAt(pos++);\n\n    if ((value & 0xffffff80) === 0) {\n      // 1-byte\n      output[offset++] = value;\n      continue;\n    } else if ((value & 0xfffff800) === 0) {\n      // 2-bytes\n      output[offset++] = ((value >> 6) & 0x1f) | 0xc0;\n    } else {\n      // handle surrogate pair\n      if (value >= 0xd800 && value <= 0xdbff) {\n        // high surrogate\n        if (pos < strLength) {\n          const extra = str.charCodeAt(pos);\n          if ((extra & 0xfc00) === 0xdc00) {\n            ++pos;\n            value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n          }\n        }\n      }\n\n      if ((value & 0xffff0000) === 0) {\n        // 3-byte\n        output[offset++] = ((value >> 12) & 0x0f) | 0xe0;\n        output[offset++] = ((value >> 6) & 0x3f) | 0x80;\n      } else {\n        // 4-byte\n        output[offset++] = ((value >> 18) & 0x07) | 0xf0;\n        output[offset++] = ((value >> 12) & 0x3f) | 0x80;\n        output[offset++] = ((value >> 6) & 0x3f) | 0x80;\n      }\n    }\n\n    output[offset++] = (value & 0x3f) | 0x80;\n  }\n}\n\n// TextEncoder and TextDecoder are standardized in whatwg encoding:\n// https://encoding.spec.whatwg.org/\n// and available in all the modern browsers:\n// https://caniuse.com/textencoder\n// They are available in Node.js since v12 LTS as well:\n// https://nodejs.org/api/globals.html#textencoder\n\nconst sharedTextEncoder = new TextEncoder();\n\n// This threshold should be determined by benchmarking, which might vary in engines and input data.\n// Run `npx ts-node benchmark/encode-string.ts` for details.\nconst TEXT_ENCODER_THRESHOLD = 50;\n\nexport function utf8EncodeTE(str: string, output: Uint8Array, outputOffset: number): void {\n  sharedTextEncoder.encodeInto(str, output.subarray(outputOffset));\n}\n\nexport function utf8Encode(str: string, output: Uint8Array, outputOffset: number): void {\n  if (str.length > TEXT_ENCODER_THRESHOLD) {\n    utf8EncodeTE(str, output, outputOffset);\n  } else {\n    utf8EncodeJs(str, output, outputOffset);\n  }\n}\n\nconst CHUNK_SIZE = 0x1_000;\n\nexport function utf8DecodeJs(bytes: Uint8Array, inputOffset: number, byteLength: number): string {\n  let offset = inputOffset;\n  const end = offset + byteLength;\n\n  const units: Array<number> = [];\n  let result = \"\";\n  while (offset < end) {\n    const byte1 = bytes[offset++]!;\n    if ((byte1 & 0x80) === 0) {\n      // 1 byte\n      units.push(byte1);\n    } else if ((byte1 & 0xe0) === 0xc0) {\n      // 2 bytes\n      const byte2 = bytes[offset++]! & 0x3f;\n      units.push(((byte1 & 0x1f) << 6) | byte2);\n    } else if ((byte1 & 0xf0) === 0xe0) {\n      // 3 bytes\n      const byte2 = bytes[offset++]! & 0x3f;\n      const byte3 = bytes[offset++]! & 0x3f;\n      units.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3);\n    } else if ((byte1 & 0xf8) === 0xf0) {\n      // 4 bytes\n      const byte2 = bytes[offset++]! & 0x3f;\n      const byte3 = bytes[offset++]! & 0x3f;\n      const byte4 = bytes[offset++]! & 0x3f;\n      let unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4;\n      if (unit > 0xffff) {\n        unit -= 0x10000;\n        units.push(((unit >>> 10) & 0x3ff) | 0xd800);\n        unit = 0xdc00 | (unit & 0x3ff);\n      }\n      units.push(unit);\n    } else {\n      units.push(byte1);\n    }\n\n    if (units.length >= CHUNK_SIZE) {\n      result += String.fromCharCode(...units);\n      units.length = 0;\n    }\n  }\n\n  if (units.length > 0) {\n    result += String.fromCharCode(...units);\n  }\n\n  return result;\n}\n\nconst sharedTextDecoder = new TextDecoder();\n\n// This threshold should be determined by benchmarking, which might vary in engines and input data.\n// Run `npx ts-node benchmark/decode-string.ts` for details.\nconst TEXT_DECODER_THRESHOLD = 200;\n\nexport function utf8DecodeTD(bytes: Uint8Array, inputOffset: number, byteLength: number): string {\n  const stringBytes = bytes.subarray(inputOffset, inputOffset + byteLength);\n  return sharedTextDecoder.decode(stringBytes);\n}\n\nexport function utf8Decode(bytes: Uint8Array, inputOffset: number, byteLength: number): string {\n  if (byteLength > TEXT_DECODER_THRESHOLD) {\n    return utf8DecodeTD(bytes, inputOffset, byteLength);\n  } else {\n    return utf8DecodeJs(bytes, inputOffset, byteLength);\n  }\n}\n","/**\n * ExtData is used to handle Extension Types that are not registered to ExtensionCodec.\n */\nexport class ExtData {\n  constructor(\n    readonly type: number,\n    readonly data: Uint8Array,\n  ) {}\n}\n","// Integer Utility\n\n/**\n * An enum of different options for decoding integers.\n */\nexport enum IntMode {\n  /**\n   * Always returns the value as a number. Be aware that there will be a loss of precision if the\n   * value is outside the range of Number.MIN_SAFE_INTEGER to Number.MAX_SAFE_INTEGER.\n   */\n  UNSAFE_NUMBER,\n  /**\n   * Always returns the value as a number, but throws an error if the value is outside of the range\n   * of Number.MIN_SAFE_INTEGER to Number.MAX_SAFE_INTEGER.\n   */\n  SAFE_NUMBER,\n  /**\n   * Returns all values encoded as int64/uint64 as bigints and all other integers as numbers.\n   */\n  AS_ENCODED,\n  /**\n   * Returns all values inside the range of Number.MIN_SAFE_INTEGER to Number.MAX_SAFE_INTEGER as\n   * numbers and all values outside that range as bigints.\n   */\n  MIXED,\n  /**\n   * Always returns the value as a bigint, even if it is small enough to safely fit in a number.\n   */\n  BIGINT,\n}\n\nexport const UINT32_MAX = 0xffff_ffff;\n\n// DataView extension to handle int64 / uint64,\n// where the actual range is 53-bits integer (a.k.a. safe integer)\n\nexport function setUint64(view: DataView, offset: number, value: number): void {\n  const high = value / 0x1_0000_0000;\n  const low = value; // high bits are truncated by DataView\n  view.setUint32(offset, high);\n  view.setUint32(offset + 4, low);\n}\n\nexport function setInt64(view: DataView, offset: number, value: number): void {\n  const high = Math.floor(value / 0x1_0000_0000);\n  const low = value; // high bits are truncated by DataView\n  view.setUint32(offset, high);\n  view.setUint32(offset + 4, low);\n}\n\nexport function getInt64(view: DataView, offset: number, mode: IntMode.UNSAFE_NUMBER | IntMode.SAFE_NUMBER): number;\nexport function getInt64(view: DataView, offset: number, mode: IntMode.BIGINT): bigint;\nexport function getInt64(view: DataView, offset: number, mode: IntMode): number | bigint;\nexport function getInt64(view: DataView, offset: number, mode: IntMode): number | bigint {\n  if (mode === IntMode.UNSAFE_NUMBER || mode === IntMode.SAFE_NUMBER) {\n    // for compatibility, don't use view.getBigInt64 if the user hasn't told us to use BigInts\n    const high = view.getInt32(offset);\n    const low = view.getUint32(offset + 4);\n\n    if (\n      mode === IntMode.SAFE_NUMBER &&\n      (high < Math.floor(Number.MIN_SAFE_INTEGER / 0x1_0000_0000) ||\n        (high === Math.floor(Number.MIN_SAFE_INTEGER / 0x1_0000_0000) && low === 0) ||\n        high > (Number.MAX_SAFE_INTEGER - low) / 0x1_0000_0000)\n    ) {\n      const hexValue = `${high < 0 ? \"-\" : \"\"}0x${Math.abs(high).toString(16)}${low.toString(16).padStart(8, \"0\")}`;\n      throw new Error(`Mode is IntMode.SAFE_NUMBER and value is not a safe integer: ${hexValue}`);\n    }\n\n    return high * 0x1_0000_0000 + low;\n  }\n\n  const value = view.getBigInt64(offset);\n\n  if (mode === IntMode.MIXED && value >= Number.MIN_SAFE_INTEGER && value <= Number.MAX_SAFE_INTEGER) {\n    return Number(value);\n  }\n\n  return value;\n}\n\nexport function getUint64(view: DataView, offset: number, mode: IntMode.UNSAFE_NUMBER | IntMode.SAFE_NUMBER): number;\nexport function getUint64(view: DataView, offset: number, mode: IntMode.BIGINT): bigint;\nexport function getUint64(view: DataView, offset: number, mode: IntMode): number | bigint;\nexport function getUint64(view: DataView, offset: number, mode: IntMode): number | bigint {\n  if (mode === IntMode.UNSAFE_NUMBER || mode === IntMode.SAFE_NUMBER) {\n    // for compatibility, don't use view.getBigUint64 if the user hasn't told us to use BigInts\n    const high = view.getUint32(offset);\n    const low = view.getUint32(offset + 4);\n\n    if (mode === IntMode.SAFE_NUMBER && high > (Number.MAX_SAFE_INTEGER - low) / 0x1_0000_0000) {\n      const hexValue = `0x${high.toString(16)}${low.toString(16).padStart(8, \"0\")}`;\n      throw new Error(`Mode is IntMode.SAFE_NUMBER and value is not a safe integer: ${hexValue}`);\n    }\n\n    return high * 0x1_0000_0000 + low;\n  }\n\n  const value = view.getBigUint64(offset);\n\n  if (mode === IntMode.MIXED && value <= Number.MAX_SAFE_INTEGER) {\n    return Number(value);\n  }\n\n  return value;\n}\n\n/**\n * Convert a safe integer Number (i.e. in the range Number.MIN_SAFE_INTEGER to Number.MAX_SAFE_INTEGER)\n * with respect to the given IntMode. For all modes except IntMode.BIGINT, this returns the original\n * Number unmodified.\n */\nexport function convertSafeIntegerToMode(value: number, mode: IntMode): number | bigint {\n  if (mode === IntMode.BIGINT) {\n    return BigInt(value);\n  }\n\n  return Number(value);\n}\n","export class DecodeError extends Error {\n  constructor(message: string) {\n    super(message);\n\n    // fix the prototype chain in a cross-platform way\n    const proto: typeof DecodeError.prototype = Object.create(DecodeError.prototype);\n    Object.setPrototypeOf(this, proto);\n\n    Object.defineProperty(this, \"name\", {\n      configurable: true,\n      enumerable: false,\n      value: DecodeError.name,\n    });\n  }\n}\n","// https://github.com/msgpack/msgpack/blob/master/spec.md#timestamp-extension-type\nimport { DecodeError } from \"./DecodeError\";\nimport { IntMode, getInt64, setInt64 } from \"./utils/int\";\n\nexport const EXT_TIMESTAMP = -1;\n\nexport type TimeSpec = {\n  sec: number;\n  nsec: number;\n};\n\nconst TIMESTAMP32_MAX_SEC = 0x100000000 - 1; // 32-bit unsigned int\nconst TIMESTAMP64_MAX_SEC = 0x400000000 - 1; // 34-bit unsigned int\n\nexport function encodeTimeSpecToTimestamp({ sec, nsec }: TimeSpec): Uint8Array {\n  if (sec >= 0 && nsec >= 0 && sec <= TIMESTAMP64_MAX_SEC) {\n    // Here sec >= 0 && nsec >= 0\n    if (nsec === 0 && sec <= TIMESTAMP32_MAX_SEC) {\n      // timestamp 32 = { sec32 (unsigned) }\n      const rv = new Uint8Array(4);\n      const view = new DataView(rv.buffer);\n      view.setUint32(0, sec);\n      return rv;\n    } else {\n      // timestamp 64 = { nsec30 (unsigned), sec34 (unsigned) }\n      const secHigh = sec / 0x100000000;\n      const secLow = sec & 0xffffffff;\n      const rv = new Uint8Array(8);\n      const view = new DataView(rv.buffer);\n      // nsec30 | secHigh2\n      view.setUint32(0, (nsec << 2) | (secHigh & 0x3));\n      // secLow32\n      view.setUint32(4, secLow);\n      return rv;\n    }\n  } else {\n    // timestamp 96 = { nsec32 (unsigned), sec64 (signed) }\n    const rv = new Uint8Array(12);\n    const view = new DataView(rv.buffer);\n    view.setUint32(0, nsec);\n    setInt64(view, 4, sec);\n    return rv;\n  }\n}\n\nexport function encodeDateToTimeSpec(date: Date): TimeSpec {\n  const msec = date.getTime();\n  const sec = Math.floor(msec / 1e3);\n  const nsec = (msec - sec * 1e3) * 1e6;\n\n  // Normalizes { sec, nsec } to ensure nsec is unsigned.\n  const nsecInSec = Math.floor(nsec / 1e9);\n  return {\n    sec: sec + nsecInSec,\n    nsec: nsec - nsecInSec * 1e9,\n  };\n}\n\nexport function encodeTimestampExtension(object: unknown): Uint8Array | null {\n  if (object instanceof Date) {\n    const timeSpec = encodeDateToTimeSpec(object);\n    return encodeTimeSpecToTimestamp(timeSpec);\n  } else {\n    return null;\n  }\n}\n\nexport function decodeTimestampToTimeSpec(data: Uint8Array): TimeSpec {\n  const view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n\n  // data may be 32, 64, or 96 bits\n  switch (data.byteLength) {\n    case 4: {\n      // timestamp 32 = { sec32 }\n      const sec = view.getUint32(0);\n      const nsec = 0;\n      return { sec, nsec };\n    }\n    case 8: {\n      // timestamp 64 = { nsec30, sec34 }\n      const nsec30AndSecHigh2 = view.getUint32(0);\n      const secLow32 = view.getUint32(4);\n      const sec = (nsec30AndSecHigh2 & 0x3) * 0x100000000 + secLow32;\n      const nsec = nsec30AndSecHigh2 >>> 2;\n      return { sec, nsec };\n    }\n    case 12: {\n      // timestamp 96 = { nsec32 (unsigned), sec64 (signed) }\n\n      const sec = getInt64(view, 4, IntMode.UNSAFE_NUMBER);\n      const nsec = view.getUint32(0);\n      return { sec, nsec };\n    }\n    default:\n      throw new DecodeError(`Unrecognized data size for timestamp (expected 4, 8, or 12): ${data.length}`);\n  }\n}\n\nexport function decodeTimestampExtension(data: Uint8Array): Date {\n  const timeSpec = decodeTimestampToTimeSpec(data);\n  return new Date(timeSpec.sec * 1e3 + timeSpec.nsec / 1e6);\n}\n\nexport const timestampExtension = {\n  type: EXT_TIMESTAMP,\n  encode: encodeTimestampExtension,\n  decode: decodeTimestampExtension,\n};\n","// ExtensionCodec to handle MessagePack extensions\n\nimport { ExtData } from \"./ExtData\";\nimport { timestampExtension } from \"./timestamp\";\n\nexport type ExtensionDecoderType<ContextType> = (\n  data: Uint8Array,\n  extensionType: number,\n  context: ContextType,\n) => unknown;\n\nexport type ExtensionEncoderType<ContextType> = (input: unknown, context: ContextType) => Uint8Array | null;\n\n// immutable interface to ExtensionCodec\nexport type ExtensionCodecType<ContextType> = {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  __brand?: ContextType;\n  tryToEncode(object: unknown, context: ContextType): ExtData | null;\n  decode(data: Uint8Array, extType: number, context: ContextType): unknown;\n};\n\nexport class ExtensionCodec<ContextType = undefined> implements ExtensionCodecType<ContextType> {\n  public static readonly defaultCodec: ExtensionCodecType<undefined> = new ExtensionCodec();\n\n  // ensures ExtensionCodecType<X> matches ExtensionCodec<X>\n  // this will make type errors a lot more clear\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  __brand?: ContextType;\n\n  // built-in extensions\n  private readonly builtInEncoders: Array<ExtensionEncoderType<ContextType> | undefined | null> = [];\n  private readonly builtInDecoders: Array<ExtensionDecoderType<ContextType> | undefined | null> = [];\n\n  // custom extensions\n  private readonly encoders: Array<ExtensionEncoderType<ContextType> | undefined | null> = [];\n  private readonly decoders: Array<ExtensionDecoderType<ContextType> | undefined | null> = [];\n\n  public constructor() {\n    this.register(timestampExtension);\n  }\n\n  public register({\n    type,\n    encode,\n    decode,\n  }: {\n    type: number;\n    encode: ExtensionEncoderType<ContextType>;\n    decode: ExtensionDecoderType<ContextType>;\n  }): void {\n    if (type >= 0) {\n      // custom extensions\n      this.encoders[type] = encode;\n      this.decoders[type] = decode;\n    } else {\n      // built-in extensions\n      const index = 1 + type;\n      this.builtInEncoders[index] = encode;\n      this.builtInDecoders[index] = decode;\n    }\n  }\n\n  public tryToEncode(object: unknown, context: ContextType): ExtData | null {\n    // built-in extensions\n    for (let i = 0; i < this.builtInEncoders.length; i++) {\n      const encodeExt = this.builtInEncoders[i];\n      if (encodeExt != null) {\n        const data = encodeExt(object, context);\n        if (data != null) {\n          const type = -1 - i;\n          return new ExtData(type, data);\n        }\n      }\n    }\n\n    // custom extensions\n    for (let i = 0; i < this.encoders.length; i++) {\n      const encodeExt = this.encoders[i];\n      if (encodeExt != null) {\n        const data = encodeExt(object, context);\n        if (data != null) {\n          const type = i;\n          return new ExtData(type, data);\n        }\n      }\n    }\n\n    if (object instanceof ExtData) {\n      // to keep ExtData as is\n      return object;\n    }\n    return null;\n  }\n\n  public decode(data: Uint8Array, type: number, context: ContextType): unknown {\n    const decodeExt = type < 0 ? this.builtInDecoders[-1 - type] : this.decoders[type];\n    if (decodeExt) {\n      return decodeExt(data, type, context);\n    } else {\n      // decode() does not fail, returns ExtData instead.\n      return new ExtData(type, data);\n    }\n  }\n}\n","export function ensureUint8Array(buffer: ArrayLike<number> | Uint8Array | ArrayBufferView | ArrayBuffer): Uint8Array {\n  if (buffer instanceof Uint8Array) {\n    return buffer;\n  } else if (ArrayBuffer.isView(buffer)) {\n    return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n  } else if (buffer instanceof ArrayBuffer) {\n    return new Uint8Array(buffer);\n  } else {\n    // ArrayLike<number>\n    return Uint8Array.from(buffer);\n  }\n}\n\nexport function createDataView(buffer: ArrayLike<number> | ArrayBufferView | ArrayBuffer): DataView {\n  if (buffer instanceof ArrayBuffer) {\n    return new DataView(buffer);\n  }\n\n  const bufferView = ensureUint8Array(buffer);\n  return new DataView(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);\n}\n\nexport function compareUint8Arrays(a: Uint8Array, b: Uint8Array): number {\n  const length = Math.min(a.length, b.length);\n  for (let i = 0; i < length; i++) {\n    const diff = a[i]! - b[i]!;\n    if (diff !== 0) {\n      return diff;\n    }\n  }\n  return a.length - b.length;\n}\n\n/**\n * Represents a binary value that should be encoded as if it were a string.\n *\n * Effectively, this is a string that has already been UTF-8 encoded to a binary string. This is\n * useful if you need to encode a value as a string, but that value contains invalid UTF-8 sequences;\n * ideally this situation should be avoided and the value should be encoded as binary, not string,\n * but this may be necessary for compatibility with non-ideal systems.\n */\nexport class RawBinaryString {\n  /**\n   * Create a new RawBinaryString from an ArrayBufferView.\n   */\n  public constructor(public readonly rawBinaryValue: ArrayBufferView) {\n    if (!ArrayBuffer.isView(rawBinaryValue)) {\n      throw new TypeError(\"RawBinaryString: rawBinaryValue must be an ArrayBufferView\");\n    }\n  }\n}\n","import { utf8Count, utf8Encode } from \"./utils/utf8\";\nimport { ExtensionCodec, ExtensionCodecType } from \"./ExtensionCodec\";\nimport { setInt64, setUint64 } from \"./utils/int\";\nimport { ensureUint8Array, compareUint8Arrays, RawBinaryString } from \"./utils/typedArrays\";\nimport type { ExtData } from \"./ExtData\";\nimport type { ContextOf } from \"./context\";\n\nexport const DEFAULT_MAX_DEPTH = 100;\nexport const DEFAULT_INITIAL_BUFFER_SIZE = 2048;\n\nexport type EncoderOptions<ContextType = undefined> = Partial<\n  Readonly<{\n    extensionCodec: ExtensionCodecType<ContextType>;\n\n    /**\n     * Encodes bigint as Int64 or Uint64 if it's set to true, regardless of the size of bigint number.\n     * {@link forceIntegerToFloat} does not affect bigint if this is enabled.\n     * Depends on ES2020's {@link DataView#setBigInt64} and\n     * {@link DataView#setBigUint64}.\n     *\n     * Defaults to false.\n     */\n    forceBigIntToInt64: boolean;\n\n    /**\n     * The maximum depth in nested objects and arrays.\n     *\n     * Defaults to 100.\n     */\n    maxDepth: number;\n\n    /**\n     * The initial size of the internal buffer.\n     *\n     * Defaults to 2048.\n     */\n    initialBufferSize: number;\n\n    /**\n     * If `true`, the keys of an object is sorted. In other words, the encoded\n     * binary is canonical and thus comparable to another encoded binary.\n     *\n     * Defaults to `false`. If enabled, it spends more time in encoding objects.\n     *\n     * If enabled, the encoder will throw an error if the NaN value is included in the keys of a\n     * map, since it is not comparable.\n     *\n     * If enabled and the keys of a map include multiple different types, each type will be sorted\n     * separately, and the order of the types will be as follows:\n     * 1. Numbers (including bigints)\n     * 2. Strings\n     * 3. Binary data\n     */\n    sortKeys: boolean;\n\n    /**\n     * If `true`, non-integer numbers are encoded in float32, not in float64 (the default).\n     *\n     * Only use it if precisions don't matter.\n     *\n     * Defaults to `false`.\n     */\n    forceFloat32: boolean;\n\n    /**\n     * If `true`, an object property with `undefined` value are ignored.\n     * e.g. `{ foo: undefined }` will be encoded as `{}`, as `JSON.stringify()` does.\n     *\n     * Defaults to `false`. If enabled, it spends more time in encoding objects.\n     */\n    ignoreUndefined: boolean;\n\n    /**\n     * If `true`, integer numbers are encoded as floating point numbers,\n     * with the `forceFloat32` option taken into account.\n     *\n     * Defaults to `false`.\n     */\n    forceIntegerToFloat: boolean;\n  }>\n> &\n  ContextOf<ContextType>;\n\nexport class Encoder<ContextType = undefined> {\n  private readonly extensionCodec: ExtensionCodecType<ContextType>;\n  private readonly context: ContextType;\n  private readonly forceBigIntToInt64: boolean;\n  private readonly maxDepth: number;\n  private readonly initialBufferSize: number;\n  private readonly sortKeys: boolean;\n  private readonly forceFloat32: boolean;\n  private readonly ignoreUndefined: boolean;\n  private readonly forceIntegerToFloat: boolean;\n\n  private pos: number;\n  private view: DataView;\n  private bytes: Uint8Array;\n\n  public constructor(options?: EncoderOptions<ContextType>) {\n    this.extensionCodec = options?.extensionCodec ?? (ExtensionCodec.defaultCodec as ExtensionCodecType<ContextType>);\n    this.context = (options as { context: ContextType } | undefined)?.context as ContextType; // needs a type assertion because EncoderOptions has no context property when ContextType is undefined\n\n    this.forceBigIntToInt64 = options?.forceBigIntToInt64 ?? false;\n    this.maxDepth = options?.maxDepth ?? DEFAULT_MAX_DEPTH;\n    this.initialBufferSize = options?.initialBufferSize ?? DEFAULT_INITIAL_BUFFER_SIZE;\n    this.sortKeys = options?.sortKeys ?? false;\n    this.forceFloat32 = options?.forceFloat32 ?? false;\n    this.ignoreUndefined = options?.ignoreUndefined ?? false;\n    this.forceIntegerToFloat = options?.forceIntegerToFloat ?? false;\n\n    this.pos = 0;\n    this.view = new DataView(new ArrayBuffer(this.initialBufferSize));\n    this.bytes = new Uint8Array(this.view.buffer);\n  }\n\n  private reinitializeState() {\n    this.pos = 0;\n  }\n\n  /**\n   * This is almost equivalent to {@link Encoder#encode}, but it returns an reference of the encoder's internal buffer and thus much faster than {@link Encoder#encode}.\n   *\n   * @returns Encodes the object and returns a shared reference the encoder's internal buffer.\n   */\n  public encodeSharedRef(object: unknown): Uint8Array {\n    this.reinitializeState();\n    this.doEncode(object, 1);\n    return this.bytes.subarray(0, this.pos);\n  }\n\n  /**\n   * @returns Encodes the object and returns a copy of the encoder's internal buffer.\n   */\n  public encode(object: unknown): Uint8Array {\n    this.reinitializeState();\n    this.doEncode(object, 1);\n    return this.bytes.slice(0, this.pos);\n  }\n\n  private doEncode(object: unknown, depth: number): void {\n    if (depth > this.maxDepth) {\n      throw new Error(`Too deep objects in depth ${depth}`);\n    }\n\n    if (object == null) {\n      this.encodeNil();\n    } else if (typeof object === \"boolean\") {\n      this.encodeBoolean(object);\n    } else if (typeof object === \"number\") {\n      this.encodeNumber(object);\n    } else if (typeof object === \"string\") {\n      this.encodeString(object);\n    } else {\n      this.encodeObject(object, depth);\n    }\n  }\n\n  private ensureBufferSizeToWrite(sizeToWrite: number) {\n    const requiredSize = this.pos + sizeToWrite;\n\n    if (this.view.byteLength < requiredSize) {\n      this.resizeBuffer(requiredSize * 2);\n    }\n  }\n\n  private resizeBuffer(newSize: number) {\n    const newBuffer = new ArrayBuffer(newSize);\n    const newBytes = new Uint8Array(newBuffer);\n    const newView = new DataView(newBuffer);\n\n    newBytes.set(this.bytes);\n\n    this.view = newView;\n    this.bytes = newBytes;\n  }\n\n  private encodeNil() {\n    this.writeU8(0xc0);\n  }\n\n  private encodeBoolean(object: boolean) {\n    if (object === false) {\n      this.writeU8(0xc2);\n    } else {\n      this.writeU8(0xc3);\n    }\n  }\n\n  private encodeNumber(object: number): void {\n    if (!this.forceIntegerToFloat && Number.isSafeInteger(object)) {\n      if (object >= 0) {\n        if (object < 0x80) {\n          // positive fixint\n          this.writeU8(object);\n        } else if (object < 0x100) {\n          // uint 8\n          this.writeU8(0xcc);\n          this.writeU8(object);\n        } else if (object < 0x10000) {\n          // uint 16\n          this.writeU8(0xcd);\n          this.writeU16(object);\n        } else if (object < 0x100000000) {\n          // uint 32\n          this.writeU8(0xce);\n          this.writeU32(object);\n        } else {\n          // uint 64\n          this.writeU8(0xcf);\n          this.writeU64(object);\n        }\n      } else {\n        if (object >= -0x20) {\n          // negative fixint\n          this.writeU8(0xe0 | (object + 0x20));\n        } else if (object >= -0x80) {\n          // int 8\n          this.writeU8(0xd0);\n          this.writeI8(object);\n        } else if (object >= -0x8000) {\n          // int 16\n          this.writeU8(0xd1);\n          this.writeI16(object);\n        } else if (object >= -0x80000000) {\n          // int 32\n          this.writeU8(0xd2);\n          this.writeI32(object);\n        } else {\n          // int 64\n          this.writeU8(0xd3);\n          this.writeI64(object);\n        }\n      }\n    } else {\n      this.encodeNumberAsFloat(object);\n    }\n  }\n\n  private encodeNumberAsFloat(object: number): void {\n    if (this.forceFloat32) {\n      // float 32\n      this.writeU8(0xca);\n      this.writeF32(object);\n    } else {\n      // float 64\n      this.writeU8(0xcb);\n      this.writeF64(object);\n    }\n  }\n\n  private encodeBigInt(object: bigint) {\n    if (this.forceBigIntToInt64) {\n      this.encodeBigIntAsInt64(object);\n    } else if (object >= 0) {\n      if (object < 0x100000000 || this.forceIntegerToFloat) {\n        // uint 32 or lower, or force to float\n        this.encodeNumber(Number(object));\n      } else if (object < BigInt(\"0x10000000000000000\")) {\n        // uint 64\n        this.encodeBigIntAsInt64(object);\n      } else {\n        throw new Error(`Bigint is too large for uint64: ${object}`);\n      }\n    } else {\n      if (object >= -0x80000000 || this.forceIntegerToFloat) {\n        // int 32 or lower, or force to float\n        this.encodeNumber(Number(object));\n      } else if (object >= BigInt(-1) * BigInt(\"0x8000000000000000\")) {\n        // int 64\n        this.encodeBigIntAsInt64(object);\n      } else {\n        throw new Error(`Bigint is too small for int64: ${object}`);\n      }\n    }\n  }\n\n  private encodeBigIntAsInt64(object: bigint): void {\n    if (object >= BigInt(0)) {\n      // uint 64\n      this.writeU8(0xcf);\n      this.writeBigUint64(object);\n    } else {\n      // int 64\n      this.writeU8(0xd3);\n      this.writeBigInt64(object);\n    }\n  }\n\n  private writeStringHeader(byteLength: number) {\n    if (byteLength < 32) {\n      // fixstr\n      this.writeU8(0xa0 + byteLength);\n    } else if (byteLength < 0x100) {\n      // str 8\n      this.writeU8(0xd9);\n      this.writeU8(byteLength);\n    } else if (byteLength < 0x10000) {\n      // str 16\n      this.writeU8(0xda);\n      this.writeU16(byteLength);\n    } else if (byteLength < 0x100000000) {\n      // str 32\n      this.writeU8(0xdb);\n      this.writeU32(byteLength);\n    } else {\n      throw new Error(`Too long string: ${byteLength} bytes in UTF-8`);\n    }\n  }\n\n  private encodeString(object: string) {\n    const maxHeaderSize = 1 + 4;\n\n    const byteLength = utf8Count(object);\n    this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);\n    this.writeStringHeader(byteLength);\n    utf8Encode(object, this.bytes, this.pos);\n    this.pos += byteLength;\n  }\n\n  private encodeObject(object: unknown, depth: number) {\n    // try to encode objects with custom codec first of non-primitives\n    const ext = this.extensionCodec.tryToEncode(object, this.context);\n    if (ext != null) {\n      this.encodeExtension(ext);\n    } else if (Array.isArray(object)) {\n      this.encodeArray(object, depth);\n    } else if (ArrayBuffer.isView(object)) {\n      this.encodeBinary(object);\n    } else if (object instanceof RawBinaryString) {\n      this.encodeBinaryAsString(object);\n    } else if (typeof object === \"bigint\") {\n      // this is here instead of in doEncode so that we can try encoding with an extension first,\n      // otherwise we would break existing extensions for bigints\n      this.encodeBigInt(object);\n    } else if (object instanceof Map) {\n      this.encodeMap(object, depth);\n    } else if (typeof object === \"object\") {\n      this.encodeMapObject(object as Record<string, unknown>, depth);\n    } else {\n      // symbol, function and other special object come here unless extensionCodec handles them.\n      throw new Error(`Unrecognized object: ${Object.prototype.toString.apply(object)}`);\n    }\n  }\n\n  private encodeBinary(object: ArrayBufferView) {\n    const size = object.byteLength;\n    if (size < 0x100) {\n      // bin 8\n      this.writeU8(0xc4);\n      this.writeU8(size);\n    } else if (size < 0x10000) {\n      // bin 16\n      this.writeU8(0xc5);\n      this.writeU16(size);\n    } else if (size < 0x100000000) {\n      // bin 32\n      this.writeU8(0xc6);\n      this.writeU32(size);\n    } else {\n      throw new Error(`Too large binary: ${size}`);\n    }\n    const bytes = ensureUint8Array(object);\n    this.writeU8a(bytes);\n  }\n\n  private encodeBinaryAsString(binaryString: RawBinaryString) {\n    const object = binaryString.rawBinaryValue;\n    this.writeStringHeader(object.byteLength);\n    const bytes = ensureUint8Array(object);\n    this.writeU8a(bytes);\n  }\n\n  private encodeArray(object: Array<unknown>, depth: number) {\n    const size = object.length;\n    if (size < 16) {\n      // fixarray\n      this.writeU8(0x90 + size);\n    } else if (size < 0x10000) {\n      // array 16\n      this.writeU8(0xdc);\n      this.writeU16(size);\n    } else if (size < 0x100000000) {\n      // array 32\n      this.writeU8(0xdd);\n      this.writeU32(size);\n    } else {\n      throw new Error(`Too large array: ${size}`);\n    }\n    for (const item of object) {\n      this.doEncode(item, depth + 1);\n    }\n  }\n\n  private countWithoutUndefined(map: Map<unknown, unknown>, keys: ReadonlyArray<unknown>): number {\n    let count = 0;\n\n    for (const key of keys) {\n      if (map.get(key) !== undefined) {\n        count++;\n      }\n    }\n\n    return count;\n  }\n\n  private sortMapKeys(keys: Array<unknown>): Array<unknown> {\n    const numericKeys: Array<number | bigint> = [];\n    const stringKeys: Array<string> = [];\n    const rawStringKeys: Array<RawBinaryString> = [];\n    const binaryKeys: Array<Uint8Array> = [];\n    for (const key of keys) {\n      if (typeof key === \"number\") {\n        if (isNaN(key)) {\n          throw new Error(\"Cannot sort map keys with NaN value\");\n        }\n        numericKeys.push(key);\n      } else if (typeof key === \"bigint\") {\n        numericKeys.push(key);\n      } else if (typeof key === \"string\") {\n        stringKeys.push(key);\n      } else if (ArrayBuffer.isView(key)) {\n        binaryKeys.push(ensureUint8Array(key));\n      } else if (key instanceof RawBinaryString) {\n        rawStringKeys.push(key);\n      } else {\n        throw new Error(`Unsupported map key type: ${Object.prototype.toString.apply(key)}`);\n      }\n    }\n    numericKeys.sort((a, b) => (a < b ? -1 : a > b ? 1 : 0)); // Avoid using === to compare numbers and bigints\n    stringKeys.sort();\n    rawStringKeys.sort((a, b) =>\n      compareUint8Arrays(ensureUint8Array(a.rawBinaryValue), ensureUint8Array(b.rawBinaryValue)),\n    );\n    binaryKeys.sort(compareUint8Arrays);\n    // At the moment this arbitrarily orders the keys as numeric, string, raw string, binary\n    return ([] as Array<unknown>).concat(numericKeys, stringKeys, rawStringKeys, binaryKeys);\n  }\n\n  private encodeMapObject(object: Record<string, unknown>, depth: number) {\n    this.encodeMap(new Map<string, unknown>(Object.entries(object)), depth);\n  }\n\n  private encodeMap(map: Map<unknown, unknown>, depth: number) {\n    let keys = Array.from(map.keys());\n    if (this.sortKeys) {\n      keys = this.sortMapKeys(keys);\n    }\n\n    // Map keys may encode to the same underlying value. For example, the number 3 and the bigint 3.\n    // This is also possible with ArrayBufferViews. We may want to introduce a new encoding option\n    // which checks for duplicate keys in this sense and throws an error if they are found.\n\n    const size = this.ignoreUndefined ? this.countWithoutUndefined(map, keys) : keys.length;\n\n    if (size < 16) {\n      // fixmap\n      this.writeU8(0x80 + size);\n    } else if (size < 0x10000) {\n      // map 16\n      this.writeU8(0xde);\n      this.writeU16(size);\n    } else if (size < 0x100000000) {\n      // map 32\n      this.writeU8(0xdf);\n      this.writeU32(size);\n    } else {\n      throw new Error(`Too large map object: ${size}`);\n    }\n\n    for (const key of keys) {\n      const value = map.get(key);\n\n      if (!(this.ignoreUndefined && value === undefined)) {\n        if (typeof key === \"string\") {\n          this.encodeString(key);\n        } else if (typeof key === \"number\") {\n          this.encodeNumber(key);\n        } else if (typeof key === \"bigint\") {\n          this.encodeBigInt(key);\n        } else if (ArrayBuffer.isView(key)) {\n          this.encodeBinary(key);\n        } else if (key instanceof RawBinaryString) {\n          this.encodeBinaryAsString(key);\n        } else {\n          throw new Error(`Unsupported map key type: ${Object.prototype.toString.apply(key)}`);\n        }\n        this.doEncode(value, depth + 1);\n      }\n    }\n  }\n\n  private encodeExtension(ext: ExtData) {\n    const size = ext.data.length;\n    if (size === 1) {\n      // fixext 1\n      this.writeU8(0xd4);\n    } else if (size === 2) {\n      // fixext 2\n      this.writeU8(0xd5);\n    } else if (size === 4) {\n      // fixext 4\n      this.writeU8(0xd6);\n    } else if (size === 8) {\n      // fixext 8\n      this.writeU8(0xd7);\n    } else if (size === 16) {\n      // fixext 16\n      this.writeU8(0xd8);\n    } else if (size < 0x100) {\n      // ext 8\n      this.writeU8(0xc7);\n      this.writeU8(size);\n    } else if (size < 0x10000) {\n      // ext 16\n      this.writeU8(0xc8);\n      this.writeU16(size);\n    } else if (size < 0x100000000) {\n      // ext 32\n      this.writeU8(0xc9);\n      this.writeU32(size);\n    } else {\n      throw new Error(`Too large extension object: ${size}`);\n    }\n    this.writeI8(ext.type);\n    this.writeU8a(ext.data);\n  }\n\n  private writeU8(value: number) {\n    this.ensureBufferSizeToWrite(1);\n\n    this.view.setUint8(this.pos, value);\n    this.pos++;\n  }\n\n  private writeU8a(values: ArrayLike<number>) {\n    const size = values.length;\n    this.ensureBufferSizeToWrite(size);\n\n    this.bytes.set(values, this.pos);\n    this.pos += size;\n  }\n\n  private writeI8(value: number) {\n    this.ensureBufferSizeToWrite(1);\n\n    this.view.setInt8(this.pos, value);\n    this.pos++;\n  }\n\n  private writeU16(value: number) {\n    this.ensureBufferSizeToWrite(2);\n\n    this.view.setUint16(this.pos, value);\n    this.pos += 2;\n  }\n\n  private writeI16(value: number) {\n    this.ensureBufferSizeToWrite(2);\n\n    this.view.setInt16(this.pos, value);\n    this.pos += 2;\n  }\n\n  private writeU32(value: number) {\n    this.ensureBufferSizeToWrite(4);\n\n    this.view.setUint32(this.pos, value);\n    this.pos += 4;\n  }\n\n  private writeI32(value: number) {\n    this.ensureBufferSizeToWrite(4);\n\n    this.view.setInt32(this.pos, value);\n    this.pos += 4;\n  }\n\n  private writeF32(value: number) {\n    this.ensureBufferSizeToWrite(4);\n\n    this.view.setFloat32(this.pos, value);\n    this.pos += 4;\n  }\n\n  private writeF64(value: number) {\n    this.ensureBufferSizeToWrite(8);\n\n    this.view.setFloat64(this.pos, value);\n    this.pos += 8;\n  }\n\n  private writeU64(value: number) {\n    this.ensureBufferSizeToWrite(8);\n\n    setUint64(this.view, this.pos, value);\n    this.pos += 8;\n  }\n\n  private writeI64(value: number) {\n    this.ensureBufferSizeToWrite(8);\n\n    setInt64(this.view, this.pos, value);\n    this.pos += 8;\n  }\n\n  private writeBigUint64(value: bigint) {\n    this.ensureBufferSizeToWrite(8);\n\n    this.view.setBigUint64(this.pos, value);\n    this.pos += 8;\n  }\n\n  private writeBigInt64(value: bigint) {\n    this.ensureBufferSizeToWrite(8);\n\n    this.view.setBigInt64(this.pos, value);\n    this.pos += 8;\n  }\n}\n","import { Encoder } from \"./Encoder\";\nimport type { EncoderOptions } from \"./Encoder\";\nimport type { SplitUndefined } from \"./context\";\n\n/**\n * @deprecated Use {@link EncoderOptions} instead.\n */\nexport type EncodeOptions = never;\n\n/**\n * @deprecated No longer supported.\n */\nexport const defaultEncodeOptions: never = undefined as never;\n\n/**\n * It encodes `value` in the MessagePack format and\n * returns a byte buffer.\n *\n * The returned buffer is a slice of a larger `ArrayBuffer`, so you have to use its `#byteOffset` and `#byteLength` in order to convert it to another typed arrays including NodeJS `Buffer`.\n */\nexport function encode<ContextType = undefined>(\n  value: unknown,\n  options?: EncoderOptions<SplitUndefined<ContextType>>,\n): Uint8Array {\n  const encoder = new Encoder(options);\n  return encoder.encodeSharedRef(value);\n}\n","export function prettyByte(byte: number): string {\n  return `${byte < 0 ? \"-\" : \"\"}0x${Math.abs(byte).toString(16).padStart(2, \"0\")}`;\n}\n","import { utf8DecodeJs } from \"./utils/utf8\";\n\nconst DEFAULT_MAX_KEY_LENGTH = 16;\nconst DEFAULT_MAX_LENGTH_PER_KEY = 16;\n\nexport interface KeyDecoder {\n  canBeCached(byteLength: number): boolean;\n  decode(bytes: Uint8Array, inputOffset: number, byteLength: number): string;\n}\ninterface KeyCacheRecord {\n  readonly bytes: Uint8Array;\n  readonly str: string;\n}\n\nexport class CachedKeyDecoder implements KeyDecoder {\n  hit = 0;\n  miss = 0;\n  private readonly caches: Array<Array<KeyCacheRecord>>;\n\n  constructor(\n    readonly maxKeyLength = DEFAULT_MAX_KEY_LENGTH,\n    readonly maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY,\n  ) {\n    // avoid `new Array(N)`, which makes a sparse array,\n    // because a sparse array is typically slower than a non-sparse array.\n    this.caches = [];\n    for (let i = 0; i < this.maxKeyLength; i++) {\n      this.caches.push([]);\n    }\n  }\n\n  public canBeCached(byteLength: number): boolean {\n    return byteLength > 0 && byteLength <= this.maxKeyLength;\n  }\n\n  private find(bytes: Uint8Array, inputOffset: number, byteLength: number): string | null {\n    const records = this.caches[byteLength - 1]!;\n\n    FIND_CHUNK: for (const record of records) {\n      const recordBytes = record.bytes;\n\n      for (let j = 0; j < byteLength; j++) {\n        if (recordBytes[j] !== bytes[inputOffset + j]) {\n          continue FIND_CHUNK;\n        }\n      }\n      return record.str;\n    }\n    return null;\n  }\n\n  private store(bytes: Uint8Array, value: string) {\n    const records = this.caches[bytes.length - 1]!;\n    const record: KeyCacheRecord = { bytes, str: value };\n\n    if (records.length >= this.maxLengthPerKey) {\n      // `records` are full!\n      // Set `record` to an arbitrary position.\n      records[(Math.random() * records.length) | 0] = record;\n    } else {\n      records.push(record);\n    }\n  }\n\n  public decode(bytes: Uint8Array, inputOffset: number, byteLength: number): string {\n    const cachedValue = this.find(bytes, inputOffset, byteLength);\n    if (cachedValue != null) {\n      this.hit++;\n      return cachedValue;\n    }\n    this.miss++;\n\n    const str = utf8DecodeJs(bytes, inputOffset, byteLength);\n    // Ensure to copy a slice of bytes because the byte may be NodeJS Buffer and Buffer#slice() returns a reference to its internal ArrayBuffer.\n    const slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);\n    this.store(slicedCopyOfBytes, str);\n    return str;\n  }\n}\n","import { prettyByte } from \"./utils/prettyByte\";\nimport { ExtensionCodec, ExtensionCodecType } from \"./ExtensionCodec\";\nimport { IntMode, getInt64, getUint64, convertSafeIntegerToMode, UINT32_MAX } from \"./utils/int\";\nimport { utf8Decode } from \"./utils/utf8\";\nimport { createDataView, ensureUint8Array, RawBinaryString } from \"./utils/typedArrays\";\nimport { CachedKeyDecoder, KeyDecoder } from \"./CachedKeyDecoder\";\nimport { DecodeError } from \"./DecodeError\";\nimport type { ContextOf } from \"./context\";\n\nexport type DecoderOptions<ContextType = undefined> = Readonly<\n  Partial<{\n    extensionCodec: ExtensionCodecType<ContextType>;\n\n    /**\n     * Decodes Int64 and Uint64 as bigint if it's set to true.\n     * Depends on ES2020's {@link DataView#getBigInt64} and\n     * {@link DataView#getBigUint64}.\n     *\n     * Defaults to false. If true, equivalent to intMode: IntMode.AS_ENCODED.\n     */\n    useBigInt64: boolean;\n\n    /**\n     * Allows for more fine-grained control of BigInt handling, overrides useBigInt64.\n     *\n     * Defaults to IntMode.AS_ENCODED if useBigInt64 is true or IntMode.UNSAFE_NUMBER otherwise.\n     */\n    intMode?: IntMode;\n\n    /**\n     * By default, string values will be decoded as UTF-8 strings. However, if this option is true,\n     * string values will be returned as Uint8Arrays without additional decoding.\n     *\n     * This is useful if the strings may contain invalid UTF-8 sequences.\n     *\n     * When enabled, raw string length is limited by the maxBinLength option.\n     *\n     * Note that this option only applies to string values, not map keys. See `rawBinaryStringKeys`\n     * for map keys.\n     */\n    rawBinaryStringValues: boolean;\n\n    /**\n     * By default, map keys will be decoded as UTF-8 strings. However, if this option is true, map\n     * keys will be returned as Uint8Arrays without additional decoding.\n     *\n     * Requires `useMap` to be true, since plain objects do not support binary keys.\n     *\n     * When enabled, raw string length is limited by the maxBinLength option.\n     *\n     * Note that this option only applies to map keys, not string values. See `rawBinaryStringValues`\n     * for string values.\n     */\n    rawBinaryStringKeys: boolean;\n\n    /**\n     * If true, the decoder will use the RawBinaryString class to store raw binary strings created\n     * during decoding from the rawBinaryStringValues and rawBinaryStringKeys options. If false, it\n     * will use Uint8Arrays.\n     *\n     * Defaults to false.\n     *\n     * Has no effect if rawBinaryStringValues and rawBinaryStringKeys are both false.\n     */\n    useRawBinaryStringClass: boolean;\n\n    /**\n     * If true, the decoder will use the Map object to store map values. If false, it will use plain\n     * objects. Defaults to false.\n     *\n     * Besides the type of container, the main difference is that Map objects support a wider range\n     * of key types. Plain objects only support string keys (though you can enable\n     * `supportObjectNumberKeys` to coerce number keys to strings), while Map objects support\n     * strings, numbers, bigints, and Uint8Arrays.\n     */\n    useMap: boolean;\n\n    /**\n     * If true, the decoder will support decoding numbers as map keys on plain objects. Defaults to\n     * false.\n     *\n     * Note that any numbers used as object keys will be converted to strings, so there is a risk of\n     * key collision as well as the inability to re-encode the object to the same representation.\n     *\n     * This option is ignored if `useMap` is true.\n     *\n     * This is useful for backwards compatibility before `useMap` was introduced. Consider instead\n     * using `useMap` for new code.\n     */\n    supportObjectNumberKeys: boolean;\n\n    /**\n     * Maximum string length.\n     *\n     * Defaults to 4_294_967_295 (UINT32_MAX).\n     */\n    maxStrLength: number;\n    /**\n     * Maximum binary length.\n     *\n     * Defaults to 4_294_967_295 (UINT32_MAX).\n     */\n    maxBinLength: number;\n    /**\n     * Maximum array length.\n     *\n     * Defaults to 4_294_967_295 (UINT32_MAX).\n     */\n    maxArrayLength: number;\n    /**\n     * Maximum map length.\n     *\n     * Defaults to 4_294_967_295 (UINT32_MAX).\n     */\n    maxMapLength: number;\n    /**\n     * Maximum extension length.\n     *\n     * Defaults to 4_294_967_295 (UINT32_MAX).\n     */\n    maxExtLength: number;\n\n    /**\n     * An object key decoder. Defaults to the shared instance of {@link CachedKeyDecoder}.\n     * `null` is a special value to disable the use of the key decoder at all.\n     */\n    keyDecoder: KeyDecoder | null;\n  }>\n> &\n  ContextOf<ContextType>;\n\nconst STATE_ARRAY = \"array\";\nconst STATE_MAP_KEY = \"map_key\";\nconst STATE_MAP_VALUE = \"map_value\";\n\ntype MapKeyType = string | number | bigint | Uint8Array;\n\nfunction isValidMapKeyType(key: unknown, useMap: boolean, supportObjectNumberKeys: boolean): key is MapKeyType {\n  if (useMap) {\n    return (\n      typeof key === \"string\" ||\n      typeof key === \"number\" ||\n      typeof key === \"bigint\" ||\n      key instanceof Uint8Array ||\n      key instanceof RawBinaryString\n    );\n  }\n  // Plain objects support a more limited set of key types\n  return typeof key === \"string\" || (supportObjectNumberKeys && typeof key === \"number\");\n}\n\ntype StackMapState = {\n  type: typeof STATE_MAP_KEY | typeof STATE_MAP_VALUE;\n  size: number;\n  key: MapKeyType | null;\n  readCount: number;\n  map: Record<string, unknown> | Map<MapKeyType, unknown>;\n};\n\ntype StackArrayState = {\n  type: typeof STATE_ARRAY;\n  size: number;\n  array: Array<unknown>;\n  position: number;\n};\n\nclass StackPool {\n  private readonly stack: Array<StackState> = [];\n  private stackHeadPosition = -1;\n\n  constructor(private readonly useMap: boolean) {}\n\n  public get length(): number {\n    return this.stackHeadPosition + 1;\n  }\n\n  public top(): StackState | undefined {\n    return this.stack[this.stackHeadPosition];\n  }\n\n  public pushArrayState(size: number) {\n    const state = this.getUninitializedStateFromPool() as StackArrayState;\n\n    state.type = STATE_ARRAY;\n    state.position = 0;\n    state.size = size;\n    state.array = new Array(size);\n  }\n\n  public pushMapState(size: number) {\n    const state = this.getUninitializedStateFromPool() as StackMapState;\n\n    state.type = STATE_MAP_KEY;\n    state.readCount = 0;\n    state.size = size;\n    state.map = this.useMap ? new Map() : {};\n  }\n\n  private getUninitializedStateFromPool() {\n    this.stackHeadPosition++;\n\n    if (this.stackHeadPosition === this.stack.length) {\n      const partialState: Partial<StackState> = {\n        type: undefined,\n        size: 0,\n        array: undefined,\n        position: 0,\n        readCount: 0,\n        map: undefined,\n        key: null,\n      };\n\n      this.stack.push(partialState as StackState);\n    }\n\n    return this.stack[this.stackHeadPosition];\n  }\n\n  public release(state: StackState): void {\n    const topStackState = this.stack[this.stackHeadPosition];\n\n    if (topStackState !== state) {\n      throw new Error(\"Invalid stack state. Released state is not on top of the stack.\");\n    }\n\n    if (state.type === STATE_ARRAY) {\n      const partialState = state as Partial<StackArrayState>;\n      partialState.size = 0;\n      partialState.array = undefined;\n      partialState.position = 0;\n      partialState.type = undefined;\n    }\n\n    if (state.type === STATE_MAP_KEY || state.type === STATE_MAP_VALUE) {\n      const partialState = state as Partial<StackMapState>;\n      partialState.size = 0;\n      partialState.map = undefined;\n      partialState.readCount = 0;\n      partialState.type = undefined;\n    }\n\n    this.stackHeadPosition--;\n  }\n\n  public reset(): void {\n    this.stack.length = 0;\n    this.stackHeadPosition = -1;\n  }\n}\n\ntype StackState = StackArrayState | StackMapState;\n\nconst HEAD_BYTE_REQUIRED = -1;\n\nconst EMPTY_VIEW = new DataView(new ArrayBuffer(0));\nconst EMPTY_BYTES = new Uint8Array(EMPTY_VIEW.buffer);\n\ntry {\n  // IE11: The spec says it should throw RangeError,\n  // IE11: but in IE11 it throws TypeError.\n  EMPTY_VIEW.getInt8(0);\n} catch (e) {\n  if (!(e instanceof RangeError)) {\n    throw new Error(\n      \"This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access\",\n    );\n  }\n}\nexport const DataViewIndexOutOfBoundsError = RangeError;\n\nconst MORE_DATA = new DataViewIndexOutOfBoundsError(\"Insufficient data\");\n\nconst sharedCachedKeyDecoder = new CachedKeyDecoder();\n\nexport class Decoder<ContextType = undefined> {\n  private readonly extensionCodec: ExtensionCodecType<ContextType>;\n  private readonly context: ContextType;\n  private readonly intMode: IntMode;\n  private readonly rawBinaryStringValues: boolean;\n  private readonly rawBinaryStringKeys: boolean;\n  private readonly useRawBinaryStringClass: boolean;\n  private readonly useMap: boolean;\n  private readonly supportObjectNumberKeys: boolean;\n  private readonly maxStrLength: number;\n  private readonly maxBinLength: number;\n  private readonly maxArrayLength: number;\n  private readonly maxMapLength: number;\n  private readonly maxExtLength: number;\n  private readonly keyDecoder: KeyDecoder | null;\n\n  private totalPos = 0;\n  private pos = 0;\n\n  private view = EMPTY_VIEW;\n  private bytes = EMPTY_BYTES;\n  private headByte = HEAD_BYTE_REQUIRED;\n  private readonly stack: StackPool;\n\n  public constructor(options?: DecoderOptions<ContextType>) {\n    this.extensionCodec = options?.extensionCodec ?? (ExtensionCodec.defaultCodec as ExtensionCodecType<ContextType>);\n    this.context = (options as { context: ContextType } | undefined)?.context as ContextType; // needs a type assertion because EncoderOptions has no context property when ContextType is undefined\n\n    this.intMode = options?.intMode ?? (options?.useBigInt64 ? IntMode.AS_ENCODED : IntMode.UNSAFE_NUMBER);\n    this.rawBinaryStringValues = options?.rawBinaryStringValues ?? false;\n    this.rawBinaryStringKeys = options?.rawBinaryStringKeys ?? false;\n    this.useRawBinaryStringClass = options?.useRawBinaryStringClass ?? false;\n    this.useMap = options?.useMap ?? false;\n    this.supportObjectNumberKeys = options?.supportObjectNumberKeys ?? false;\n    this.maxStrLength = options?.maxStrLength ?? UINT32_MAX;\n    this.maxBinLength = options?.maxBinLength ?? UINT32_MAX;\n    this.maxArrayLength = options?.maxArrayLength ?? UINT32_MAX;\n    this.maxMapLength = options?.maxMapLength ?? UINT32_MAX;\n    this.maxExtLength = options?.maxExtLength ?? UINT32_MAX;\n    this.keyDecoder = options?.keyDecoder !== undefined ? options.keyDecoder : sharedCachedKeyDecoder;\n\n    if (this.rawBinaryStringKeys && !this.useMap) {\n      throw new Error(\"rawBinaryStringKeys is only supported when useMap is true\");\n    }\n\n    this.stack = new StackPool(this.useMap);\n  }\n\n  private reinitializeState() {\n    this.totalPos = 0;\n    this.headByte = HEAD_BYTE_REQUIRED;\n    this.stack.reset();\n\n    // view, bytes, and pos will be re-initialized in setBuffer()\n  }\n\n  private setBuffer(buffer: ArrayLike<number> | BufferSource): void {\n    this.bytes = ensureUint8Array(buffer);\n    this.view = createDataView(this.bytes);\n    this.pos = 0;\n  }\n\n  private appendBuffer(buffer: ArrayLike<number> | BufferSource) {\n    if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining(1)) {\n      this.setBuffer(buffer);\n    } else {\n      const remainingData = this.bytes.subarray(this.pos);\n      const newData = ensureUint8Array(buffer);\n\n      // concat remainingData + newData\n      const newBuffer = new Uint8Array(remainingData.length + newData.length);\n      newBuffer.set(remainingData);\n      newBuffer.set(newData, remainingData.length);\n      this.setBuffer(newBuffer);\n    }\n  }\n\n  private hasRemaining(size: number) {\n    return this.view.byteLength - this.pos >= size;\n  }\n\n  private createExtraByteError(posToShow: number): Error {\n    const { view, pos } = this;\n    return new RangeError(`Extra ${view.byteLength - pos} of ${view.byteLength} byte(s) found at buffer[${posToShow}]`);\n  }\n\n  /**\n   * @throws {@link DecodeError}\n   * @throws {@link RangeError}\n   */\n  public decode(buffer: ArrayLike<number> | BufferSource): unknown {\n    this.reinitializeState();\n    this.setBuffer(buffer);\n\n    const object = this.doDecodeSync();\n    if (this.hasRemaining(1)) {\n      throw this.createExtraByteError(this.pos);\n    }\n    return object;\n  }\n\n  public *decodeMulti(buffer: ArrayLike<number> | BufferSource): Generator<unknown, void, unknown> {\n    this.reinitializeState();\n    this.setBuffer(buffer);\n\n    while (this.hasRemaining(1)) {\n      yield this.doDecodeSync();\n    }\n  }\n\n  public async decodeAsync(stream: AsyncIterable<ArrayLike<number> | BufferSource>): Promise<unknown> {\n    let decoded = false;\n    let object: unknown;\n    for await (const buffer of stream) {\n      if (decoded) {\n        throw this.createExtraByteError(this.totalPos);\n      }\n\n      this.appendBuffer(buffer);\n\n      try {\n        object = this.doDecodeSync();\n        decoded = true;\n      } catch (e) {\n        if (!(e instanceof DataViewIndexOutOfBoundsError)) {\n          throw e; // rethrow\n        }\n        // fallthrough\n      }\n      this.totalPos += this.pos;\n    }\n\n    if (decoded) {\n      if (this.hasRemaining(1)) {\n        throw this.createExtraByteError(this.totalPos);\n      }\n      return object;\n    }\n\n    const { headByte, pos, totalPos } = this;\n    throw new RangeError(\n      `Insufficient data in parsing ${prettyByte(headByte)} at ${totalPos} (${pos} in the current buffer)`,\n    );\n  }\n\n  public decodeArrayStream(\n    stream: AsyncIterable<ArrayLike<number> | BufferSource>,\n  ): AsyncGenerator<unknown, void, unknown> {\n    return this.decodeMultiAsync(stream, true);\n  }\n\n  public decodeStream(stream: AsyncIterable<ArrayLike<number> | BufferSource>): AsyncGenerator<unknown, void, unknown> {\n    return this.decodeMultiAsync(stream, false);\n  }\n\n  private async *decodeMultiAsync(stream: AsyncIterable<ArrayLike<number> | BufferSource>, isArray: boolean) {\n    let isArrayHeaderRequired = isArray;\n    let arrayItemsLeft = -1;\n\n    for await (const buffer of stream) {\n      if (isArray && arrayItemsLeft === 0) {\n        throw this.createExtraByteError(this.totalPos);\n      }\n\n      this.appendBuffer(buffer);\n\n      if (isArrayHeaderRequired) {\n        arrayItemsLeft = this.readArraySize();\n        isArrayHeaderRequired = false;\n        this.complete();\n      }\n\n      try {\n        while (true) {\n          yield this.doDecodeSync();\n          if (--arrayItemsLeft === 0) {\n            break;\n          }\n        }\n      } catch (e) {\n        if (!(e instanceof DataViewIndexOutOfBoundsError)) {\n          throw e; // rethrow\n        }\n        // fallthrough\n      }\n      this.totalPos += this.pos;\n    }\n  }\n\n  private doDecodeSync(): unknown {\n    DECODE: while (true) {\n      const headByte = this.readHeadByte();\n      let object: unknown;\n\n      if (headByte >= 0xe0) {\n        // negative fixint (111x xxxx) 0xe0 - 0xff\n        object = this.convertNumber(headByte - 0x100);\n      } else if (headByte < 0xc0) {\n        if (headByte < 0x80) {\n          // positive fixint (0xxx xxxx) 0x00 - 0x7f\n          object = this.convertNumber(headByte);\n        } else if (headByte < 0x90) {\n          // fixmap (1000 xxxx) 0x80 - 0x8f\n          const size = headByte - 0x80;\n          if (size !== 0) {\n            this.pushMapState(size);\n            this.complete();\n            continue DECODE;\n          } else {\n            object = this.useMap ? new Map() : {};\n          }\n        } else if (headByte < 0xa0) {\n          // fixarray (1001 xxxx) 0x90 - 0x9f\n          const size = headByte - 0x90;\n          if (size !== 0) {\n            this.pushArrayState(size);\n            this.complete();\n            continue DECODE;\n          } else {\n            object = [];\n          }\n        } else {\n          // fixstr (101x xxxx) 0xa0 - 0xbf\n          const byteLength = headByte - 0xa0;\n          object = this.decodeString(byteLength, 0);\n        }\n      } else if (headByte === 0xc0) {\n        // nil\n        object = null;\n      } else if (headByte === 0xc2) {\n        // false\n        object = false;\n      } else if (headByte === 0xc3) {\n        // true\n        object = true;\n      } else if (headByte === 0xca) {\n        // float 32\n        object = this.readF32();\n      } else if (headByte === 0xcb) {\n        // float 64\n        object = this.readF64();\n      } else if (headByte === 0xcc) {\n        // uint 8\n        object = this.convertNumber(this.readU8());\n      } else if (headByte === 0xcd) {\n        // uint 16\n        object = this.convertNumber(this.readU16());\n      } else if (headByte === 0xce) {\n        // uint 32\n        object = this.convertNumber(this.readU32());\n      } else if (headByte === 0xcf) {\n        // uint 64\n        object = this.readU64();\n      } else if (headByte === 0xd0) {\n        // int 8\n        object = this.convertNumber(this.readI8());\n      } else if (headByte === 0xd1) {\n        // int 16\n        object = this.convertNumber(this.readI16());\n      } else if (headByte === 0xd2) {\n        // int 32\n        object = this.convertNumber(this.readI32());\n      } else if (headByte === 0xd3) {\n        // int 64\n        object = this.readI64();\n      } else if (headByte === 0xd9) {\n        // str 8\n        const byteLength = this.lookU8();\n        object = this.decodeString(byteLength, 1);\n      } else if (headByte === 0xda) {\n        // str 16\n        const byteLength = this.lookU16();\n        object = this.decodeString(byteLength, 2);\n      } else if (headByte === 0xdb) {\n        // str 32\n        const byteLength = this.lookU32();\n        object = this.decodeString(byteLength, 4);\n      } else if (headByte === 0xdc) {\n        // array 16\n        const size = this.readU16();\n        if (size !== 0) {\n          this.pushArrayState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = [];\n        }\n      } else if (headByte === 0xdd) {\n        // array 32\n        const size = this.readU32();\n        if (size !== 0) {\n          this.pushArrayState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = [];\n        }\n      } else if (headByte === 0xde) {\n        // map 16\n        const size = this.readU16();\n        if (size !== 0) {\n          this.pushMapState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = {};\n        }\n      } else if (headByte === 0xdf) {\n        // map 32\n        const size = this.readU32();\n        if (size !== 0) {\n          this.pushMapState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = {};\n        }\n      } else if (headByte === 0xc4) {\n        // bin 8\n        const size = this.lookU8();\n        object = this.decodeBinary(size, 1);\n      } else if (headByte === 0xc5) {\n        // bin 16\n        const size = this.lookU16();\n        object = this.decodeBinary(size, 2);\n      } else if (headByte === 0xc6) {\n        // bin 32\n        const size = this.lookU32();\n        object = this.decodeBinary(size, 4);\n      } else if (headByte === 0xd4) {\n        // fixext 1\n        object = this.decodeExtension(1, 0);\n      } else if (headByte === 0xd5) {\n        // fixext 2\n        object = this.decodeExtension(2, 0);\n      } else if (headByte === 0xd6) {\n        // fixext 4\n        object = this.decodeExtension(4, 0);\n      } else if (headByte === 0xd7) {\n        // fixext 8\n        object = this.decodeExtension(8, 0);\n      } else if (headByte === 0xd8) {\n        // fixext 16\n        object = this.decodeExtension(16, 0);\n      } else if (headByte === 0xc7) {\n        // ext 8\n        const size = this.lookU8();\n        object = this.decodeExtension(size, 1);\n      } else if (headByte === 0xc8) {\n        // ext 16\n        const size = this.lookU16();\n        object = this.decodeExtension(size, 2);\n      } else if (headByte === 0xc9) {\n        // ext 32\n        const size = this.lookU32();\n        object = this.decodeExtension(size, 4);\n      } else {\n        throw new DecodeError(`Unrecognized type byte: ${prettyByte(headByte)}`);\n      }\n\n      this.complete();\n\n      const stack = this.stack;\n      while (stack.length > 0) {\n        // arrays and maps\n        const state = stack.top()!;\n        if (state.type === STATE_ARRAY) {\n          state.array[state.position] = object;\n          state.position++;\n          if (state.position === state.size) {\n            object = state.array;\n            stack.release(state);\n          } else {\n            continue DECODE;\n          }\n        } else if (state.type === STATE_MAP_KEY) {\n          if (!isValidMapKeyType(object, this.useMap, this.supportObjectNumberKeys)) {\n            const acceptableTypes = this.useMap\n              ? \"string, number, bigint, or Uint8Array\"\n              : this.supportObjectNumberKeys\n              ? \"string or number\"\n              : \"string\";\n            throw new DecodeError(`The type of key must be ${acceptableTypes} but got ${typeof object}`);\n          }\n          if (!this.useMap && object === \"__proto__\") {\n            throw new DecodeError(\"The key __proto__ is not allowed\");\n          }\n\n          state.key = object;\n          state.type = STATE_MAP_VALUE;\n          continue DECODE;\n        } else {\n          // it must be `state.type === State.MAP_VALUE` here\n\n          if (this.useMap) {\n            (state.map as Map<MapKeyType, unknown>).set(state.key!, object);\n          } else {\n            (state.map as Record<string, unknown>)[state.key as string] = object;\n          }\n          state.readCount++;\n\n          if (state.readCount === state.size) {\n            object = state.map;\n            stack.release(state);\n          } else {\n            state.key = null;\n            state.type = STATE_MAP_KEY;\n            continue DECODE;\n          }\n        }\n      }\n\n      return object;\n    }\n  }\n\n  private readHeadByte(): number {\n    if (this.headByte === HEAD_BYTE_REQUIRED) {\n      this.headByte = this.readU8();\n      // console.log(\"headByte\", prettyByte(this.headByte));\n    }\n\n    return this.headByte;\n  }\n\n  private complete(): void {\n    this.headByte = HEAD_BYTE_REQUIRED;\n  }\n\n  private readArraySize(): number {\n    const headByte = this.readHeadByte();\n\n    switch (headByte) {\n      case 0xdc:\n        return this.readU16();\n      case 0xdd:\n        return this.readU32();\n      default: {\n        if (headByte < 0xa0) {\n          return headByte - 0x90;\n        } else {\n          throw new DecodeError(`Unrecognized array type byte: ${prettyByte(headByte)}`);\n        }\n      }\n    }\n  }\n\n  private pushMapState(size: number) {\n    if (size > this.maxMapLength) {\n      throw new DecodeError(`Max length exceeded: map length (${size}) > maxMapLengthLength (${this.maxMapLength})`);\n    }\n\n    this.stack.pushMapState(size);\n  }\n\n  private pushArrayState(size: number) {\n    if (size > this.maxArrayLength) {\n      throw new DecodeError(`Max length exceeded: array length (${size}) > maxArrayLength (${this.maxArrayLength})`);\n    }\n\n    this.stack.pushArrayState(size);\n  }\n\n  private decodeString(byteLength: number, headerOffset: number): string | Uint8Array | RawBinaryString {\n    if (this.stateIsMapKey() ? this.rawBinaryStringKeys : this.rawBinaryStringValues) {\n      const decoded = this.decodeBinary(byteLength, headerOffset);\n      if (this.useRawBinaryStringClass) {\n        return new RawBinaryString(decoded);\n      }\n      return decoded;\n    }\n    return this.decodeUtf8String(byteLength, headerOffset);\n  }\n\n  private decodeUtf8String(byteLength: number, headerOffset: number): string {\n    if (byteLength > this.maxStrLength) {\n      throw new DecodeError(\n        `Max length exceeded: UTF-8 byte length (${byteLength}) > maxStrLength (${this.maxStrLength})`,\n      );\n    }\n\n    if (this.bytes.byteLength < this.pos + headerOffset + byteLength) {\n      throw MORE_DATA;\n    }\n\n    const offset = this.pos + headerOffset;\n    let object: string;\n    if (this.stateIsMapKey() && this.keyDecoder?.canBeCached(byteLength)) {\n      object = this.keyDecoder.decode(this.bytes, offset, byteLength);\n    } else {\n      object = utf8Decode(this.bytes, offset, byteLength);\n    }\n    this.pos += headerOffset + byteLength;\n    return object;\n  }\n\n  private stateIsMapKey(): boolean {\n    if (this.stack.length > 0) {\n      const state = this.stack.top()!;\n      return state.type === STATE_MAP_KEY;\n    }\n    return false;\n  }\n\n  private decodeBinary(byteLength: number, headOffset: number): Uint8Array {\n    if (byteLength > this.maxBinLength) {\n      throw new DecodeError(`Max length exceeded: bin length (${byteLength}) > maxBinLength (${this.maxBinLength})`);\n    }\n\n    if (!this.hasRemaining(byteLength + headOffset)) {\n      throw MORE_DATA;\n    }\n\n    const offset = this.pos + headOffset;\n    const object = this.bytes.subarray(offset, offset + byteLength);\n    this.pos += headOffset + byteLength;\n    return object;\n  }\n\n  private decodeExtension(size: number, headOffset: number): unknown {\n    if (size > this.maxExtLength) {\n      throw new DecodeError(`Max length exceeded: ext length (${size}) > maxExtLength (${this.maxExtLength})`);\n    }\n\n    const extType = this.view.getInt8(this.pos + headOffset);\n    const data = this.decodeBinary(size, headOffset + 1 /* extType */);\n    return this.extensionCodec.decode(data, extType, this.context);\n  }\n\n  private convertNumber(value: number): number | bigint {\n    return convertSafeIntegerToMode(value, this.intMode);\n  }\n\n  private lookU8() {\n    return this.view.getUint8(this.pos);\n  }\n\n  private lookU16() {\n    return this.view.getUint16(this.pos);\n  }\n\n  private lookU32() {\n    return this.view.getUint32(this.pos);\n  }\n\n  private readU8(): number {\n    const value = this.view.getUint8(this.pos);\n    this.pos++;\n    return value;\n  }\n\n  private readI8(): number {\n    const value = this.view.getInt8(this.pos);\n    this.pos++;\n    return value;\n  }\n\n  private readU16(): number {\n    const value = this.view.getUint16(this.pos);\n    this.pos += 2;\n    return value;\n  }\n\n  private readI16(): number {\n    const value = this.view.getInt16(this.pos);\n    this.pos += 2;\n    return value;\n  }\n\n  private readU32(): number {\n    const value = this.view.getUint32(this.pos);\n    this.pos += 4;\n    return value;\n  }\n\n  private readI32(): number {\n    const value = this.view.getInt32(this.pos);\n    this.pos += 4;\n    return value;\n  }\n\n  private readU64(): number | bigint {\n    const value = getUint64(this.view, this.pos, this.intMode);\n    this.pos += 8;\n    return value;\n  }\n\n  private readI64(): number | bigint {\n    const value = getInt64(this.view, this.pos, this.intMode);\n    this.pos += 8;\n    return value;\n  }\n\n  private readF32() {\n    const value = this.view.getFloat32(this.pos);\n    this.pos += 4;\n    return value;\n  }\n\n  private readF64() {\n    const value = this.view.getFloat64(this.pos);\n    this.pos += 8;\n    return value;\n  }\n}\n","import { Decoder } from \"./Decoder\";\nimport type { DecoderOptions } from \"./Decoder\";\nimport type { SplitUndefined } from \"./context\";\n\n/**\n * @deprecated Use {@link DecoderOptions} instead.\n */\nexport type DecodeOptions = never;\n\n/**\n * @deprecated No longer supported.\n */\nexport const defaultDecodeOptions: never = undefined as never;\n\n/**\n * It decodes a single MessagePack object in a buffer.\n *\n * This is a synchronous decoding function.\n * See other variants for asynchronous decoding: {@link decodeAsync}, {@link decodeStream}, or {@link decodeArrayStream}.\n *\n * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.\n * @throws {@link DecodeError} if the buffer contains invalid data.\n */\nexport function decode<ContextType = undefined>(\n  buffer: ArrayLike<number> | BufferSource,\n  options?: DecoderOptions<SplitUndefined<ContextType>>,\n): unknown {\n  const decoder = new Decoder(options);\n  return decoder.decode(buffer);\n}\n\n/**\n * It decodes multiple MessagePack objects in a buffer.\n * This is corresponding to {@link decodeMultiStream}.\n *\n * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.\n * @throws {@link DecodeError} if the buffer contains invalid data.\n */\nexport function decodeMulti<ContextType = undefined>(\n  buffer: ArrayLike<number> | BufferSource,\n  options?: DecoderOptions<SplitUndefined<ContextType>>,\n): Generator<unknown, void, unknown> {\n  const decoder = new Decoder(options);\n  return decoder.decodeMulti(buffer);\n}\n","// utility for whatwg streams\n\n// The living standard of whatwg streams says\n// ReadableStream is also AsyncIterable, but\n// as of June 2019, no browser implements it.\n// See https://streams.spec.whatwg.org/ for details\nexport type ReadableStreamLike<T> = AsyncIterable<T> | ReadableStream<T>;\n\nexport function isAsyncIterable<T>(object: ReadableStreamLike<T>): object is AsyncIterable<T> {\n  return (object as any)[Symbol.asyncIterator] != null;\n}\n\nfunction assertNonNull<T>(value: T | null | undefined): asserts value is T {\n  if (value == null) {\n    throw new Error(\"Assertion Failure: value must not be null nor undefined\");\n  }\n}\n\nexport async function* asyncIterableFromStream<T>(stream: ReadableStream<T>): AsyncIterable<T> {\n  const reader = stream.getReader();\n\n  try {\n    while (true) {\n      const { done, value } = await reader.read();\n      if (done) {\n        return;\n      }\n      assertNonNull(value);\n      yield value;\n    }\n  } finally {\n    reader.releaseLock();\n  }\n}\n\nexport function ensureAsyncIterable<T>(streamLike: ReadableStreamLike<T>): AsyncIterable<T> {\n  if (isAsyncIterable(streamLike)) {\n    return streamLike;\n  } else {\n    return asyncIterableFromStream(streamLike);\n  }\n}\n","import { Decoder } from \"./Decoder\";\nimport { ensureAsyncIterable } from \"./utils/stream\";\nimport type { DecoderOptions } from \"./Decoder\";\nimport type { ReadableStreamLike } from \"./utils/stream\";\nimport type { SplitUndefined } from \"./context\";\n\n/**\n * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.\n * @throws {@link DecodeError} if the buffer contains invalid data.\n */\nexport async function decodeAsync<ContextType = undefined>(\n  streamLike: ReadableStreamLike<ArrayLike<number> | BufferSource>,\n  options?: DecoderOptions<SplitUndefined<ContextType>>,\n): Promise<unknown> {\n  const stream = ensureAsyncIterable(streamLike);\n  const decoder = new Decoder(options);\n  return decoder.decodeAsync(stream);\n}\n\n/**\n * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.\n * @throws {@link DecodeError} if the buffer contains invalid data.\n */\nexport function decodeArrayStream<ContextType>(\n  streamLike: ReadableStreamLike<ArrayLike<number> | BufferSource>,\n  options?: DecoderOptions<SplitUndefined<ContextType>>,\n): AsyncGenerator<unknown, void, unknown> {\n  const stream = ensureAsyncIterable(streamLike);\n  const decoder = new Decoder(options);\n  return decoder.decodeArrayStream(stream);\n}\n\n/**\n * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.\n * @throws {@link DecodeError} if the buffer contains invalid data.\n */\nexport function decodeMultiStream<ContextType>(\n  streamLike: ReadableStreamLike<ArrayLike<number> | BufferSource>,\n  options?: DecoderOptions<SplitUndefined<ContextType>>,\n): AsyncGenerator<unknown, void, unknown> {\n  const stream = ensureAsyncIterable(streamLike);\n  const decoder = new Decoder(options);\n  return decoder.decodeStream(stream);\n}\n\n/**\n * @deprecated Use {@link decodeMultiStream} instead.\n */\nexport const decodeStream: never = undefined as never;\n"],"names":["root","factory","exports","module","define","amd","this","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","sharedTextEncoder","TextEncoder","CHUNK_SIZE","utf8DecodeJs","bytes","inputOffset","byteLength","offset","end","units","result","byte1","push","byte2","byte3","unit","length","String","fromCharCode","sharedTextDecoder","TextDecoder","IntMode","type","data","message","proto","create","DecodeError","setPrototypeOf","configurable","name","Error","UINT32_MAX","setInt64","view","high","Math","floor","low","setUint32","getInt64","mode","UNSAFE_NUMBER","SAFE_NUMBER","getInt32","getUint32","Number","MIN_SAFE_INTEGER","MAX_SAFE_INTEGER","hexValue","abs","toString","padStart","getBigInt64","MIXED","EXT_TIMESTAMP","TIMESTAMP32_MAX_SEC","TIMESTAMP64_MAX_SEC","encodeTimeSpecToTimestamp","sec","nsec","rv","Uint8Array","DataView","buffer","secHigh","secLow","encodeDateToTimeSpec","date","msec","getTime","nsecInSec","encodeTimestampExtension","object","Date","decodeTimestampToTimeSpec","byteOffset","nsec30AndSecHigh2","decodeTimestampExtension","timeSpec","timestampExtension","encode","decode","builtInEncoders","builtInDecoders","encoders","decoders","register","index","tryToEncode","context","i","encodeExt","ExtData","decodeExt","defaultCodec","ExtensionCodec","ensureUint8Array","ArrayBuffer","isView","from","compareUint8Arrays","a","b","min","diff","rawBinaryValue","TypeError","options","extensionCodec","forceBigIntToInt64","maxDepth","initialBufferSize","sortKeys","forceFloat32","ignoreUndefined","forceIntegerToFloat","pos","reinitializeState","encodeSharedRef","doEncode","subarray","slice","depth","encodeNil","encodeBoolean","encodeNumber","encodeString","encodeObject","ensureBufferSizeToWrite","sizeToWrite","requiredSize","resizeBuffer","newSize","newBuffer","newBytes","newView","set","writeU8","isSafeInteger","writeU16","writeU32","writeU64","writeI8","writeI16","writeI32","writeI64","encodeNumberAsFloat","writeF32","writeF64","encodeBigInt","encodeBigIntAsInt64","BigInt","writeBigUint64","writeBigInt64","writeStringHeader","str","output","outputOffset","strLength","charCodeAt","extra","utf8Count","encodeInto","utf8EncodeTE","utf8EncodeJs","ext","encodeExtension","Array","isArray","encodeArray","encodeBinary","RawBinaryString","encodeBinaryAsString","Map","encodeMap","apply","encodeMapObject","size","writeU8a","binaryString","item","countWithoutUndefined","map","keys","count","undefined","sortMapKeys","numericKeys","stringKeys","rawStringKeys","binaryKeys","isNaN","sort","concat","entries","setUint8","values","setInt8","setUint16","setInt16","setInt32","setFloat32","setFloat64","setUint64","setBigUint64","setBigInt64","Encoder","prettyByte","byte","maxKeyLength","maxLengthPerKey","hit","miss","caches","canBeCached","find","records","FIND_CHUNK","record","recordBytes","j","store","random","cachedValue","slicedCopyOfBytes","STATE_ARRAY","STATE_MAP_KEY","STATE_MAP_VALUE","useMap","stack","stackHeadPosition","top","pushArrayState","state","getUninitializedStateFromPool","position","array","pushMapState","readCount","release","partialState","reset","EMPTY_VIEW","EMPTY_BYTES","getInt8","e","RangeError","DataViewIndexOutOfBoundsError","MORE_DATA","sharedCachedKeyDecoder","CachedKeyDecoder","totalPos","headByte","intMode","useBigInt64","AS_ENCODED","rawBinaryStringValues","rawBinaryStringKeys","useRawBinaryStringClass","supportObjectNumberKeys","maxStrLength","maxBinLength","maxArrayLength","maxMapLength","maxExtLength","keyDecoder","StackPool","setBuffer","bufferView","createDataView","appendBuffer","hasRemaining","remainingData","newData","createExtraByteError","posToShow","doDecodeSync","decodeMulti","decodeAsync","stream","decoded","decodeArrayStream","decodeMultiAsync","decodeStream","isArrayHeaderRequired","arrayItemsLeft","readArraySize","complete","DECODE","readHeadByte","convertNumber","decodeString","readF32","readF64","readU8","readU16","readU32","readU64","readI8","readI16","readI32","readI64","lookU8","lookU16","lookU32","decodeBinary","decodeExtension","acceptableTypes","headerOffset","stateIsMapKey","decodeUtf8String","stringBytes","utf8DecodeTD","utf8Decode","headOffset","extType","BIGINT","convertSafeIntegerToMode","getUint8","getUint16","getInt16","getBigUint64","getUint64","getFloat32","getFloat64","Decoder","ensureAsyncIterable","streamLike","asyncIterator","reader","getReader","read","done","assertNonNull","releaseLock","asyncIterableFromStream","decodeMultiStream"],"sourceRoot":""}