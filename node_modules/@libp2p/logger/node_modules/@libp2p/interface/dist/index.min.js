(function (root, factory) {(typeof module === 'object' && module.exports) ? module.exports = factory() : root.Libp2PInterface = factory()}(typeof self !== 'undefined' ? self : this, function () {
"use strict";var Libp2PInterface=(()=>{var a=Object.defineProperty;var $=Object.getOwnPropertyDescriptor;var k=Object.getOwnPropertyNames;var rr=Object.prototype.hasOwnProperty;var tr=(t,r)=>{for(var e in r)a(t,e,{get:r[e],enumerable:!0})},er=(t,r,e,s)=>{if(r&&typeof r=="object"||typeof r=="function")for(let o of k(r))!rr.call(t,o)&&o!==e&&a(t,o,{get:()=>r[o],enumerable:!(s=$(r,o))||s.enumerable});return t};var or=t=>er(a({},"__esModule",{value:!0}),t);var Er={};tr(Er,{AbortError:()=>i,AlreadyStartedError:()=>U,ConnectionClosedError:()=>f,ConnectionClosingError:()=>d,ConnectionFailedError:()=>E,DialError:()=>N,FaultTolerance:()=>G,InvalidCIDError:()=>L,InvalidCryptoExchangeError:()=>p,InvalidMessageError:()=>T,InvalidMultiaddrError:()=>A,InvalidMultihashError:()=>g,InvalidParametersError:()=>l,InvalidPeerIdError:()=>P,InvalidPrivateKeyError:()=>m,InvalidPublicKeyError:()=>u,KEEP_ALIVE:()=>lr,LimitedConnectionError:()=>_,ListenError:()=>K,MuxerClosedError:()=>h,NotFoundError:()=>I,NotImplementedError:()=>R,NotStartedError:()=>M,ProtocolError:()=>C,StreamAbortEvent:()=>V,StreamAbortedError:()=>y,StreamBufferError:()=>S,StreamCloseEvent:()=>n,StreamMessageEvent:()=>q,StreamResetError:()=>b,StreamResetEvent:()=>j,StreamStateError:()=>v,TimeoutError:()=>D,TooManyInboundProtocolStreamsError:()=>B,TooManyOutboundProtocolStreamsError:()=>F,TypedEventEmitter:()=>H,UnexpectedPeerError:()=>c,UnsupportedKeyTypeError:()=>O,UnsupportedOperationError:()=>x,UnsupportedProtocolError:()=>w,connectionSymbol:()=>J,contentRoutingSymbol:()=>nr,isConnection:()=>sr,isPeerId:()=>cr,isPrivateKey:()=>ar,isPublicKey:()=>Q,isStartable:()=>z,isTransport:()=>xr,peerDiscoverySymbol:()=>ir,peerIdSymbol:()=>W,peerRoutingSymbol:()=>pr,serviceCapabilities:()=>dr,serviceDependencies:()=>fr,setMaxListeners:()=>Y,start:()=>ur,stop:()=>mr,transportSymbol:()=>X});var J=Symbol.for("@libp2p/connection");function sr(t){return t!=null&&!!t[J]}var nr=Symbol.for("@libp2p/content-routing");var i=class extends Error{static name="AbortError";constructor(r="The operation was aborted"){super(r),this.name="AbortError"}},c=class extends Error{static name="UnexpectedPeerError";constructor(r="Unexpected Peer"){super(r),this.name="UnexpectedPeerError"}},p=class extends Error{static name="InvalidCryptoExchangeError";constructor(r="Invalid crypto exchange"){super(r),this.name="InvalidCryptoExchangeError"}},l=class extends Error{static name="InvalidParametersError";constructor(r="Invalid parameters"){super(r),this.name="InvalidParametersError"}},u=class extends Error{static name="InvalidPublicKeyError";constructor(r="Invalid public key"){super(r),this.name="InvalidPublicKeyError"}},m=class extends Error{static name="InvalidPrivateKeyError";constructor(r="Invalid private key"){super(r),this.name="InvalidPrivateKeyError"}},x=class extends Error{static name="UnsupportedOperationError";constructor(r="Unsupported operation"){super(r),this.name="UnsupportedOperationError"}},d=class extends Error{static name="ConnectionClosingError";constructor(r="The connection is closing"){super(r),this.name="ConnectionClosingError"}},f=class extends Error{static name="ConnectionClosedError";constructor(r="The connection is closed"){super(r),this.name="ConnectionClosedError"}},E=class extends Error{static name="ConnectionFailedError";constructor(r="Connection failed"){super(r),this.name="ConnectionFailedError"}},h=class extends Error{static name="MuxerClosedError";constructor(r="The muxer is closed"){super(r),this.name="MuxerClosedError"}},b=class extends Error{static name="StreamResetError";constructor(r="The stream has been reset"){super(r),this.name="StreamResetError"}},y=class extends Error{static name="StreamAbortedError";constructor(r="The stream has been aborted"){super(r),this.name="StreamAbortedError"}},v=class extends Error{static name="StreamStateError";constructor(r="The stream is in an invalid state"){super(r),this.name="StreamStateError"}},S=class extends Error{static name="StreamBufferError";constructor(r="The stream buffer was full"){super(r),this.name="StreamBufferError"}},I=class extends Error{static name="NotFoundError";constructor(r="Not found"){super(r),this.name="NotFoundError"}},P=class extends Error{static name="InvalidPeerIdError";constructor(r="Invalid PeerID"){super(r),this.name="InvalidPeerIdError"}},A=class extends Error{static name="InvalidMultiaddrError";constructor(r="Invalid multiaddr"){super(r),this.name="InvalidMultiaddrError"}},L=class extends Error{static name="InvalidCIDError";constructor(r="Invalid CID"){super(r),this.name="InvalidCIDError"}},g=class extends Error{static name="InvalidMultihashError";constructor(r="Invalid Multihash"){super(r),this.name="InvalidMultihashError"}},w=class extends Error{static name="UnsupportedProtocolError";constructor(r="Unsupported protocol error"){super(r),this.name="UnsupportedProtocolError"}},T=class extends Error{static name="InvalidMessageError";constructor(r="Invalid message"){super(r),this.name="InvalidMessageError"}},C=class extends Error{static name="ProtocolError";constructor(r="Protocol error"){super(r),this.name="ProtocolError"}},D=class extends Error{static name="TimeoutError";constructor(r="Timed out"){super(r),this.name="TimeoutError"}},M=class extends Error{static name="NotStartedError";constructor(r="Not started"){super(r),this.name="NotStartedError"}},U=class extends Error{static name="AlreadyStartedError";constructor(r="Already started"){super(r),this.name="AlreadyStartedError"}},N=class extends Error{static name="DialError";constructor(r="Dial error"){super(r),this.name="DialError"}},K=class extends Error{static name="ListenError";constructor(r="Listen error"){super(r),this.name="ListenError"}},_=class extends Error{static name="LimitedConnectionError";constructor(r="Limited connection"){super(r),this.name="LimitedConnectionError"}},B=class extends Error{static name="TooManyInboundProtocolStreamsError";constructor(r="Too many inbound protocol streams"){super(r),this.name="TooManyInboundProtocolStreamsError"}},F=class extends Error{static name="TooManyOutboundProtocolStreamsError";constructor(r="Too many outbound protocol streams"){super(r),this.name="TooManyOutboundProtocolStreamsError"}},O=class extends Error{static name="UnsupportedKeyTypeError";constructor(r="Unsupported key type"){super(r),this.name="UnsupportedKeyTypeError"}},R=class extends Error{static name="NotImplementedError";constructor(r="Not implemented"){super(r),this.name="NotImplementedError"}};var q=class extends Event{data;constructor(r,e){super("message",e),this.data=r}},n=class extends Event{error;local;constructor(r,e,s){super("close",s),this.error=e,this.local=r}},V=class extends n{constructor(r,e){super(!0,r,e)}},j=class extends n{constructor(r,e){super(!1,r,e)}};function Q(t){return t==null?!1:(t.type==="RSA"||t.type==="Ed25519"||t.type==="secp256k1"||t.type==="ECDSA")&&t.raw instanceof Uint8Array&&typeof t.equals=="function"&&typeof t.toMultihash=="function"&&typeof t.toCID=="function"&&typeof t.verify=="function"}function ar(t){return t==null?!1:(t.type==="RSA"||t.type==="Ed25519"||t.type==="secp256k1"||t.type==="ECDSA")&&Q(t.publicKey)&&t.raw instanceof Uint8Array&&typeof t.equals=="function"&&typeof t.sign=="function"}var ir=Symbol.for("@libp2p/peer-discovery");var W=Symbol.for("@libp2p/peer-id");function cr(t){return!!t?.[W]}var pr=Symbol.for("@libp2p/peer-routing");var lr="keep-alive";function z(t){return t!=null&&typeof t.start=="function"&&typeof t.stop=="function"}async function ur(...t){let r=[];for(let e of t)z(e)&&r.push(e);await Promise.all(r.map(async e=>{e.beforeStart!=null&&await e.beforeStart()})),await Promise.all(r.map(async e=>{await e.start()})),await Promise.all(r.map(async e=>{e.afterStart!=null&&await e.afterStart()}))}async function mr(...t){let r=[];for(let e of t)z(e)&&r.push(e);await Promise.all(r.map(async e=>{e.beforeStop!=null&&await e.beforeStop()})),await Promise.all(r.map(async e=>{await e.stop()})),await Promise.all(r.map(async e=>{e.afterStop!=null&&await e.afterStop()}))}var X=Symbol.for("@libp2p/transport");function xr(t){return t!=null&&!!t[X]}var G;(function(t){t[t.FATAL_ALL=0]="FATAL_ALL",t[t.NO_FATAL=1]="NO_FATAL"})(G||(G={}));function Y(){}var H=class extends EventTarget{#r=new Map;constructor(){super()}listenerCount(r){let e=this.#r.get(r);return e==null?0:e.length}addEventListener(r,e,s){super.addEventListener(r,e,s);let o=this.#r.get(r);o==null&&(o=[],this.#r.set(r,o)),o.push({callback:e,once:(s!==!0&&s!==!1&&s?.once)??!1})}removeEventListener(r,e,s){super.removeEventListener(r.toString(),e??null,s);let o=this.#r.get(r);o!=null&&(o=o.filter(({callback:Z})=>Z!==e),this.#r.set(r,o))}dispatchEvent(r){let e=super.dispatchEvent(r),s=this.#r.get(r.type);return s==null||(s=s.filter(({once:o})=>!o),this.#r.set(r.type,s)),e}safeDispatchEvent(r,e={}){return this.dispatchEvent(new CustomEvent(r,e))}};var dr=Symbol.for("@libp2p/service-capabilities"),fr=Symbol.for("@libp2p/service-dependencies");return or(Er);})();
return Libp2PInterface}));
//# sourceMappingURL=index.min.js.map
